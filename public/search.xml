<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stanford-CS224n</title>
      <link href="2022/01/26/CS224n/"/>
      <url>2022/01/26/CS224n/</url>
      
        <content type="html"><![CDATA[<p>学习Stanford的CS224n NLP</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Pretrained Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reread *Attention Is All You Need*</title>
      <link href="2022/01/20/attention%20is%20all%20you%20need/"/>
      <url>2022/01/20/attention%20is%20all%20you%20need/</url>
      
        <content type="html"><![CDATA[<p>跟李沐再读《Attention Is All You Need》。(<a href="https://www.bilibili.com/video/BV1pu411o7BE?spm_id_from=333.999.0.0" target="_blank" rel="noopener">视频链接</a>)</p><a id="more"></a><h2 id="Introction"><a href="#Introction" class="headerlink" title="Introction"></a>Introction</h2><ul><li>机器翻译通常使用语言模型和encoder-decoder架构</li><li>RNN的特点：序列从左到右串行，$h_t$取决于$h_{t-1}$和$w_t$。<ul><li>长程依赖问题</li><li>时序的依赖导致难以并行</li></ul></li><li>attention在RNN中的使用<ul><li>解决距离依赖的问题</li></ul></li><li>本文的纯attention模型——Transformer</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ul><li>用CNN代替RNN的工作<ul><li>可以并行计算</li><li>长程依赖依旧难以捕获（卷积核的限制）</li><li><strong>多通道conv</strong>意味着多层次信息 -&gt; Multi-head attention</li></ul></li><li>Attention机制</li><li>memory network</li></ul><h2 id="model-architecture"><a href="#model-architecture" class="headerlink" title="model architecture"></a>model architecture</h2><p><img src="/uploads/upload_94e5630aa8c00c531f241a431f58c5e2.png" alt=""></p><ul><li>encoder-decoder<ul><li>encoder：$(x_1,\dots,x_n)-&gt;(z_1,\dots,z_n)$</li><li>decoder：$(z_1,\dots,z_n)-&gt;(y_1,\dots,y_m)$<ul><li>decoder是auto-regressve的</li></ul></li></ul></li></ul><h3 id="encoder-and-decoder-stacks"><a href="#encoder-and-decoder-stacks" class="headerlink" title="encoder and decoder stacks"></a>encoder and decoder stacks</h3><h4 id="encoder"><a href="#encoder" class="headerlink" title="encoder"></a>encoder</h4><h5 id="encoder架构"><a href="#encoder架构" class="headerlink" title="encoder架构"></a>encoder架构</h5><ul><li>encoder = 6 layers<ul><li>layer = 2 sub-layer<ul><li>multi-head self-attention</li><li>fully connected feed-forward network（MLP）</li></ul></li><li>residual connection<ul><li>$layernorm(x+Sublayer(x))$</li></ul></li><li>每一层输出维度$d_{model}$都为512</li></ul></li></ul><h5 id="LayerNorm-和-BatchNorm"><a href="#LayerNorm-和-BatchNorm" class="headerlink" title="LayerNorm 和 BatchNorm"></a>LayerNorm 和 BatchNorm</h5><ul><li>2-D：输入为$b \times d$<ul><li>BN：对每个特征做norm</li><li>LN：对每个输入做norm</li></ul></li><li>3-D：输入为$b \times n \times d$<ul><li>BN：对每个特征的$b \times n$，同时需要计算全局的方差</li><li>LN：对每个输入$n \times d$，只需对每个样本计算方差</li></ul></li></ul><h4 id="decoder"><a href="#decoder" class="headerlink" title="decoder"></a>decoder</h4><h5 id="decoder架构"><a href="#decoder架构" class="headerlink" title="decoder架构"></a>decoder架构</h5><ul><li>decoder = 6 layers<ul><li>layer = 3 sub-layer<ul><li>multi-head self-attention</li><li>fully connected feed-forward network（MLP）</li><li><strong>maskeded</strong> multi-head attention</li></ul></li></ul></li></ul><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p><img src="/uploads/upload_ba3e07af45d5cd5430f5fe4f54818928.png" alt=""></p><ul><li>attention函数根据query和一系列key-value pairs计算一个output</li><li>output是value的加权和，权重是query和key的相似度，output的维度和value相同</li></ul><h4 id="scaled-dot-product-attention"><a href="#scaled-dot-product-attention" class="headerlink" title="scaled dot-product attention"></a>scaled dot-product attention</h4><ul><li>$q、k$维度都是$d_k$，$v$的维度是$d_v$，则计算$q$和所有$k$的内积再除以$\sqrt{d_k}$，用softmax即可得到attention</li><li>matrix形式：<br>${\rm Attention}(Q,K,V)={\rm softmax}(\frac{QK_T}{\sqrt{d_k}})V$</li><li>除以$\sqrt{d_k}$是为了缩小点积结果的差距，否则softmax很接近max，梯度难以传播</li></ul><h4 id="multi-head-attention"><a href="#multi-head-attention" class="headerlink" title="multi-head attention"></a>multi-head attention</h4><ul><li>将$q、k、v$用可训练的MLP投影到多个低维空间<br>${\rm MultiHead}(Q,K,V) = {\rm Concat(head_1,\dots,head_h)}W^O,\\ {\rm head_i=Attention}(QW_i^Q,KW_i^K,VW_i^V)$</li></ul><h4 id="application-of-attention-in-Transformer"><a href="#application-of-attention-in-Transformer" class="headerlink" title="application of attention in Transformer"></a>application of attention in Transformer</h4><ul><li>encoder的multi-head self-attention<ul><li>输入同时作为q、k、v</li></ul></li><li>decoder的masked multi-head self-attention<ul><li>当前输出后的部分mask掉</li></ul></li><li>decoder的multi-head attention<ul><li>k和v来自encoder的输出，q来自decoder中masked attention输出</li><li>有效提取encoder输出中的有效部分</li></ul></li></ul><h3 id="position-wise-feed-forward-network"><a href="#position-wise-feed-forward-network" class="headerlink" title="position-wise feed-forward network"></a>position-wise feed-forward network</h3><ul><li><p>是双层的MLP：${\rm FFN}(x)={\rm max}(0,xW_1+b_1)W_2+b_2$</p></li><li><p>经过attention后已经汇聚了序列信息，因此每个向量可以单独通过MLP（并行）</p></li><li><p>RNN和Transformer（图源：李沐）<br><img src="/uploads/upload_1f6bdcf108f7e5185d2899c9038615c8.png" alt=""></p></li></ul><h3 id="embedding-and-softmax"><a href="#embedding-and-softmax" class="headerlink" title="embedding and softmax"></a>embedding and softmax</h3><p>乘$\sqrt{d}$</p><h3 id="positional-encoding"><a href="#positional-encoding" class="headerlink" title="positional encoding"></a>positional encoding</h3><ul><li>attention不包含时序信息<ul><li>打乱顺序后attention是不变的</li></ul></li><li>在输入中添加时序信息</li><li>对位置的数字作embedding<br>$PE_{(pos,2i)}=sin(pos/10000^{2i/d_{model}})$<br>$PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_{model}})$</li></ul><h2 id="Why-self-attention"><a href="#Why-self-attention" class="headerlink" title="Why self-attention"></a>Why self-attention</h2><p><img src="/uploads/upload_b623ebb8d122a7f541215896dab6d4d5.png" alt=""></p><ul><li>CNN的Maximum Path Length：在不同kernel内需要到高层卷积才能传递</li></ul><h2 id="experiment"><a href="#experiment" class="headerlink" title="experiment"></a>experiment</h2><h3 id="optimizer"><a href="#optimizer" class="headerlink" title="optimizer"></a>optimizer</h3><ul><li>Adam optimizer</li><li>$\beta_1=0.9,\ \beta_2=0.98,\ \epsilon=10^{-9}$</li><li>$lr=d_{model}^{-0.5}\cdot min(step_num^{-0.5},step_num\cdot warmup_steps^{-1.5})$<ul><li>warmup机制：从一个小lr慢慢爬到大lr，之后再衰减</li><li>$warmup_steps=4000$</li></ul></li></ul><h3 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h3><h4 id="residual-dropout"><a href="#residual-dropout" class="headerlink" title="residual dropout"></a>residual dropout</h4><ul><li>对每个sub-layer的输出，进入residual connection和layernorm之前，做dropout</li><li>输入➕word embedding➕position embedding时，做dropout</li><li>label smoothing：正确的label score削减为$\epsilon_{ls}=0.1$</li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
          <category> Transformer </category>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Transformer </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（EMNLP2019） Heterogeneous Graph Attention Networks for Semi-supervised Short Text Classification</title>
      <link href="2021/11/27/%EF%BC%88EMNLP2019%EF%BC%89%20Heterogeneous%20Graph%20Attention%20Networks%20for%20Semi-supervised%20Short%20Text%20Classification/"/>
      <url>2021/11/27/%EF%BC%88EMNLP2019%EF%BC%89%20Heterogeneous%20Graph%20Attention%20Networks%20for%20Semi-supervised%20Short%20Text%20Classification/</url>
      
        <content type="html"><![CDATA[<p>来自北邮团队，提出了可以集成多种额外信息的HIN和dual-level的GAT，利用附加信息帮助半监督STC。在AGNews上由TextGCN的67.67涨到72.10。</p><a id="more"></a><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20211206140728.png" alt=""></p><h3 id="HIN-for-STC"><a href="#HIN-for-STC" class="headerlink" title="HIN for STC"></a>HIN for STC</h3><p><a href="https://arxiv.org/pdf/1809.03664.pdf" target="_blank" rel="noopener">Topic Memory Networks for Short Text Classification</a>提出生成latent topic，一些方法中利用KB获取额外知识，以期充实short text的语义信息，这些方法忽视了short text中重要的entity信息。</p><p>该文章提出的HIN例子使用了topic和entity信息：</p><ul><li>topic通过LDA提取，text包含topic即构建edge</li><li>entity通过TAGME工具抽取，先使用w2v embedding，$cos(word_i, entity)&gt;\delta$则构建edge，node embedding用w2v+TF-IDF init</li></ul><h3 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h3><p>topic-text-entity Graph中异质节点embedding 维度不同，不能直接aggregate。concatenate方法（其他类型的axis上为0）忽略不同，</p><script type="math/tex; mode=display">H^{(l+1)}=\sigma(\Sigma_{\tau\in\Tau}\widetilde{A}_\tau \cdot H_\tau^{(l)} \cdot W_\tau^{(l)}),\\where\   \widetilde{A}_\tau\in\mathbb{R}^{|V|\times|V_\tau|} \text{ is the submatrix of }\widetilde{A}</script><p>子邻接矩阵$\hat{A}$的row表示所有node，col表示类型为$\tau$的邻node。</p><p>通过不同的转换矩阵$W_\tau$将不同类型的node embedding投影到相同空间，从而聚合到$H^{(l+1)}$</p><h3 id="dual-level-attention"><a href="#dual-level-attention" class="headerlink" title="dual-level attention"></a>dual-level attention</h3><h4 id="type-level"><a href="#type-level" class="headerlink" title="type-level"></a>type-level</h4><p>对节点$v$，计算其所有type $\tau$的邻节点embedding之和$h_\tau$：</p><script type="math/tex; mode=display">h_\tau=\Sigma_{v'}\widetilde{A}_{vv'}h_{v'}</script><p>用$h_\tau$计算type $\tau$的attention：</p><script type="math/tex; mode=display">a_\tau=\sigma(\mu_\tau^T \cdot [h_v||h_\tau])</script><p>计算type-level attention值：</p><script type="math/tex; mode=display">\alpha_\tau=\frac{exp(a_\tau)}{\Sigma_{\tau'\in\Tau}exp(a_{\tau'})}</script><h4 id="node-level"><a href="#node-level" class="headerlink" title="node-level"></a>node-level</h4><p>对节点$v$，计算其与拥有type $\tau’$的邻节点$v’$的attention：<script type="math/tex">b_{vv'}=\sigma(v^T \cdot \alpha_{\tau'}[h_v||h_{v'}])</script></p><p>计算node-level attention值：</p><script type="math/tex; mode=display">\beta_\tau=\frac{exp(b_{vv'})}{\Sigma_{i\in\mathcal{N_v}}exp(b_{vi})}</script><p>propagation：</p><script type="math/tex; mode=display">H^{(l+1)}=\sigma(\Sigma_{\tau\in\Tau}\mathcal{B_\tau}\cdot H_\tau^{(l)}\cdot W_\tau^{(l)})</script><h3 id="train-loss"><a href="#train-loss" class="headerlink" title="train loss"></a>train loss</h3><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20211206142149.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 短文本分类 </category>
          
          <category> GNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HGAT </tag>
            
            <tag> GNN </tag>
            
            <tag> 短文本分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法（五）--决策树</title>
      <link href="2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>决策树（design tree）是一种基本的分类与回归方法。 是if-then规则的集合或者定义在特征空间与类空间上的条件概率分布。</p><a id="more"></a><h3 id="决策树模型与学习"><a href="#决策树模型与学习" class="headerlink" title="决策树模型与学习"></a>决策树模型与学习</h3><h4 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h4><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127185427.png" alt=""></p><h4 id="if-then规则"><a href="#if-then规则" class="headerlink" title="if-then规则"></a>if-then规则</h4><p>由决策树的根结点到叶结点的每一条路径构建一条规则，路径上内部结点的特征对应规则的条件，叶结点的类对应规则的结论。</p><p>规则集合互斥且完备。</p><h4 id="条件概率分布"><a href="#条件概率分布" class="headerlink" title="条件概率分布"></a>条件概率分布</h4><p>决策树还表示给定特征条件下类的条件率分布，将特征空间划分为互不相交的单元，在每个单元定义一个类的概率分布。决策树表示的条件概率分布由<strong>各个单元给定条件下类的条件概率分布</strong>组成。当某个单元的条件概率$P(Y=+1|X=c)&gt;0.5$时，则归为正类。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127212346.png" alt=""></p><h4 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h4><p>本质上是从训练集归纳出分类规则——得到与训练集矛盾较小的决策树 或 由训练集估计条件概率模型。</p><p>选取最优决策树是NP完全问题，通常采用启发式方法近似求解。</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>选取对训练数据具有分类能力的特征，特征选择的准则是信息增益or信息增益比。</p><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>熵表示随机变量不确定性的度量：</p><script type="math/tex; mode=display">H(p)=-\Sigma^n_{i=1} p_i log\ p_i</script><p>条件熵$H(Y|X)$表示在已知随机变量X的条件下随机变量Y的不确定性：</p><script type="math/tex; mode=display">H(Y|X)=\Sigma^n_{i=1} p_i H(Y|X=x_i)</script><p>信息增益表示得知特征X的信息使得Y的信息不确定性减少的程度——等价于训练集类与特征的互信息：</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script><p>特征选择时计算每个特征的信息增益，选择最大的特征。</p><h4 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h4><p>使用信息增益可能会偏向选择取值较多的特征。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128140531.png" alt=""></p><h3 id="决策树生成"><a href="#决策树生成" class="headerlink" title="决策树生成"></a>决策树生成</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>在决策树各个结点上以<strong>信息增益</strong>为准则</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128154959.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128155020.png" alt=""></p><p>ID3算法只有树的生成，没有剪枝，容易过拟合。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><p>C4.5与ID3算法相似，但用信息增益比来选择特征</p><h3 id="决策树剪枝"><a href="#决策树剪枝" class="headerlink" title="决策树剪枝"></a>决策树剪枝</h3><p>从已生成的树熵裁掉一些子树/叶结点，回退到其根节点/父节点，简化分类树模型，避免过拟合。</p><p>剪枝通过极小化决策树损失函数实现，树T的叶结点个数为$|T|$，$t$是树$T$的叶结点，该叶节点上由$N_t$个样本点，其中k类点有$N_{tk}$个，$H_t(T)$为叶结点$t$的经验熵，$\alpha \ge 0$为参数，则损失函数为</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128160732.png" alt=""></p><p>剪枝即在$\alpha$确定时选择损失函数最小的模型——子树越大，训练集拟合效果越好，但复杂度也更高，损失函数是对两者的平衡。</p><h4 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h4><p>输入：生成算法产生的整个树$T$，参数$\alpha$</p><p>输出：修剪后的子树$T_a$</p><ul><li>计算每个结点的经验熵</li><li>递归地从叶结点向上回缩</li><li>计算损失函数，变小则剪枝</li></ul><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><p>决策树生成是递归构建二叉决策树的过程。</p><h4 id="CART生成"><a href="#CART生成" class="headerlink" title="CART生成"></a>CART生成</h4><h5 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h5><p>用平方误差最小化准则进行特征选择</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128165754.png" alt=""></p><h5 id="分类树"><a href="#分类树" class="headerlink" title="分类树"></a>分类树</h5><p>分类树用基尼指数最小化准则进行特征选择。</p><blockquote><p>基尼指数：分类问题中，有K个类，样本点属于第k类的概率为$p_k$，则概率分布的基尼系数为$Gini(p) = \sum_{k=1}^Kp_k(1-p_k) = 1 - \sum_{k=1}^Kp_k^2$</p><p>K=2时，$Gini(p)=2p(1-p)$</p></blockquote><p>如果样本集合D根据特征A是否取某一可能值a进行分割，即</p><script type="math/tex; mode=display">D_1 = \{(x,y)\in D|A(x)=a\}, \quad D_2 = D - D_1</script><p>则在特征A的条件下，集合D的基尼指数定义为：</p><script type="math/tex; mode=display">Gini(D,A) = \frac {|D_1|} {D} Gini(D_1)+\frac {|D_2|} {D} Gini(D_2)</script><p>$Gini(D)$表示集合D的不确定性，$Gini(D,A)$表示$A=a$分割后集合D的不确定性，基尼指数和熵的一半很接近。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128170900.png" alt=""></p><h4 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h4><ul><li><p>从生成算法产生的决策树$T_0$底端开始不断剪枝，直到根节点，形成一个子树序列${T_0,T_1,\cdots,T_n}$</p><blockquote><p>从$T_0$开始剪枝，对其中每一内部结点，计算$g(t)=\frac {C(t)-C(T_t)} {|T_t|-1}$，表示剪枝后损失函数减小的程度（负数），将最小的$g(t)$对应的$T_t$减去，得到子树$T_1$，并置$\alpha_1=g(t)$，该子树就是$[\alpha_1,\alpha_2)$上的最优子树</p></blockquote></li><li><p>交叉验证选择最优子树</p></li></ul><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210128173217.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 统计学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 - 统计学习方法 </tag>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法（四）--朴素贝叶斯</title>
      <link href="2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
      <url>2021/01/27/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<p>朴素贝叶斯（naive Bayes）是基于Bayes定理与特征条件独立假设的分类方法。基于特征条件独立假设学习输入输出的联合概率分布，然后基于此模型对给定输入x利用Bayes定理求出后验概率最大的输出y。</p><a id="more"></a><h3 id="朴素贝叶斯法的学习与分类"><a href="#朴素贝叶斯法的学习与分类" class="headerlink" title="朴素贝叶斯法的学习与分类"></a>朴素贝叶斯法的学习与分类</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>朴素贝叶斯法通过训练集学习联合概率分布$P(X,Y)$——学习先验概率分布和条件概率分布：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127122636.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127122653.png" alt=""></p><p>条件概率分布有指数级的参数，因此朴素贝叶斯法做了条件独立性假设（强假设）：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127123020.png" alt=""></p><p>朴素贝叶斯法属于生成模型，分类时将后验概率最大的类作为输出</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127132816.png" alt=""></p><p>则朴素贝叶斯分类器表示为：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127132858.png" alt=""></p><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><p>用极大似然估计学习$P(Y=c_k)$和$P(X^{(j)=x^{(j)}}|Y=c_k)$</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127135740.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127135754.png" alt=""></p><h4 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h4><ul><li>计算先验概率与条件概率</li><li>计算<img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127140015.png" alt=""></li><li>确定y</li></ul><h4 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h4><p>极大似然估计可能会出现概率为0的情况，影响后验概率计算，采用贝叶斯估计解决问题：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127140148.png" alt=""></p><p>$S_j$为第j个特征可能取值的数目，$\lambda=1$时为拉普拉斯平滑。</p><p>先验概率的贝叶斯估计为：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127140350.png" alt=""></p><p>$K$为类数。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 - 统计学习方法 </tag>
            
            <tag> 朴素贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法（三）--K近邻法</title>
      <link href="2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89-K%E8%BF%91%E9%82%BB%E6%B3%95/"/>
      <url>2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89-K%E8%BF%91%E9%82%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>k近邻法是一种基本分类与回归方法，输入特征向量，输出类别（可以取多类）。分类时，对新实例根据其k个最近邻的训练实例的类别，通过多数表决进行预测，不具有显式的学习过程。</p><a id="more"></a><h3 id="k近邻算法"><a href="#k近邻算法" class="headerlink" title="k近邻算法"></a>k近邻算法</h3><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126183555.png" alt=""></p><h3 id="k近邻模型"><a href="#k近邻模型" class="headerlink" title="k近邻模型"></a>k近邻模型</h3><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>每个训练实例附近的点组成一个cell，这些cell对特征空间进行划分，每个cell中的类相同。</p><h4 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h4><p>一般是在$R^n$上使用欧氏距离，也可以是更一般的$L_p$距离或Minkowski距离。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126184044.png" alt=""></p><ul><li>p=1时是曼哈顿距离</li><li>p=2时是欧氏距离</li><li>p=∞时是各个坐标距离的最大值</li></ul><h4 id="K值选择"><a href="#K值选择" class="headerlink" title="K值选择"></a>K值选择</h4><ul><li>k较小，近似误差减小——只有与输入相近的点起作用，估计误差增大——对相近的点很敏感，模型变得复杂，<strong>易过拟合</strong>。</li><li>k较大，近似误差增大，估计误差减小，模型更简单</li></ul><p>一般取比较小的k，用交叉验证选取最优的k。</p><h4 id="分类决策规则"><a href="#分类决策规则" class="headerlink" title="分类决策规则"></a>分类决策规则</h4><p>通常是多数表决</p><h3 id="k近邻法的实现：kd树"><a href="#k近邻法的实现：kd树" class="headerlink" title="k近邻法的实现：kd树"></a>k近邻法的实现：kd树</h3><p>kd树是二叉树，表示对k维空间的一个划分。</p><h4 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a>构造kd树</h4><p>不断用垂直于坐标轴的超平面划分k维空间，构成超矩形区域，每个结点对应一个超矩形。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126185918.png" alt=""></p><h4 id="搜索kd树"><a href="#搜索kd树" class="headerlink" title="搜索kd树"></a>搜索kd树</h4><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210127002310.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 统计学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 - 统计学习方法 </tag>
            
            <tag> kNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法（二）--感知机</title>
      <link href="2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>感知机是二分类的线性分类模型，输入特征向量，输出±1。感知机旨在求出将训练数据线性划分的超平面，属于判别模型。</p><a id="more"></a><h3 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h3><h4 id="感知机定义"><a href="#感知机定义" class="headerlink" title="感知机定义"></a>感知机定义</h4><p>感知机$f(x)=sign(w \cdot x + b)$，$w \in R^n$为权值向量，$b \in R$为偏置</p><h4 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h4><p>线性方程$w \cdot x + b = 0$ 是特征空间$R^n$的一个分离超平面，位于其两边的点被分为正负两类</p><h3 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h3><h4 id="数据集的线性可分性"><a href="#数据集的线性可分性" class="headerlink" title="数据集的线性可分性"></a>数据集的线性可分性</h4><p>存在某个超平面S能够将数据集的正负实例点完全正确地划分，则称数据集为<strong>线性可分数据集</strong>。</p><h4 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h4><p>损失函数为误分类点到超平面S的总距离，任一点$x_0$到S的距离为：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123204605.png" alt=""></p><p>则误分类点集合$M$到S的总距离为</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123204708.png" alt=""></p><p>那么感知机学习的损失函数为</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123204753.png" alt=""></p><h3 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h3><p>感知机学习问题转化为$L(w,b)$的最优化问题。</p><h4 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h4><p>采用随机梯度下降法，任意选取一个超平面$w_0,b_0$，采用梯度下降法不断极小化损失函数，极小化过程中每次随机选取一个误分类点使其梯度下降，直至训练集中没有误分类点。</p><p>从几何意义上解释即每次调整$w,b$会是超平面向该误分类点侧移动，直至超平面越过该误分类点。</p><p>当训练集线性可分时，感知机学习算法原始形式迭代收敛，存在许多解，依赖于初值和选择顺序；线性不可分时，感知机学习算法不收敛，迭代结果发生震荡。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123211542.png" alt=""></p><h4 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h4><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123211621.png" alt=""></p><p>对偶形式中训练集仅以内积($x_j \cdot x_i$)出现。</p>]]></content>
      
      
      <categories>
          
          <category> 统计学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 - 统计学习方法 </tag>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法（一）--统计学习概论</title>
      <link href="2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
      <url>2021/01/23/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>重新系统学习《统计学习方法》。<br><a id="more"></a></p><h3 id="统计学习的方法"><a href="#统计学习的方法" class="headerlink" title="统计学习的方法"></a>统计学习的方法</h3><p>从给定的、有限的、用于学习的训练数据（Training data）集合出发，假设数据是<strong>独立同分布</strong>；假设要学习的模型属于某个函数的集合（假设空间）；应用某个评价准则从假设空间中选取最优模型。</p><p>三要素：</p><ul><li>模型：模型的假设空间</li><li>策略：模型选择的准则</li><li>算法：模型学习的算法</li></ul><h3 id="统计学习的分类"><a href="#统计学习的分类" class="headerlink" title="统计学习的分类"></a>统计学习的分类</h3><h4 id="监督学习（supervised-learning）"><a href="#监督学习（supervised-learning）" class="headerlink" title="监督学习（supervised learning）"></a>监督学习（supervised learning）</h4><p>从<strong>标注数据</strong>中学习预测模型，监督学习的本质是<strong>学习输入到输出的映射的统计规律</strong>。实例从输入空间映射到特征空间。</p><p>监督学习假设输入与输入的随机变量 $X$ 和 $Y$ 遵循联合分布概率 $ P(X,Y) $，统计学习假设数据存在一定的统计规律，$X$ 和 $Y$ 具有联合概率分布就是监督学习关于数据的基本假设。</p><p>监督学习的模型可以是概率模型或非概率模型，由条件概率分布 $P(Y|X)$ 或决策函数 $Y=f(X)$ 表示。</p><p>监督学习分为 <strong>学习</strong> 和 <strong>预测</strong> 两个过程，学习系统利用给定的训练数据集，通过学习（训练）得到一个模型，表示为条件概率分布 $\hat{P}(Y|X)$ 或决策函数 $Y=\hat{f}(X)$ ，在预测过程中，对于给定的输入$x_{N+1}$，由模型$y_{N+1}=\underset{y}{\mathrm{argmax}} \hat{P}(y|x_{N+1})$ 或 $y_{N+1}=\hat{f}(x_{N+1})$ 给出相应的输出 $y_{N+1}$。</p><h4 id="无监督学习（unsupervised-learning）"><a href="#无监督学习（unsupervised-learning）" class="headerlink" title="无监督学习（unsupervised learning）"></a>无监督学习（unsupervised learning）</h4><p>从<strong>无标注模型</strong>中学习预测模型，无标注数据是自然得到的数据，预测模型表示数据的类别、转换或概率。无监督学习的本质是<strong>学习数据中的统计规律或潜在结构</strong>。</p><p>无监督学习的输出是对输入的分析结果，由输入的类别、转换或概率表示。模型可以实现对数据的<strong>聚类、降维或概率估计</strong>。</p><p>无监督学习中的模型可以表示为函数 $z=g(x)$，条件概率分布 $P(z|x)$ 或条件概率分布 $P(x|z)$ 的形式。在预测过程中，对于给定输入$x_{N+1}$ ，由模型 $z_{N+1}=\hat{g}(x_{N+1})$ 或 $z_{N+1}=\underset{z} {\mathrm {argmax}} \hat{P}(z|x_{N+1})$ 给出相应的输出 $z_{N+1}$，进行聚类或降维；由模型 $\hat{P}(x|z)$ 给出输入的概率 $\hat{P}(x_{N+1}|z_{N+1})$，进行概率估计。</p><h4 id="强化学习（reinforcement-learning）"><a href="#强化学习（reinforcement-learning）" class="headerlink" title="强化学习（reinforcement learning）"></a>强化学习（reinforcement learning）</h4><p>指智能系统在于环境的<strong>连续互动</strong>中学习最优行为策略的机器学习问题。假设智能系统与环境的互动基于马尔可夫决策过程，智能系统观测到的是与环境互动得到的数据序列。强化学习的本质是<strong>学习最优的序贯决策</strong>。</p><p>智能系统与环境的互动中，在每一步 $t$，智能系统从环境中观测到一个状态(State) $s_t$与一个奖励(reward) $r_t$，采取一个动作(action) $a_t$。环境根据智能系统选择的动作，决定下一步 $t+1$ 的状态 $s_{t+1}$ 与奖励 $r_{t+1}$。要学习的策略表示为给定的状态下采取的动作。智能系统不追求短期奖励的最大化，目标是<strong>长期累积奖励的最大化</strong>。强化学习过程中，不断<strong>试错</strong> (trial and error)，以达到学习最优策略的目的。</p><p>马尔科夫决策过程$<S,A,P,r,\gamma>$：</p><ul><li>有限状态集$S$</li><li>有限动作集$A$</li><li>状态转移概率函数$P(s’|s,a)$</li><li>奖励函数$r(s,a)=E(r_{t+1}|s_t=s,a_t=a)$</li><li>衰减系数$\gamma$</li></ul><p>策略$\pi$为给定状态下的动作函数或条件概率分布，</p><p>状态价值函数为策略$\pi$从某一状态始的长期累计奖励的数学期望$v_\pi(s)=E_\pi[r_{t+1}+\gamma r_{t+2} \cdots|s_t=s]$</p><p>动作价值函数为$\pi$从某一状态和动作始的长期累计奖励的数学期望$q_\pi(s)=E_\pi[r_{t+1}+\gamma r_{t+2} \cdots|s_t=s,a_t=a]$</p><p>强化学习的目标是选出价值函数最大的$\pi^*$：</p><ul><li>有模型方法：直接学习Markov过程的P和r</li><li>无模型方法：<ul><li>基于策略的：学习策略即动作函数/条件概率分布</li><li>基于价值的：学习最优价值函数，尤其是最优动作价值函数</li></ul></li></ul><h4 id="半监督学习（semi-supervised-learning）与主动学习（active-learning）"><a href="#半监督学习（semi-supervised-learning）与主动学习（active-learning）" class="headerlink" title="半监督学习（semi-supervised learning）与主动学习（active learning）"></a>半监督学习（semi-supervised learning）与主动学习（active learning）</h4><p>前者是利用大量未标注数据中的信息，辅助少量的标注数据进行监督学习，后者机器主动找出对学习最有帮助的实例让用户标注，降低标注代价。</p><h3 id="统计学习方法三要素"><a href="#统计学习方法三要素" class="headerlink" title="统计学习方法三要素"></a>统计学习方法三要素</h3><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>要学习什么样的模型，模型空间包括所有可能的条件概率分布/决策函数</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>要按照什么样的准则学习模型</p><h5 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h5><p>度量模型一次预测的好坏（错误的程度），常用的损失函数有：</p><ul><li><p>0-1损失函数</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123002846.png" alt=""></p></li><li><p>平方损失函数</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123003007.png" alt=""></p></li><li><p>绝对损失函数</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123003017.png" alt=""></p></li><li><p>对数损失函数/对数似然损失函数</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123003028.png" alt=""></p></li></ul><h5 id="期望风险"><a href="#期望风险" class="headerlink" title="期望风险"></a>期望风险</h5><p>损失函数值越小，模型越好，模型输入输出$(X,Y)$遵循联合分布$P(X,Y)$，所以损失函数的期望即风险函数/期望损失为：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123145103.png" alt=""></p><p>学习的目标是选择期望风险最小的模型，学习模型需要用到联合分布，而联合分布却未知，因此监督学习是一个病态问题（ill-formed problem）。</p><p>根据大叔定律，当样本容量N区域无穷时，经验风险趋于期望风险，即用训练集损失估计期望损失：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123145500.png" alt=""></p><h5 id="经验风险最小化与结构风险最小化"><a href="#经验风险最小化与结构风险最小化" class="headerlink" title="经验风险最小化与结构风险最小化"></a>经验风险最小化与结构风险最小化</h5><p>样本容量足够大，经验风险最小化（empirical risk minimization。ERM）效果很好，而容量较小时会过拟合（over-fitting）。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123150313.png" alt=""></p><p>结构风险最小化（structural risk minimization，SRM）是为防止过拟合而提出的策略，等价于正则化（regularization），在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）：</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123150329.png" alt=""></p><p>$J(f)$为模型复杂度，$\lambda$是权衡经验风险和模型复杂度的系数——结构风险小需要经验风险与模型复杂度同时小。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123150347.png" alt=""></p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>即最优化算法</p><h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><h4 id="训练误差与测试误差"><a href="#训练误差与测试误差" class="headerlink" title="训练误差与测试误差"></a>训练误差与测试误差</h4><p>在训练集和测试集上的平均损失</p><h4 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h4><p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度往往会比真模型更高。出现过拟合（over-fitting）</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123163644.png" alt=""></p><h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><p>在学习时<strong>防止过拟合</strong>的两种常用<strong>模型选择方法</strong></p><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p><a href="#经验风险最小化与结构风险最小化">正则化</a>的作用是选择经验风险与模型复杂度同时较小的模型。正则化符合奥卡姆剃刀原理，对应于模型的先验概率，即复杂模型有较小的先验概率。</p><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><ul><li>简单交叉验证：随机划分</li><li>S折交叉验证（S-fold cross validation）：随即划分为S个互不相交、大小相同的子集，用S-1个子集的数据训练模型，余下的子集测试模型，重复进行，从S个模型中选出最好的</li><li>留一交叉验证：S-fold的极端情况，S=N，数据缺乏时使用</li></ul><h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><h4 id="泛化误差（generalization-error）"><a href="#泛化误差（generalization-error）" class="headerlink" title="泛化误差（generalization error）"></a>泛化误差（generalization error）</h4><p>对未知数据预测的误差——所学到模型的期望风险</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210123173138.png" alt=""></p><h4 id="泛化误差上界（generalization-error-bound）"><a href="#泛化误差上界（generalization-error-bound）" class="headerlink" title="泛化误差上界（generalization error bound）"></a>泛化误差上界（generalization error bound）</h4><p>通过比较学习方法的泛化误差上界比较它们的优劣。</p><ul><li>样本容量增加时，泛化误差上界趋于0</li><li>假设空间容量越大，泛化误差上界越大</li></ul><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>监督学习方法分为生成方法与判别方法。</p><ul><li>生成方法学习联合概率分布，关心的是X-&gt;Y的生成关系。收敛速度快，且适用于存在隐变量的情况。</li><li>判别方法学习决策函数/条件概率分布，关心的是对给定的X，应该预测什么样的Y。准确率更高，可以简化学习问题。</li></ul><h3 id="监督学习的应用——分类、标注、回归"><a href="#监督学习的应用——分类、标注、回归" class="headerlink" title="监督学习的应用——分类、标注、回归"></a>监督学习的应用——分类、标注、回归</h3><h4 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h4><p>分类准确率accuracy：正确分类样本数/总样本数</p><ul><li>TP——正类预测为正类</li><li>FN——正类预测为负类</li><li>TN——负类预测为负类</li><li>FP——负类预测为正类</li></ul><p>精确率precision：$P= \frac {TP} {TP+FP}$</p><p>召回率recall：$R= \frac {TP} {TP+FN}$</p><p>F1：精确率与召回率的调和均值 $\frac 2 {F_1} = \frac 1 P + \frac 1 R$</p><h4 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h4><p>可以看作分类问题的推广，输入观测序列，输出标记序列。NLP中的词性标注是典型的标注问题</p><h4 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h4><p>预测输入输出之间的关系，即映射函数的拟合</p>]]></content>
      
      
      <categories>
          
          <category> 统计学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 统计学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Query2Box:Reasoning Over KG in Vector Space Using Box Embeddings</title>
      <link href="2020/12/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Query2Box-Reasoning%20Over%20KG%20in%20Vector%20Space%20Using%20Box%20Embeddings/"/>
      <url>2020/12/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Query2Box-Reasoning%20Over%20KG%20in%20Vector%20Space%20Using%20Box%20Embeddings/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://arxiv.org/abs/2002.05969" target="_blank" rel="noopener">Query2Box:Reasoning Over KG in Vector Space Using Box Embeddings</a></p><p>主要思路是（1）将query转换为实体、关系间的逻辑运算；（2）在嵌入空间上定义逻辑运算；（3）用实体和关系的嵌入向量，通过逻辑运算得到query的嵌入向量；（4）定义距离函数，查找离query近（本文为在box中）的实体，即为推理的答案。</p><a id="more"></a><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>最近在大规模KG上回答query的一种典型方法是将KG实体和query嵌入到向量空间中，答案实体在嵌入向量空间中会和query很近。</p><p>先前工作将query投影成<strong>单点</strong>，但复杂查询的answer会是一个潜在的大集合。</p><p>先前工作只能处理合取$\wedge$和存在$\exists$，对<strong>析取$\vee $</strong>查询的处理仍未解决。</p><p>本文提出的Query2box<strong>将query嵌入为box超矩形框，box内的一组点对应于一组答案实体</strong>，作者证明了合取可以天然地表示为boxes地交集，但处理析取需要embedding的维度和KG实体数成比例。但是，通过将query转换为<strong>析取范式</strong>，Query2box能以可扩展方式处理合取、析取和存在逻辑查询。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>一阶逻辑查询可以表示为有向无环图DAG，并可以根据DAG进行推理，缺点是（1）<strong>子图匹配的计算复杂度和query size成指数关系</strong>，这会影响到向大规模KG的扩展；<strong>（2）子图匹配非常敏感，因为它不能正确地回答缺少关系的查询</strong>。为了解决第二个问题，可以对KG中缺失的关系进行补全，但是这样会使得KG更加稠密，这就加剧了第一个问题。</p><p>Embedding方法将<strong>逻辑查询和KG实体嵌入到低维向量空间中</strong>，而答案会在query附近，这种方法可以鲁棒地补全关系，且速度很快，因为回答任意的逻辑查询被简化为了识别在向量空间中最接近于query嵌入向量的实体。</p><p><img src="C:\Users\deng\AppData\Roaming\Typora\typora-user-images\image-20201205231045331.png" alt="image-20201205231045331"></p><p>先前工作中（1）<strong>将query嵌入到向量空间的单点</strong>，而回答一个query需要遍历KG并建立一个active实体集，且如何有效地将一个集合建模成一个单点还是有待研究的。（2）<strong>在向量空间中定义两个点的逻辑操作符（例如 集合交集）也是不自然的</strong>。（3）<strong>只能处理conjuctive queries，是一阶逻辑中的子集，包含合取$\wedge$和存在$\exists$，但不包括析取$\vee$</strong>。在向量空间有效地处理析取逻辑还是一个有待解决的问题。</p><hr><p>本文中提出的query2box能以可扩展方式处理任意EPFO（Existential Positive First-order）逻辑查询（包含任意$\wedge、\exists、 \vee$的查询）。关键思想是使用向量空间中的封闭区域box而非单点来表示query（Figure1-D），如此（1）<strong>Boxes可以自然地对其包含的实体进行建模</strong>；（2）<strong>逻辑运算符（例如 集合交集）在box上的定义也很自然，就像venn图一样</strong>；（3）<strong>在box上执行逻辑运算符就会产生新的box，这意味着操作符是封闭的，通过逻辑计算迭代box可以高效地执行推理</strong>。</p><p>作者证明了query2box可以很自然地处理conjunctive query，也证明了将EPFO查询嵌入到单个点或box中需要与KG实体数量成比例地嵌入向量尺寸，难以实现。本文的解决方案是<strong>将EPFO查询转化为析取范式（DNF）</strong>，将其表示成一组boxes，<strong>每个box对应DNF中的一个conjunctive query，再将最近的实体作为查询答案返回，即回答多个EPFO取并集再找最近实体。</strong></p><p>（boxes本质上是向量空间中的venn图，但box是和嵌入共同学习的。）</p><h3 id="QUERY2BOX-LOGICAL-REASONING-OVER-KGS-IN-VECTOR-SPACE"><a href="#QUERY2BOX-LOGICAL-REASONING-OVER-KGS-IN-VECTOR-SPACE" class="headerlink" title="QUERY2BOX: LOGICAL REASONING OVER KGS IN VECTOR SPACE"></a>QUERY2BOX: LOGICAL REASONING OVER KGS IN VECTOR SPACE</h3><h4 id="KNOWLEDGE-GRAPHS-AND-CONJUNCTIVE-QUERIES"><a href="#KNOWLEDGE-GRAPHS-AND-CONJUNCTIVE-QUERIES" class="headerlink" title="KNOWLEDGE GRAPHS AND CONJUNCTIVE QUERIES"></a>KNOWLEDGE GRAPHS AND CONJUNCTIVE QUERIES</h4><p>KG：$\mathcal{G=(V,R)，\\ V表示实体，\\ R:V\times V \rightarrow \{true,false\}表示两实体之间是否存在有向边}$</p><p>Conjunctive queries: 使用$\exists、\wedge$操作的一阶逻辑查询的子类，表示如下</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206111851.png" alt=""></p><p>$v_a$表示<strong>不变锚实体</strong>，$V_1,…,V_k$是量化的边界变量（<strong>quantified bound variables</strong>）,$V_?$ 是<strong>目标变量实体</strong>。回答查询q的目标是$找到一个实体集[q] \subseteq \mathcal{V} 使得 v\in[q]当且仅当(iff) q[v]=True$，$[q]$就是query的答案集。</p><p>从DAG(Figure1-A)可以得到计算图(Figure1-B)，其中包含了Projection和Intersection两种计算。</p><p>对给定的查询q，计算图<strong>将推理过程转换为通过计算得到答案实体集的过程</strong>，即从锚节点集合出发，迭代使用两种运算直至到达唯一的目标节点。</p><h4 id="REASONING-OVER-SETS-OF-ENTITIES-USING-BOX-EMBEDDINGS"><a href="#REASONING-OVER-SETS-OF-ENTITIES-USING-BOX-EMBEDDINGS" class="headerlink" title="REASONING OVER SETS OF ENTITIES USING BOX EMBEDDINGS"></a>REASONING OVER SETS OF ENTITIES USING BOX EMBEDDINGS</h4><p>到目前为止我们将conjunctive queries定义成了计算图，并且可以直接在KG的节点和边上执行.</p><p>给定一个复杂query，<strong>将其分解为一系列逻辑运算，并在向量空间中定义逻辑推理执行这些运算</strong>，这样将获得查询的嵌入，且<strong>查询嵌入box中会包含查询答案</strong>。</p><h5 id="Box-embeddings"><a href="#Box-embeddings" class="headerlink" title="Box embeddings"></a>Box embeddings</h5><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206201655.png" alt=""></p><p>$Cen(p)$表示box的中心，$Off(p)$表示box的正偏移（大小）。KG中的每个实体都被表示为为一个$\mathbf{v} \in \mathbb{R}^d$ 即大小为0的box，box的p建模了一个实体集$\{v\in \mathcal{V}:\mathbf{v} \in Box_p\}$ ，即其向量在box内的实体。</p><p>本文的框架是基于query的计算图在向量空间中进行推理的，如Figure1-D所示：从初始锚节点的box开始，根据逻辑操作不断更新box的embedding。下边介绍entity-to-box<strong>距离函数</strong>以及为了学习嵌入和几何操作符（geometric operators）的<strong>整体目标函数</strong>。</p><h5 id="Initial-boxes-for-source-nodes"><a href="#Initial-boxes-for-source-nodes" class="headerlink" title="Initial boxes for source nodes"></a>Initial boxes for source nodes</h5><p>每个源节点表示一个锚实体$v\mathcal{\in V}$，这可以很自然地表示为Cen为v，Off为0的box，即$(v,0)$。</p><h5 id="Geometric-projection-operator"><a href="#Geometric-projection-operator" class="headerlink" title="Geometric projection operator"></a>Geometric projection operator</h5><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206204922.png" alt=""></p><p>将每个关系$r\in \mathcal{R}$和关系嵌入$\mathbf{r} = (Cen(r),Off(r)) \in \mathbb{R}^{2d}$联系，给定一个输出box embedding $\mathbf{p}$，用<strong>$\mathbf{p+r}$表示其projection运算</strong>：对Cen和Off分别求和，得到一个<strong>中心转移的、大小更大的box</strong>，如Figure2-A所示。</p><h5 id="Geometric-intersection-operator"><a href="#Geometric-intersection-operator" class="headerlink" title="Geometric intersection operator"></a>Geometric intersection operator</h5><p>对一组box embeddings$\mathbf{p_1,\cdots,p_n}$，用$\mathbf{p_{inter}} = (Cen(\mathbf{p_{inter}}),Off(\mathbf{p_{inter}}))$<strong>表示其intersection运算</strong>，对box的中心使用<strong>注意力机制</strong>，并使用sigmoid函数缩小box的偏移量。</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206204902.png" alt=""></p><p>其中$\odot$表示<strong>dimension-wise</strong>的乘积；$MLP(\cdot): \mathbb{R}^{2d}\rightarrow \mathbb{R}^d$是多层感知机；$\sigma(\cdot)$表示sigmoid函数；$DeepSets(\cdot)$表示<strong>排列不变</strong>的（permutation-invariant）深层架构；$Min(\cdot), exp(\cdot)$都在<strong>dimension-wise</strong>进行操作。作者用 $DeepSets({\{\mathbf{x_1}, …, \mathbf{x_N}}\}) = MLP((1/N)\cdot \sum^N_{i=1}MLP(\mathbf{x_i}))$表示所有的deep sets，其中的MLP隐层维度都和输入维度相同。</p><p>几何交集运算的思想是在一组box内生成一个小的box，和通常用的deep sets不同，本文的几何交集操作<strong>有效地限制了中心的位置并且缩小了set的大小</strong>。</p><h5 id="Entity-to-box-distance"><a href="#Entity-to-box-distance" class="headerlink" title="Entity-to-box distance"></a>Entity-to-box distance</h5><p>给定一个query box $\mathbf{q} \in \mathbb{R^{2d}}$和一个实体向量$\mathbf{v} \in \mathbb{R^d}$，距离定义为：</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206210406.png" alt=""></p><p>如Figure2-C所示，$\mathbb{dist_{outside}}$对应于<strong>实体和其在box内最接近的边/角的距离</strong>；$\mathbb{dist_{inside}}$对应于<strong>box的中心和它的边/角的距离</strong>（如果实体在box内则为实体自身）。</p><p>关键在于<strong>用$\alpha$降低了$dist_{inside}$的权重</strong>，这意味着<strong>在box内的实体被视为和box距离足够近</strong>，若$\alpha=1$，则距离退化为$L_1$距离，如TransE中用的$|Cen(q)-\mathbf{v}|_1$。</p><h5 id="Training-objective"><a href="#Training-objective" class="headerlink" title="Training objective"></a>Training objective</h5><p>模型需要学习<strong>实体嵌入</strong>以及几何映射和交集操作符。</p><p>给定queries和answer的训练集，通过优化<strong>负采样损失</strong>优化基于距离的模型：</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206212303.png" alt=""></p><p>其中$\gamma$表示margin；$v\in [q]$是正实体（query q的答案）；$v^{‘}_i \notin [q]$是第i个负实体（非query q的答案）；k是负实体的数目。</p><h4 id="TRACTABLE-HANDLING-OF-DISJUNCTION-USING-DISJUNCTIVE-NORMAL-FORM"><a href="#TRACTABLE-HANDLING-OF-DISJUNCTION-USING-DISJUNCTIVE-NORMAL-FORM" class="headerlink" title="TRACTABLE HANDLING OF DISJUNCTION USING DISJUNCTIVE NORMAL FORM"></a>TRACTABLE HANDLING OF DISJUNCTION USING DISJUNCTIVE NORMAL FORM</h4><p>增加了一种<strong>新类型的有向边Union</strong></p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206213558.png" alt=""></p><p>一种简单的方法是为union定义几何操作符，如同前面的操作一样。但是对于box embedding有一个<strong>挑战</strong>：<strong>boxes可以位于向量空间中的任意位置，它们的union可以不再是一个简单的box</strong>。</p><p>作者证明了一个适用于所有通过embedding将query嵌入为$\mathbf{q}$并通过距离查找实体的方法的负面结果。</p><h5 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem 1"></a>Theorem 1</h5><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206214008.png" alt=""></p><p>对任意M个不相交的合取查询 $q_1,\cdots,q_M$,D是函数集${sign(\beta-dist(\cdot;\mathbf{q})):q\in \Xi}$的VC维数，其中$\Xi$表示query的嵌入空间，sign为符号函数，那么<strong>需要$D\ge M$才能建模任意的EPFO以通过距离寻找答案</strong>。</p><p>对于真实世界的的KG，有$M \approx \mathcal{|V|}$个不相交的合取查询，这就<strong>要求距离函数的VC维度和KG实体数目一样大</strong>，因此无法扩展到大型KG/边缘未知的KG。</p><p>为了解决这个问题，作者的主要思想是<strong>将给定的EPFO query转换为析取范式（DNF）即合取的析取</strong>，以使析取操作仅出现在最后一步，从而可以在低维空间中对每个合取查询进行推理。</p><h5 id="Transformation-to-DNF"><a href="#Transformation-to-DNF" class="headerlink" title="Transformation to DNF"></a>Transformation to DNF</h5><p>所有的一阶逻辑都可以转换为DNF，可以直接在计算图的空间进行转换。给定EPFO query q，其计算图为$G_q=(V_q,E_q)$，<br>$V_{union}\subset V_q$表示入边的类型为“union”的节点集合。对于每个$ v\in V_{union}$，定义$P_v \subset V_q$为其父节点的集合。</p><p>首先生成 $N=\prod_{v\in V_{union}}|P_v|$个不同的计算图$G_{q^{(1)}}, \cdots, G_{q^{(N)}}$（步骤如下所示），其中每个在第一步都有不同的$v_{parent}$选择：</p><ol><li>对每个$v\in V_{union}$，选择一个父节点$v_{parent} \in P_v$</li><li>删除所有union类型的边</li><li>合并$v$和$v_{parent}$，并保留所有其他类型的边</li></ol><p>然后<strong>组合</strong>获得的计算图$G_{q^{(1)}}, \cdots, G_{q^{(N)}}$，以得到最终的等价的计算图：</p><ol><li>将获得的所有计算图的目标汇聚节点转换成量化边界的变量节点（the existentially quantified bound variables nodes）;</li><li>创建一个行额目标汇聚节点$V_?$，从上述所有的变量节点到新的目标节点连接“union”类型的有向边。</li></ol><p>整个转化过程如下Figure3所示，该计算图与原始计算图等价。</p><h5 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h5><p>定义给定EPFO查询$q$ 和实体$v\in \mathcal{V}$ 间的距离函数，因为$q$ 在逻辑上等效于$ q^{(1)}\vee \cdots \vee q^{(N)}$，距离函数很自然地定义为：</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.06/20201206224615.png" alt=""></p><p>该模型和union操作一致，只要实体在一个集合中，该实体就在集合的union中。</p><h5 id="Computational-complexity"><a href="#Computational-complexity" class="headerlink" title="Computational complexity"></a>Computational complexity</h5><p>计算复杂度等同于回答N个交集查询，且这N个查询是可并行的。回答每个conjunctive query的速度很快，因为它执行一个简单的box操作序列，然后在嵌入空间中执行一系列搜索，搜索可以基于<strong>局部敏感哈希</strong>（LSH）技术在固定时间内完成。</p>]]></content>
      
      
      <categories>
          
          <category> KG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KG </tag>
            
            <tag> Knowledge Reasoning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读: Reasoning Like Human: Hierarchical Reinforcement Learning for Knowledge Graph Reasoning</title>
      <link href="2020/12/01/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Reasoning-Like-Human-Hierarchical-Reinforcement-Learning-for-Knowledge-Graph-Reasoning/"/>
      <url>2020/12/01/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Reasoning-Like-Human-Hierarchical-Reinforcement-Learning-for-Knowledge-Graph-Reasoning/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://www.ijcai.org/Proceedings/2020/0267.pdf" target="_blank" rel="noopener">Reasoning Like Human: Hierarchical Reinforcement Learning for Knowledge Graph Reasoning</a></p><a id="more"></a><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>KG推理补全的一种流行方法是通过对连接两实体的其他路径上发现的信息来进行多跳推理。当<strong>一个关系/实体具有多含义</strong>时，效果会显著降低，本文受人类处理认知模糊情况的分层结构启发，提出了层次强化学习框架来自动从KG中学习推理链。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>本文提出了分层强化学习框架（RLH，Reason Like Human）以模仿人的思维模式，在KG上进行多跳推理。通过模拟分层决策，模型能够自动学习推理的路径链。</p><p>模型由一个高级策略和一个低级策略组成，将宏观操作分解成更简单的子任务，从而学习每个关系的潜在语义。</p><h3 id="Definitions-and-Notations"><a href="#Definitions-and-Notations" class="headerlink" title="Definitions and Notations"></a>Definitions and Notations</h3><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.01/20201201140411.png" alt=""></p><h4 id="Definition-1-KG"><a href="#Definition-1-KG" class="headerlink" title="Definition 1 KG"></a>Definition 1 KG</h4><p>KG是一个有向图$G=\mathcal{(E,R,U)}$，其中$\mathcal{E、R、U}$ 分别为实体集、关系集、边集（$(e_o,r,e_t)$） </p><h4 id="Definition-2-KG-Reasoning"><a href="#Definition-2-KG-Reasoning" class="headerlink" title="Definition 2 KG Reasoning"></a>Definition 2 KG Reasoning</h4><p>给定三种情况$(h,r,?)，(?,r,t)，(h,?,t)$，KG Reasoning通过k跳的推理路径（$e_1 \xrightarrow {r_1} e_2 \xrightarrow {r_2} \cdots \xrightarrow {r_k} e_{k+1}$）来预测其中的 $?$ 。</p><h4 id="Definition-3-Markov-Decision-Process"><a href="#Definition-3-Markov-Decision-Process" class="headerlink" title="Definition 3 Markov Decision Process"></a>Definition 3 Markov Decision Process</h4><p>马尔可夫决策过程是一个四元组$(S,A,P_a,R_a)$，其中$S$ 是有限状态集，$A$ 是有限行动集（$A_s$ 是状态$S$ 下的行动集），$P_a(s,s’)=P_r(s_{t+1}=s’|s_t=s,a_t=a)$ 是$t$ 时间$s$ 状态下采取行动$a$ 会在$t+1$时间到达状态$s’$ 的概率，$R_a(s,s’)$ 是通过动作$a$ 完成$s \rightarrow s’$ 的奖励。</p><p>RL是一个MDP，在序列的每一阶段，Agent观察一个环境状态$s$，并执行一个动作$a$，收到一个期望为$R(s,a)$ 的即时奖励和状态转移概率 $P(s’|s,a)$。</p><h4 id="Definition-4-Hierarchical-Reinforcement-Learning"><a href="#Definition-4-Hierarchical-Reinforcement-Learning" class="headerlink" title="Definition 4 Hierarchical Reinforcement Learning"></a>Definition 4 Hierarchical Reinforcement Learning</h4><p>分层强化学习是一个semi-MDP$(S,A,P_a,r_{a,\Phi})$，其中$P_a(s,s’)=P_r(s_{t+1}=s’|s_t=s,a_t=a)\Pi_{i=1}^{K-1}P_r(\phi_{i+1}|\Phi_i)$。$\Phi$ 是一个用来描述动作$a$ 内部的K个转移阶段的转移函数空间，每个$\phi$ 都是$a$ 的一个子动作，所有的$\phi$ 都是相关的。</p><p>HRL的每个多做包括时间上离散的、可计数的子动作。HRL将整个问题的优化下发给更简单的子问题，在子问题中知识可以相互传递，重组子问题中的解决方案可以解决更大更复杂的问题。</p><h3 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h3><h4 id="RLH"><a href="#RLH" class="headerlink" title="RLH"></a>RLH</h4><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.01/20201201140526.png" alt=""></p><p>Agent对每个query预测一个源实体到目标实体的路径，它观察当前state并执行分层策略决定下一跳的实体。Agent不断观察并决定下一跳，直至它到达目标实体或最大长度。Agent的轨迹就是一个推理链，可以解释如何从推理系统获得查询结果。</p><p>在KG环境中，动作空间通常是层次结构，所以复杂的动作空间就会分解为像决策树一样的子任务，关系的多重语义也被分解为更具体的表示。</p><h4 id="High-Level-Policy-for-Encoding-History-Information"><a href="#High-Level-Policy-for-Encoding-History-Information" class="headerlink" title="High Level Policy for Encoding History Information"></a>High Level Policy for Encoding History Information</h4><p>RL训练Agent从KG与环境的交互中学习。KG中，RL由四元组$\mathcal{(S,A,P,R)}$ 表示。</p><p><strong>States</strong> step $i$ 的state表示为$s_i=(e_{i-1},r_i,e_i,e_t)$ ，其中$e_i\in \mathcal{E}$ 表示当前实体，$e_{i-1}$ 表示上一个实体，$r_i$ 表示这两实体间的关系，$e_t$ 是目标实体。给定实体对$(e_o,e_t)$，起始状态为$(‘ST’,’ST’,e_o,e_t)$，终态为$(e_{t-1},r_t,e_t,e_t)$。</p><p><strong>Actions</strong> 状态$s_i$的行动集是当前实体$e_i$ 的出边集。</p><p><strong>Transition</strong> 转移$\mathcal{P:S \times A \rightarrow S}$ 是状态转移概率函数，转移策略是选择$\mathcal{P}(s_{i+1}|s_i,a_i)$ 中最大概率的$a_i$。</p><p><strong>Policy</strong> 高级策略网络$\mu(s,\mathcal{A})=P(a|s;\theta)$ 用于在连续空间中建模RL Agent，$\theta$ 是网络参数。用历史向量$\mathbf{h_t}$ 来保存历史信息进行序列决策。给定步骤$t$ 的轨迹$\tau$，历史向量$\mathbf{h_t}$ 由$\mathbf{h_{t-1}、s_{t-1}}$ 决定<script type="math/tex">\mathbf{h_t} = GRU(\mathbf{h_{t-1},s_{t-1}}) \\ a \sim \pi(a_t|s_{t-1}) = softmax(\mathbf{W_\pi c})</script></p><p>其中$\mathbf{c}$ 是低级策略输出子动作的向量表示，$\mathbf{W_\pi}$ 是Rewards矩阵</p><p><strong>Rewards</strong> 如果agent到达了目标实体，则每跳的奖励定义如下：</p><script type="math/tex; mode=display">R_{H(\tau_i)} = \begin{cases} 1 \cdot \gamma_i, & \hat e_t = e_t \\ 0, & otherwise\end{cases}</script><h4 id="Low-Level-Policy-for-Structured-Action-Space"><a href="#Low-Level-Policy-for-Structured-Action-Space" class="headerlink" title="Low Level Policy for Structured Action Space"></a>Low Level Policy for Structured Action Space</h4><p>低级策略$\Phi$ 将复杂动作空间$\mathcal{A_s}$ 分解为结构化的子动作。子动作转换也是一个马尔可夫过程。通过层级聚类的关系嵌入方法，KG中的关系可以形成关系簇，低级RL的所有状态被组织为一个搜索树，可以很好地表达每个关系的潜在多重语义。</p><p><strong>Actions</strong> 首先执行TransE获得嵌入向量，然后应用k means算法初始化关系簇，构建层次结构的关系簇集。</p><p><strong>State</strong> 低级状态$s_i$ 包括当前有效子动作集，一个轨迹的起始状态是$A_s$，如果成功则终态为${a_{t+1}}$，否则为$\varnothing$。</p><p><strong>Policy</strong> Agent观察$s_i^l$ 的子操作空间，执行子任务</p><script type="math/tex; mode=display">c \sim \mu(c_t|c_{t-1},h_t,s_{t-1}) = Softmax(ReLU(\sigma(\mathbf{W_S|[H_T;S_{T-1}}])[s_i^l]\mathbf{W_cC_i}))</script><p>其中$c_t$ 是要采用的子动作</p><p><strong>Reward</strong> 对终态包含正确动作$a_{next}$时获得奖励。</p><script type="math/tex; mode=display">R_L (\epsilon) = \begin{cases} 1 , & a_{next} \in s^l \\ 0, & otherwise\end{cases}</script><h4 id="Optimization-and-Training"><a href="#Optimization-and-Training" class="headerlink" title="Optimization and Training"></a>Optimization and Training</h4><p>低级策略网络的目标函数是最大化层次决策的累计回报</p><script type="math/tex; mode=display">J^L(\theta_L) = \mathbb{E}_{\epsilon \sim p\theta_L(\epsilon)}[R_L(\epsilon)]</script><p>其中$\epsilon$ 表示从低级策略$\mu$ 的潜在分布$p\theta_L(\epsilon)$ 中生成的$M$ 长的轨迹。</p><p>高级策略的目标函数是</p><script type="math/tex; mode=display">J^H(\theta_H) = \mathbb{E}_{\theta_L,\tau \sim p\theta_H(\tau)}[R_H(\tau)]</script><p>其中$\epsilon$ 表示从潜在分布$p\theta_H(\tau)$ 中生成的$N$ 长的轨迹。</p><p>然后使用 policy gradient methods的 REINFORCE 算法优化两个策略。</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.12.02/20201202112504.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> KG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KG </tag>
            
            <tag> Knowledge Reasoning </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《algorithm》之排序与查找</title>
      <link href="2020/11/30/algorithm/"/>
      <url>2020/11/30/algorithm/</url>
      
        <content type="html"><![CDATA[<p>拜读《Algorithms》，主要阅读了排序和查找算法。</p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础编程模型"><a href="#基础编程模型" class="headerlink" title="基础编程模型"></a>基础编程模型</h2><h3 id="Java程序的基本结构"><a href="#Java程序的基本结构" class="headerlink" title="Java程序的基本结构"></a>Java程序的基本结构</h3><p>一段Java程序（类）或是一个静态方法（函数）库，或是定义了一个数据类型。用到以下语法：</p><ul><li>原始数据类型</li><li>语句：声明、赋值、条件、循环、调用、返回</li><li>静态方法：可以封装并重用代码，便于用独立模块开发程序</li><li>字符串</li><li>标准I/O</li><li>数据抽象：数据抽象封装和重用，便于定义非原始数据类型，进而支持面向对象编程</li></ul><h2 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h2><p>数据类型指一组值和一组对这些值的操作的集合。</p><p>Java编程的基础主要是使用class关键字构造<strong>引用类型</strong>的数据类型——<strong>面向对象编程</strong>。抽象数据类型（ADT）可以对使用者隐藏数据表示的数据类型。</p><h3 id="使用抽象数据类型"><a href="#使用抽象数据类型" class="headerlink" title="使用抽象数据类型"></a>使用抽象数据类型</h3><h4 id="抽象数据类型的API"><a href="#抽象数据类型的API" class="headerlink" title="抽象数据类型的API"></a>抽象数据类型的API</h4><p>用API来说明抽象数据类型的行为，列出所有构造函数和实例方法。</p><p>抽象数据类型的定义和静态方法库之间的不同：</p><ul><li>API可能会出现若干个名称与类名相同且无返回值的函数，即<strong>构造函数</strong></li><li>实例方法不需要static关键字，不是静态方法</li><li>某些实例方法是继承的方法</li></ul><h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><p>任何数据类型都能通过在API中包含特定的方法从Java的内在机制中获益。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象是能够承载数据类型的值的实体。</p><p>三大特性：状态、标识和行为。状态即数据类型中的值，标识可以认为是在内存中的位置，行为即数据类型的操作。</p><p>引用是访问对象的一种方式，Java使用术语<strong>引用类型</strong>以表示和原始数据类型的区别。</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>new+类名+(paras)来触发构造函数。调用new时系统会：</p><ul><li>为新对象分配内存空间</li><li>调用构造函数初始化对象中的值</li><li>返回该对象的一个引用</li></ul><h4 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a>调用实例方法</h4><p>对象变量名.实例方法名(paras)</p><p>方法的每次触发都是和一个对象相关的，<strong>通过触发一个实例方法可以操作对象的值</strong>。</p><p>静态方法调用的开头是类名（通常为大写），而实例方法调用的开头是对象名（通常为小写）。</p><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><p>声明以引用对象、用关键字new触发该类型的对象的构造函数、使用变量名调用实例方法。</p><p>可以像使用原始数据类型的变量一样使用和对象关联的变量。</p><h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><p>使用引用类型的赋值语句会创建该引用的一个副本，<strong>赋值并不会创建新的对象，而是创建一个引用，即别名</strong>。</p><h4 id="将对象作为参数"><a href="#将对象作为参数" class="headerlink" title="将对象作为参数"></a>将对象作为参数</h4><p>当调用一个需要参数的方法时，每个参数名都相当于左值，而传入的参数值相当于右值，即将参数值的一个副本从调用端传递给方法——<strong>按值传递</strong>。但使用引用类型参数时，传入的都是<strong>对象的引用</strong>，能够改变对象的值。</p><h4 id="将对象作为返回值"><a href="#将对象作为返回值" class="headerlink" title="将对象作为返回值"></a>将对象作为返回值</h4><p>用对象就可以返回多个值</p><h4 id="数组也是对象"><a href="#数组也是对象" class="headerlink" title="数组也是对象"></a>数组也是对象</h4><p>所有非原始数据类型的值都是对象，数组、字符串也是。</p><h4 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h4><ul><li>使用方括号语法调用数组的构造函数创建数组</li><li>对每个数组元素调用它的构造函数创建相应的对象</li></ul><h3 id="数据类型的设计"><a href="#数据类型的设计" class="headerlink" title="数据类型的设计"></a>数据类型的设计</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>模块化编程</p><h4 id="设计API"><a href="#设计API" class="headerlink" title="设计API"></a>设计API</h4><p>应该以能够复用的方式编写每个程序，API应该能够清楚地说明所有可能的输入和副作用。</p><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>Java为定义对象之间的关系提供了支持——接口。</p><p><strong>子类型</strong>（第一种继承机制）允许通过指定一个含有一组公共方法的接口为两个本来并没有关系的类建立一种联系，这两个类都必须实现这些方法。这种方式称为接口继承。</p><h4 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h4><p><strong>子类</strong>的主要思想是定义一个新类（子类或派生类）来继承另一个类的所有实例方法和实例变量。</p><h4 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h4><p>Java提供了一些内置的引用类型：Boolean、Byte、Character、Double、Float、Integer、Long、Short，含有继承得到的实例方法，在需要时Java会自动将原始数据类型转换为封装类型。</p><h4 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h4><p>equals()必须是一种等价性关系：</p><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>非空性</li></ul><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>Java最重要的一个特性就是<strong>自动内存管理</strong>，通过记录<strong>孤儿对象</strong>并将他们的内存释放到内存池中来回收内存——垃圾回收。</p><p>Java不允许修改引用的策略。</p><h4 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h4><p>不可变数据类型：该类型的对象中的值创建后无法改变。</p><p>Java通过final修饰符来强制保证不可变性，只能通过赋值语句和构造函数赋值一次，但<strong>final仅可用于保证原始数据类型的实例变量的不可变性</strong>，而无法用于引用类型的变量（会使引用无法改变，永远指向同一个对象，但对象的值仍是可变的）。</p><h4 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h4><p>能够在程序运行时检验程序状态的一些机制：</p><ul><li>异常（Exception）：一般用于处理不受控制的不可预见的错误</li><li>断言（Assertion）：验证在代码中做出的一些假设</li></ul><h4 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h4><p>都是程序运行中出现的破坏性事件，Java采取的行动称为抛出异常或抛出错误，也可以创建自己的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error message here."</span>)</span><br></pre></td></tr></table></figure><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>断言是一条需要在程序的某处确认为true的布尔表达式，如果为false程序将会终止并报告出错信息。</p><p>使用断言来确定程序的正确性并记录编程意图，使用断言来保证代码永远不会被系统错误终止或进入死循环。</p><h2 id="背包、队列和栈"><a href="#背包、队列和栈" class="headerlink" title="背包、队列和栈"></a>背包、队列和栈</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Bag</span>()创建一个空背包</span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">add</span>(<span class="title">Item</span> <span class="title">item</span>)     添加一个元素</span></span><br><span class="line"><span class="class">     <span class="title">boolean</span> <span class="title">isEmpty</span>()  背包是否为空</span></span><br><span class="line"><span class="class">     <span class="title">int</span> <span class="title">size</span>()  背包中的元素数量</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Queue</span>()创建空队列</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">enqueue</span>(<span class="title">Item</span> <span class="title">item</span>)  添加一个元素</span></span><br><span class="line"><span class="class">    <span class="title">Item</span> <span class="title">dequeue</span>() 删除最近添加的元素</span></span><br><span class="line"><span class="class">     <span class="title">boolean</span> <span class="title">isEmpty</span>()  队列是否为空</span></span><br><span class="line"><span class="class">     <span class="title">int</span> <span class="title">size</span>() 队列中的元素数量</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">Stack</span>()创建空栈</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">push</span>(<span class="title">Item</span> <span class="title">item</span>) 添加一个元素</span></span><br><span class="line"><span class="class">    <span class="title">Item</span> <span class="title">pop</span>()  删除最近添加的元素</span></span><br><span class="line"><span class="class">     <span class="title">boolean</span> <span class="title">isEmpty</span>()  栈是否为空</span></span><br><span class="line"><span class="class">     <span class="title">int</span> <span class="title">size</span>()栈中的元素数量</span></span><br></pre></td></tr></table></figure><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>集合类的抽象数据类型的一个关键特性是<strong>可以用他们存储任意类型的数据</strong>。Java的<strong>泛型机制（参数化类型）</strong>能够做到这一点。在每个API中，类名后的\<Item\>记号将Item定义为一个类型参数，它是一个象征性的占位符，表示用例将会使用的某种具体数据类型。创建栈时可以将Item替换为任意引用数据类型。</p><h4 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h4><p>类型参数必须被实例化为引用类型，因此Java有一种特殊机制来使泛型代码能够处理原始数据类型，Java会自动在引用类型和对应的原始数据类型之间进行转换（自动装箱、自动拆箱）。</p><h4 id="可迭代的集合类型"><a href="#可迭代的集合类型" class="headerlink" title="可迭代的集合类型"></a>可迭代的集合类型</h4><p>大部分应用场景下的要求只是用某种方式处理集合中的每个元素，或者叫<strong>迭代访问</strong>集合中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Transaction t : collection)</span><br><span class="line">&#123;StdOut.println(t);&#125;</span><br></pre></td></tr></table></figure><h4 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h4><p>背包是一种不支持从中删除元素的几何数据类型——他的目的就是帮助用例<strong>收集元素并迭代遍历所有收集到的元素，迭代顺序不确定且与用例无关</strong>。使用Bag就说明元素的处理顺序并不重要。</p><h4 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h4><p>队列是基于FIFO策略的集合类型。使用队列的原因是<strong>保存元素的同时保存他们的相对顺序</strong>。用例使用foreach语句迭代访问队列中的元素时，<strong>元素的处理顺序就是他们被添加到队列中的顺序</strong>。</p><h4 id="下压栈"><a href="#下压栈" class="headerlink" title="下压栈"></a>下压栈</h4><p>下压栈是基于LIFO的集合类型。用例使用foreach语句迭代访问栈中的元素时，<strong>元素的处理顺序与它们被压入栈的正好相反</strong>。</p><h3 id="集合数据类型的实现"><a href="#集合数据类型的实现" class="headerlink" title="集合数据类型的实现"></a>集合数据类型的实现</h3><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126183244.png" alt=""></p><p>在pop()时，将元素值设为null，可以防止对象游离。</p><p>迭代器需要实现hasNext()和next()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种递归的数据结构，它或者为null，或者指向一个node的引用，该节点还有一个泛型的元素和一个指向另一条链表的引用。</p><p>数组和链表是两种表示对象集合的方式——顺序存储和链式存储。 </p><h4 id="结点记录"><a href="#结点记录" class="headerlink" title="结点记录"></a>结点记录</h4><p>用一个<strong>嵌套类</strong>来定义结点的抽象数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Item item;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从表头插-入结点"><a href="#从表头插-入结点" class="headerlink" title="从表头插 入结点"></a>从表头插 入结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node oldfirst = first;</span><br><span class="line">first = <span class="keyword">new</span> Node();</span><br><span class="line">first.item = <span class="string">"new"</span>;</span><br><span class="line">first.next = oldfirst;</span><br></pre></td></tr></table></figure><h4 id="从表头删除结点"><a href="#从表头删除结点" class="headerlink" title="从表头删除结点"></a>从表头删除结点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first = first.next</span><br></pre></td></tr></table></figure><h4 id="在表尾插入结点"><a href="#在表尾插入结点" class="headerlink" title="在表尾插入结点"></a>在表尾插入结点</h4><p>需要一个指向链表尾结点的链接，这个链接必须被修改并指向一个含有新元素的结点，维护一个额外的链接并不可取，因为修改链表的操作可能需要修改该变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node oldlast = last;</span><br><span class="line">last = <span class="keyword">new</span> Node();</span><br><span class="line">last.item = <span class="string">"new"</span>;</span><br><span class="line">oldlast.next = last;</span><br></pre></td></tr></table></figure><h4 id="其他位置的插入与删除"><a href="#其他位置的插入与删除" class="headerlink" title="其他位置的插入与删除"></a>其他位置的插入与删除</h4><ul><li>删除指定的结点</li><li>在指定结点前插入一个新结点</li></ul><p>实现任意插入和删除操作的标准解决方案是<strong>双向链表</strong>。</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>将栈保存为一条链表，栈顶为表头。<strong>push即在表头添加元素，pop即删除表头元素</strong>。</p><h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><p>将队列保存为一条链表，队列开头为表头。<strong>enqueue即在表尾添加元素，dequeue即删除表头元素</strong>。</p><h4 id="背包的实现"><a href="#背包的实现" class="headerlink" title="背包的实现"></a>背包的实现</h4><p>将stack中的push改为add，并去掉pop即可。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>得到运行时间的数学模型所需的步骤：</p><ul><li>确定输入模型，定义问题的规模</li><li>识别<strong>内循环</strong></li><li>根据内循环中的操作确定<strong>成本模型</strong></li><li>对于给定的输入，判断这些操作的执行频率</li></ul><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210125135956.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210125140708.png" alt=""></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ul><li>对象：所有实例变量的内存+对象本身的开销16bytes（内存的使用一般会被填充为8bytes）</li><li>链表：需要8bytes额外开销</li><li>数组：24bytes头信息=16bytes对象开销+4bytes保存长度+4bytes填充字节</li><li>字符串对象：对象的16bytes+指向字符数组的引用8bytes+描述的字符数组中的偏移量4bytes int+计数器（字符串长度）的4bytes int+散列值4bytes int+4bytes填充字节</li><li>字符串的值和子字符串：String的40bytes+字符数组的24+2N bytes</li></ul><h2 id="Union-Find（并查集）算法"><a href="#Union-Find（并查集）算法" class="headerlink" title="Union-Find（并查集）算法"></a>Union-Find（并查集）算法</h2><p>并查集算法是解决动态连通性问题的高效数据结构。</p><h3 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h3><p>问题的输入是一列整数对，每个整数都表示一个对象，整数对p和q表示p和q是相连的，这是一种<strong>对等</strong>的关系。</p><ul><li>网络中是否需要建立新的通路</li><li>编程环境中变量名（引用）是否等价</li><li>数学集合的抽象问题</li></ul><h3 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h3><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126113755.png" alt=""></p><p>触点和分量都用<code>int</code>表示，则可以用一个以触点为索引的数组<code>id[]</code>来表示所有分量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     count = N;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> count;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> find(p) == find(q);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="quick-find算法"><a href="#quick-find算法" class="headerlink" title="quick-find算法"></a>quick-find算法</h3><p>一种方法是保证同一连通分量的触点在id[]中的值全部相同。在调用<code>union</code>时，如果p和q不在同一分量中，需要将q所在的分量的所有触点的id[]均置为id[p]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> id[p];&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pID = find(p);</span><br><span class="line">    <span class="keyword">int</span> qID = find(q);</span><br><span class="line">    <span class="keyword">if</span> (pID == qID) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (id[i] == pID) id[i] = qID;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要扫描整个id[]数组，find仅访问数组1次，union操作访问数组 N+3到2N+1 次，那么最坏情况下至少需要(N-1)(N+3)次。</p><h3 id="quick-union算法"><a href="#quick-union算法" class="headerlink" title="quick-union算法"></a>quick-union算法</h3><p>id[]数组值为同一分量中另一触点的名称，这种联系称为<strong>链接</strong>，根触点就是链接指向自己的触点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">    <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">    <span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    id[pRoot] = qRoot;</span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接的结构实际上是树，id数组用父链接表示了森林，find中返回root从而判断两节点是否在同一棵树，而在union中通过将一个root变为另一个root的父节点，归并了两棵树。</p><p>find需要访问数组1到2N-1次，并不总是线性复杂度，相比quick-find算法有所改进。</p><p>最坏情况下输入为0-1，0-2，……，0-(N-1)，每个输入对0-i需要访问数组2i+2次</p><h3 id="加权quick-union算法"><a href="#加权quick-union算法" class="headerlink" title="加权quick-union算法"></a>加权quick-union算法</h3><p>记录每棵树的大小并在每次union中将小树连接到大树上</p><p>在类中添加一个sz[]数组记录各个根节点所对应的分量大小。</p><p>最坏情况下，union合并的树大小总是相同，能够保证lgN级别的性能。</p><blockquote><p>对于N个触点，加权q-u算法构造的森林中任意节点的深度最多为log N</p><p>对于加权q-u算法和N个触点，最坏情况下connect、find、union的复杂度为log N</p></blockquote><h3 id="路径压缩的加权quick-union算法"><a href="#路径压缩的加权quick-union算法" class="headerlink" title="路径压缩的加权quick-union算法"></a>路径压缩的加权quick-union算法</h3><p>在find中添加一个循环，将路径上的节点都直接链接到根节点。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210126182051.png" alt=""></p><hr><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>不断选择元素中的最小者与第一个元素交换位置，交换的次数为N，比较的次数为1+2+3+…+(N-1)~ $N^2/2$。</p><blockquote><ul><li>运行时间和输入的状态（是否有序）无关</li><li>数据移动最少——只有N次交换</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">            exch(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selection</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(a):</span><br><span class="line">            min = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(list)):</span><br><span class="line">                <span class="keyword">if</span> a[j] &lt; a[min]:</span><br><span class="line">                    min = j</span><br><span class="line">            a[min], a[i] = a[i], a[min]</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将每个元素插入到已经有序的序列中。最坏情况下需要$N^2/2$比较和交换，最好情况下需要N-1次比较和0次交换。</p><blockquote><ul><li>运行时间与输入的状态有关。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">                exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insertion</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(a):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> a[j] &gt;= a[j<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                a[j], a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>], a[j]</span><br></pre></td></tr></table></figure><p>插入排序对<strong>部分有序</strong>数组很有效（特别是倒置的数目很少时）：</p><ul><li>数组中每个元素距离其正确位置不远</li><li>一个有序大数组接小数组</li><li>数组中仅有几个元素位置不正确</li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>基于插入排序的算法，交换不相邻的元素对数组局部排序，并最终用插入排序将局部有序的数组排序。</p><p>h有序数组：数组中任意间隔为h的元素都是有序的。</p><p>对每个h，用插入排序将h个子数组独立的排序，再减小h直到h=1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">                    exch(a[j], a[j-h]);</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> h &lt; N/<span class="number">3</span>:</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> h &gt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(a):</span><br><span class="line">                j = i</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, -h):</span><br><span class="line">                    <span class="keyword">if</span> a[j] &gt;= a[j-h]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    a[j], a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>], a[j]</span><br><span class="line">            h = h / <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序时间复杂度为O(Nlg N)，但需要额外O(N)的空间。</p><h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 原地归并的抽象方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable [] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">         aux[k] = a[k];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (i &gt; mid)a[k] = aux[j++];</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)a[k] = aux[i++];</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[i], aux[j])) a[k] = aux[i++];</span><br><span class="line">         <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="自顶向下的归并排序"><a href="#自顶向下的归并排序" class="headerlink" title="自顶向下的归并排序"></a>自顶向下的归并排序</h3><p><strong>分治思想</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable [] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparab1e[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Merge</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, a: list, lo: int, mid: int, hi: int)</span>:</span></span><br><span class="line">        i = lo</span><br><span class="line">        j = mid +<span class="number">1</span></span><br><span class="line">        aux = a[:] <span class="comment"># copy list (or a[:], a*1, copy.copy(a) )</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(lo, hi+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; mid:</span><br><span class="line">                a[k] = aux[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt; hi:</span><br><span class="line">                a[k] = aux[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> aux[i] &lt; aux[j]:</span><br><span class="line">                a[k] = aux[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a[k] = aux[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sort__</span><span class="params">(self, a: list, lo: int, hi: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hi &lt;= lo:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = int(lo + (hi - lo) / <span class="number">2</span> )</span><br><span class="line">        self.__sort__(a, lo, mid)</span><br><span class="line">        self.__sort__(a, mid+<span class="number">1</span>, hi)</span><br><span class="line">        self.merge(a, lo, mid, hi)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, a: list)</span>:</span></span><br><span class="line">        self.__sort__(a, <span class="number">0</span>, len(a)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>N个元素的数组最多构成$n=lgN$层的树，自顶向下的第k层有$2^k$个子数组，每个数组长度为$2^{n-k}$即最多比较次数，故每层最多比较$2^n$次，那么n层一共比较至多$2^n*n=NlgN$次。</p><blockquote><p>对于长度为N的数组，自顶向下的归并排序需要$NlgN/2 至 NlgN$次比较；最多需要访问数组$6NlgN$次（$2N复制 2N移动 至多2N比较$）。</p></blockquote><ul><li>小数组使用插入排序</li><li>提前测试mid小于等于mid+1</li><li>不将元素复制到辅助数组（而是直接排序到）</li></ul><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><p>先归并微型数组，自底向上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    <span class="comment">// merge()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz+sz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo += sz + sz)</span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>N为2的幂时，自底向上和自顶向下的比较与访问次数相同。</p><p>自底向上方法适合链表组织的数据，只需重新组织链表链接即可<strong>原址排序</strong>。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><blockquote><ul><li>基于比较的算法比较次数不可能小于$lg(N!)$~$NlgN$。</li><li>归并排序时渐进最优的基于比较的排序算法。</li></ul></blockquote><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>优点：</p><ul><li><strong>原址排序</strong>（仅需小辅助栈）</li><li>$NlgN$</li></ul><p>缺点：</p><p>非常脆弱，错误导致性能严重下降。</p><p>思路上和归并互补，先处理数组，后递归调用。</p><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StdRandom.shuffle(a);<span class="comment">// 消除对输入的依赖</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (less(a[++i],v)) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (less(v, a[--j])) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用<code>partition()</code>将<code>a[j]</code>的位置排定，之前的元素不大于它，之后的元素不小于它。</p><p>切分过程：</p><ul><li>随机选取<code>a[lo]</code>作为切分元素</li><li>分别从左和从右开始扫描数组，寻找未排定的元素交换位置</li><li>指针相遇时交换切分元素和左子数组最右侧元素即可 </li></ul><h3 id="性能特点"><a href="#性能特点" class="headerlink" title="性能特点"></a>性能特点</h3><blockquote><p>平均情况：比较次数$C_N = 2C_{N/2}+N$，即$2NlnN=1.39NlgN$</p><p>最坏情况：$N^2/2$次比较，但可以通过shuffle预防。</p></blockquote><p>比较次数多于归并排序，但移动次数少。</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><ul><li>对小数组使用插入排序</li><li>用三取样的中位数切分</li><li>三向切分：维护三个指针（大于、小于、等于）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3way</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable [] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo+<span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= gt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) exch(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) exch(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>某些分配调度场合下只需要支持两种操作：<strong>删除最大元素</strong> 和 <strong>插入元素</strong> </p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/01/20210217145536.png" alt=""></p><p>仅维护大小为M的优先队列即可。</p><h3 id="初级实现方法"><a href="#初级实现方法" class="headerlink" title="初级实现方法"></a>初级实现方法</h3><ul><li>无序数组（delete时类似选择排序找到最大元素）</li><li>有序数组（insert时做插入排序，最大元素始终在一边）</li><li>链表</li></ul><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210217150544.png" alt=""></p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>二叉树的父节点大于等于两个子节点——<strong>堆有序</strong>。</p><p>位置$k$的结点的父节点位置为$\lfloor k/2 \rfloor$，子节点为$2k$和$2k+1$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="comment">/* pq[]长度为N+1，不使用pq[0]*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;Key t = pq[i]; pq[i] = pq[j]; pq[j] = t;&#125;</span><br></pre></td></tr></table></figure><h4 id="由下至上的堆有序化（上浮）"><a href="#由下至上的堆有序化（上浮）" class="headerlink" title="由下至上的堆有序化（上浮）"></a>由下至上的堆有序化（上浮）</h4><p>某节点变得比父节点大，有序状态被打破。将该节点与父节点交换，不断上移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k))</span><br><span class="line">    &#123;</span><br><span class="line">        exch(k/<span class="number">2</span>, k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由上至下的堆有序化（下沉）"><a href="#由上至下的堆有序化（下沉）" class="headerlink" title="由上至下的堆有序化（下沉）"></a>由上至下的堆有序化（下沉）</h4><p>某个节点变得比子节点小，有序状态被打破。将该节点和两个子节点中较大者交换，不断下移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入元素：插入到数组末尾，不断上浮到合适位置</li><li>删除最大元素：删除最大元素（根节点）并将数组的最后一个元素放到根节点，不断下沉到合适位置。</li></ul><h4 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a>整体实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &lt;<span class="title">key</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span></span><br><span class="line"><span class="function">    </span>&#123;pq = (Key []) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> N == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> N;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;<span class="comment">//防止越界</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>insert 不超过$lgN+1$次比较</li><li>delMax不超过$2lgN$次比较</li></ul></blockquote><h4 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h4><h5 id="多叉堆"><a href="#多叉堆" class="headerlink" title="多叉堆"></a>多叉堆</h5><p>需要在树高（$log_d N$）和<strong>从每个结点的$d$个子结点中找到最大者的代价</strong>之间折中</p><h5 id="调整数组大小"><a href="#调整数组大小" class="headerlink" title="调整数组大小"></a>调整数组大小</h5><p>像栈实现一样insert中添加长度加倍、delMax添加长度减半</p><h5 id="元素的不可变性"><a href="#元素的不可变性" class="headerlink" title="元素的不可变性"></a>元素的不可变性</h5><p>假设用例代码不会改变元素</p><h5 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h5><p>允许用例引用优先队列中的元素——给每个元素一个<strong>索引</strong>。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210217202733.png" alt=""></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将所有元素插入一个查找最小元素的优先队列，重复调用delMin()方法按顺序删去即可排序。</p><h4 id="堆的构造"><a href="#堆的构造" class="headerlink" title="堆的构造"></a>堆的构造</h4><ul><li>从左到右swim()保证指针左侧堆有序（类似insert）</li><li>从右到左sink()构造子堆，</li></ul><blockquote><p>构造堆只需要少于2N次比较和少于N次交换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">        sink(a, k, N);<span class="comment">// 表示将a[]从a[k]到a[N]排序</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        exch(a, <span class="number">1</span>, N--);</span><br><span class="line">        sink(a, <span class="number">1</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210217233952.png" alt=""></p><h4 id="下沉排序"><a href="#下沉排序" class="headerlink" title="下沉排序"></a>下沉排序</h4><p>每次删除最大元素，放入堆缩小后数组空出的位置。</p><blockquote><p>堆排序需要少于$2NlgN+2N$次比较和一半次数的交换</p></blockquote><h4 id="先下沉后上浮"><a href="#先下沉后上浮" class="headerlink" title="先下沉后上浮"></a>先下沉后上浮</h4><p><strong><em>？？？并不能理解</em></strong></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210217234755.png" alt=""></p><h4 id="堆排序的特点"><a href="#堆排序的特点" class="headerlink" title="堆排序的特点"></a>堆排序的特点</h4><p>在排序复杂性的研究中很重要，唯一能够同时最优利用空间和时间的方法——最坏情况下用~$2NlgN$次比较和恒定的额外空间。</p><ul><li>在空间紧张的嵌入式操作系统和移动设备中经常使用；现代操作系统很少使用，因为无法利用<strong>缓存</strong>，元素很少和相近的元素比较，miss的次数远大于hit。</li><li>能在插入和删除最大元素操作的动态场景中保证对数级别的运行时间。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排序算法的稳定性：能够保留数组中重复元素的相对位置</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210225191325.png" alt=""></p><ul><li>快速排序是最快的通用排序算法</li></ul><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210227190126.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210227190149.png" alt=""></p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210227190744.png" alt=""></p><p><img src="C:\Users\deng\AppData\Roaming\Typora\typora-user-images\image-20210227192335974.png" alt="image-20210227192335974"></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>在二叉树中，每个结点只能有一个父结点（根节点除外），每个结点都有左右两条链接，分别指向一棵子二叉树或空。</p><p>同一个集合可以用多棵不同的二叉查找树表示。</p><h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><blockquote><p>递归查找：</p><ul><li>树为空，则miss；</li><li>和当前结点的键相同，则hit；</li><li>和当前结点的键不同，则递归地到子树中查找。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> get(root, key);&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><blockquote><p>递归插入：</p><ul><li>树为空，则返回一个含有该键值对的新结点；</li><li>小于当前结点的键，则在左子树递归插入；</li><li>大于当前结点的键，则在右子树递归插入。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function"></span>&#123;root = put(root, key, val);&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val);</span><br><span class="line">    <span class="keyword">else</span> x.val = val;</span><br><span class="line">    x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二叉查找树的运行时间取决于树的形状，而树的形状取决于结点插入的顺序。</p><p>二叉查找树和快速排序的思想相似。</p><blockquote><p>N个结点的二叉查找树中，查找命中所需的比较次数平均为~$2lnN(1.39lgN)$，插入和查找未命中所需的比较次数平均也为~$2lnN(1.39lgN)$（仅多1次额外比较）。</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在删除结点x后用其后继节点填补位置。</p><ul><li>将指向即将被删除的节点的链接保存为<code>t</code></li><li>将<code>x</code>指向后继结点<code>min(t.right)</code></li><li>将<code>x</code>的右链接指向<code>deleteMin(t.right)</code></li><li>将<code>x</code>的右链接指向<code>t.left</code></li></ul><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210227234036.png" alt=""></p><h3 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h3><p><strong>中序遍历</strong>：递归查找根节点的左子树，然后查找根节点，再查找根节点的右子树。</p><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210228000357.png" alt=""></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><blockquote><ul><li>二叉查找树的所有操作在最坏情况下所需时间都和<strong>树高</strong>成正比</li><li>随机键构造的二叉树高趋近于$2.99lgN$</li></ul></blockquote><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210228000800.png" alt=""></p><h2 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h2><h3 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h3><ul><li>2-结点：含有一个键和两条链接</li><li>3-结点：含有两个键和三条链接</li></ul><p><img src="https://gitee.com/rooki3/images/raw/master/2021/02/20210228105730.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> 并查集Union-find </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读-Embedding Logical Queries on Knowledge Graphs</title>
      <link href="2020/11/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Embedding%20Logical%20Queries%20on%20Knowledge%20Graphs/"/>
      <url>2020/11/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Embedding%20Logical%20Queries%20on%20Knowledge%20Graphs/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://arxiv.org/pdf/1806.01445v1.pdf" target="_blank" rel="noopener">Embedding Logical Queries on Knowledge Graphs</a></p><p>主要思路是(1)根据DAG结构表示query，利用$\mathcal{P}$ 算子将起点的嵌入向量集投影到到以$\tau$ 类型的出边连接的相邻节点的嵌入向量集；(2)再用$\mathcal{L}$ 算子对嵌入向量集取交集；(3)重复以上步骤直至全部聚合，得到query的嵌入向量；（4）在嵌入空间中最近邻搜索查找与query最近的节点。</p><a id="more"></a><p>[TOC]</p><h3 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h3><h4 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h4><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.11.30/20201130184325.png" alt=""></p><p>用算子$\mathcal{P, L}$ 将查询$q$ embedding到 $\mathbf{q} \in \mathbb{R}^d$，目标是优化这些算子以用来预测q的回答——节点v。</p><p>通过生成query和node的嵌入向量，用距离来表示得分：</p><script type="math/tex; mode=display">\mathbb{score} (\mathbf{q},\mathbf{z}_v) = \frac{\mathbf{q}\cdot \mathbf{z}_v}{\begin{Vmatrix}\mathbf{q}\end{Vmatrix}\begin{Vmatrix}{\mathbf{z}_v}\end{Vmatrix}}</script><p>目标是生成一个能隐含表示的$\mathbf{q}$，即<script type="math/tex">\mathbb{score} (\mathbf{q},\mathbf{z}_v) = 1, \forall v \in [q]  \ and \ \mathbb{score} (\mathbf{q},\mathbf{z}_v) = 0,\forall v \notin [q]</script></p><p><strong>在推理时，对查询$q$ 的嵌入向量执行最近邻搜索，在嵌入向量空间中寻找可能满足查询的节点</strong>。</p><h4 id="生成嵌入向量-mathbf-q"><a href="#生成嵌入向量-mathbf-q" class="headerlink" title="生成嵌入向量 $\mathbf{q} $"></a>生成嵌入向量 $\mathbf{q} $</h4><ul><li><p>将query用其DAG依赖图表示</p><p>依赖图中包含anchor nodes和variable nodes和他们之间的边。其中查询目标为唯一的 汇聚节点</p></li><li><p>从其中anchor nodes的嵌入向量$\mathbf{z}_{v1} ,\cdots,\mathbf{z}_{vn}$ 开始，用$\mathcal{P, L}$ 从这些嵌入向量中计算$\mathbf{q}$</p></li></ul><h4 id="mathcal-P-算子"><a href="#mathcal-P-算子" class="headerlink" title="$\mathcal{P}$ 算子"></a>$\mathcal{P}$ 算子</h4><p>给定query的嵌入向量$\mathbf{q}$ 和边的类型$\tau$，几何投影（Projection）算子输出一个新的query嵌入向量$\mathbf{q’} = \mathcal{P}(\mathbf{q},\tau)$，相应的表示为$[q’]= \bigcup_{v \in [q]} \ N(v,\tau)$，其中$N(v,\tau)$ 表示和节点$v$ 通过$\tau$ 类型的边连接的节点集。</p><p>$\mathcal{P}$ 接收一个对应于节点集[q]的嵌入向量，输出一个对应于和其以$\tau$ 连接的节点集的嵌入向量。</p><p>$\mathcal{P}(\mathbf{q},\tau) = \mathbf{R_\tau q}$</p><p>其中$\mathbf{R_\tau^{d\times d}}$ 是边类型$\tau$ 的可训练参数矩阵。</p><h4 id="mathcal-L-算子"><a href="#mathcal-L-算子" class="headerlink" title="$\mathcal{L}$ 算子"></a>$\mathcal{L}$ 算子</h4><p>给定具有相同的输出节点类型$\gamma$ 的query的嵌入向量集$\mathbf{q_1},\cdots,\mathbf{q_n}$，几何交集（Intersection）算子输出一个新的嵌入向量$\mathbf{q’}$，对应于$[q’]=\bigcap_{i=1,\cdots,n}\ [q]_i$ ，在嵌入空间执行交集。</p><p>$\mathcal{L}(\{\mathbf{q_1},\cdots,\mathbf{q_n}\})=\mathbf{W}_\gamma\Psi(\mathbf{NN_k(q_i)},\forall i=1,\cdots,n)$</p><p>$\mathbf{NN_k}$ 是一个k层的前馈神经网络，$\Psi$ 是对称的向量函数，$\mathbf{W}_\gamma$ 是可训练的对每个节点类型$\gamma \in \Gamma$的变换矩阵</p><h4 id="用-mathcal-P-L-算子推理"><a href="#用-mathcal-P-L-算子推理" class="headerlink" title="用$\mathcal{P,L}$算子推理"></a>用$\mathcal{P,L}$算子推理</h4><p>为了生成query的嵌入向量，首先根据anchor nodes的出边对其嵌入向量投影（$\mathcal{P}$）。</p><p>如果一个节点在query的DAG中有多个入边，用$\mathcal{L}$ 算子聚合传入的信息。</p><p>然后重复这个过程直至到达query的目标。</p><h4 id="节点embedding"><a href="#节点embedding" class="headerlink" title="节点embedding"></a>节点embedding</h4><p>原则上，任何生成节点embedding的有效可微算法都可以用，本文中用了标准的”bag-of-features”方法，假设每一个类型为$\gamma$ 的节点都有一个相关的二值特征向量$\mathbf{x}_u \in \mathbb{Z}^{m_\gamma}$，计算embedding的方法如下：</p><p> $\mathbf{z}_u = \mathbf{\frac{Z_\gamma X_u}{|X_u|}}$</p><p>其中$\mathbf{Z_\gamma}$ 是可训练的embedding矩阵，$\mathbf{x_u}$ 是独热指示向量。</p>]]></content>
      
      
      <categories>
          
          <category> KG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KG </tag>
            
            <tag> Knowledge Reasoning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读: Reasoning on Knowledge Graphs with Debate Dynamics</title>
      <link href="2020/11/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Reasoning%20on%20Knowledge%20Graphs%20with%20Debate%20Dynamics/"/>
      <url>2020/11/28/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Reasoning%20on%20Knowledge%20Graphs%20with%20Debate%20Dynamics/</url>
      
        <content type="html"><![CDATA[<p>论文链接：<a href="https://arxiv.org/abs/2001.00461" target="_blank" rel="noopener">Reasoning on Knowledge Graphs with Debate Dynamics</a></p><p>主要思路是（1）对给定的query三元组，用强化学习的方法，两个agent分别寻找论证true和false的证据链；（2）Judge以二分类器评估两个Agent寻找的证据链中的每条证据，并给予Reward。</p><a id="more"></a><p>[TOC]</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>提出了基于辩论动力学的知识图谱自动推理方法。<strong>将三分类任务构建为一个两个强化学习系统间的辩论游戏</strong>。两个Agent以论证为目标抽取知识图谱中的路径，为正题或反题提供可解释证据。工作的重点是创建一种可解释的方法以保持高预测准确率。</p><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h3><p>KG以三元组$(s,p,o)$表示，subject 和 object对应图中的节点，predicate对应连接两者的边。KG中的节点表示现实世界实体，谓词描述实体对关系。</p><p>KG的主要问题是 <strong>大多数KG是不完整的/包含虚假事实的</strong>。针对该问题的一些机器学习算法致力于通过观察连通性模式来推断缺失的三元组或检测虚假事实。此外，问答和协同过滤任务等也可以通过预测连接来完成。大多数算法都将实体与谓词嵌入到低维向量空间中，然后根据这些嵌入值计算三元组的置信度得分。大多数基于嵌入的方法都具有黑箱特性——对用户隐藏了导致这个分数的因素。</p><p>大多数可解释的AI方法可以分为两种：<strong>因果解释能力和综合透明度</strong>，前者旨在揭示已经训练好的黑箱模型输出；综合透明度方法使用内部解释机制或因为模型复杂度低而自然可解释。而低复杂性和预测精度经常是相互冲突的。本文的目标是设计一种综合透明方法，兼顾效率和用户参与。</p><p>本文提出了基于强化学习的方法，受前人提出的通过debate提高AI安全性的概念启发。两个Agent对三元组提出论点进行判断，judge（二分类器）决定最终的真假。与大多数表示学习的方法相反，这些论点对用户可见，用户可以追溯judge的分类，并可以否决器决定。因此，R2D2的综合透明机制是基于可解释特征的自动提取而非低复杂度。</p><h3 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h3><script type="math/tex; mode=display">\mathcal{KG \subset E \times R \times E,\ E为实体集, \ R为关系集}</script><p>为了表明一个三元组的真假，引入二值特征函数 $\phi : \mathcal{E \times R \times E} \rightarrow \{0,1\}$</p><p>$\phi(s,p,o)=1$ 即该三元组为真。如果KG中没有包含某三元组，则该三元组未知而非错误（开放世界假设）。KG推理主要分为以下两个任务：</p><ul><li>缺失三元组的推理</li><li>预测三元组的truth value</li></ul><p>本文中triple classification指预测truth value即$\phi(s,p,o)$，而KG completion指评估$o \in  \mathcal{E}$与$(s,p) \in \mathcal{E \times R}$对形成真三元组的可能。</p><p>表示学习在KG中的基本思想是把实体和关系投影到一个低维向量空间中，然后将三元组的likelihood作为embedding空间上的函数来建模。Das et al. 提出了与本文相关的的多跳推理方法MINERVA，基本思想是向Agent显示查询的subject和predicate，让它们执行策略引导的walk以找到正确的object，产生的路径也具有一定的可解释性。</p><h3 id="3-Method"><a href="#3-Method" class="headerlink" title="3.  Method"></a>3.  Method</h3><p>根据两个对立的Agent间的辩论进行三元组分类，因此<strong>查询三元组</strong>至关重要（辩论中心）。Agent不断挖掘KG上可作为证据（正或反）的路径，即按顺序遍历图，根据过去的转换和查询三元组决定下一跳，并将该转换扩展到当前路径。所有路径都由一个judge分类器区分真假，步骤归纳如下：</p><ul><li>查询三元组被提供给两个Agent</li><li>两个Agent轮流从KG中提取证据路径</li><li>judge处理证据和查询三元组，评估三元组的truth value</li></ul><p><strong>States</strong> 每个Agent的状态空间为$\mathcal{S:E^2 \times R \times E} $，被表示为$S^{(i)}_t = (e^{(i)}_t,q),q=(s_q,p_q,o_q)，i \in \{1,2\}$，其中q为query三元组。</p><p><strong>Actions</strong> 某状态下可采取的行动集$\mathcal{A_{S^{(i)}_t}}$，由所有$e^{(i)}_t$的出边和对应的目标节点组成，包括自循环。</p><p><strong>Environments</strong> 环境根据Agent的Actions更新State。$\delta^{(i)}_t(S^{(i)}_t ,A^{(i)}_t) := (e^{(i)}_{t+1},q),S^{(i)}_t = (A^{(i)}_t,q),A^{(i)}_t = (r,e^{(i)}_{t+1})$</p><p><strong>Policies</strong> 用$H^{(i)}_t = (H^{(i)}_{t-1},A^{(i)}_{t-1})$ 表示Agent i到时间t的历史路径，其中$H^{(t)}_t = (s_q,p_q,o_q)$。用LSTM网络对其编码得到：</p><script type="math/tex; mode=display">h^{(i)}_t = LSTM^{(i)}([a^{(i)}_{t-1}, q^{(i)}]) \tag{1}\\其中a^{(i)}_{t-1}=[r^{(i)}_{t-1},e^{(i)}_t] \in \mathbb{R}^{2d}, q^{(i)}=[e^{(i)}_s,r^{(i)}_p,e^{(i)}_o] \in \mathbb{R}^{3d}</script><p>$a^{(i)}_{t-1}$ 表示前一个action，$r^{(i)}_{t-1},e^{(i)}_t$ 表示关系和目标实体的嵌入向量embedding，LSTM的输入应该是5个长度为d的向量。$q^{(i)}$ 对query三元组编码，每个Agent和judge的嵌入向量都是不同的，即每个节点、边有三个嵌入向量。</p><p>每个Agent  根据历史信息和待选择的actions计算每个action的得分：</p><script type="math/tex; mode=display">d^{(i)}_t = softmax(A^{(i)}_t(W^{(i)}_2 ReLU(W^{(i)}_1 h^{(i)}_t))) \tag{2} \\ 其中A^{(i)}_t \in \mathbb{R}^{|A_{S^{(i)}_t}| \times d}包括S^{(i)}_t 状态下的所有潜在action</script><p>此处$d^{(i)}_t$ 的分量表示选择actions中各action的概率，根据此概率概率采样选择下一action。</p><script type="math/tex; mode=display">A^{(i)}_t \sim Categorical(d^{(i)}_t) \tag{3}</script><p>这一策略是<strong>马尔可夫决策过程</strong>，仅考虑了t-1步的策略和t步的actions空间，与之前的信息无关。上述（1）和（2）定义了从历史信息到actions空间的映射，从而产生了策略变量$\pi_{\theta^{(i)}}$，$\theta^{(i)}$ 是等式中的可训练参数。</p><p><strong>Debate Dynamics</strong> 对第一步中两个Agent产生的结果进行辩论。以固定的轮数N，在每轮中两个Agent从$s_q$ 以固定的路径长遍历图，judge观察Agents的路径，对三元组做出预测。Agent 1根据式（1）-（3）产生包含states和actions的长度为T的序列，然后Agent 2产生类似的序列。algorithm 1</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.11.29/20201130184230.png" alt=""></p><p>每个Agent采样得到N个证据链，第n次采样得到的证据为：</p><script type="math/tex; mode=display">\tau_n^{(i)} := (A_{\overline n(i,T)+1},A_{\overline n(i,T)+2},\cdots,A_{\overline n(i,T)+T}) \tag{4} \\ 下标定义为 \overline n(i, T) := (2(n−1)+i−1)T.</script><p>结果汇总为：</p><script type="math/tex; mode=display">\tau := (\tau_1^{(1)},\tau_1^{(2)},\tau_2^{(1)},\tau_2^{(2)},\cdots,\tau_N^{(1)},\tau_N^{(2)}) \tag{5}</script><p><strong>The Judge</strong> R2D2中Judge有双重功能：</p><ul><li>二分类器，鉴别真伪事实</li><li>评估Agents的证据质量，并给予奖励，从而引导Agents产生有意义的证据</li></ul><p>judge通过前馈神经网络分别处理每个证据，将输出求和得到二分类器的结果：</p><script type="math/tex; mode=display">y_n^{(i)} = f ([\tau _n^{(i)}, q^J]) \tag{6}</script><script type="math/tex; mode=display">\tau _n^{(i)} := [a_{\overline n(i,T)+1}^J,a_{\overline n(i,T)+2}^J,\cdots,a_{\overline n(i,T)+T}^J] \tag{7}</script><p>其中$a_t^J = [r_t^J, e_t^J] \in \mathbb{R}^{2d}$ 表示Judge对$A_t$ 的嵌入向量embedding，$q^J = [r_p^J, e_o^J] \in \mathbb{R}^{2d}$ 表示Judge对query中predicate和object的嵌入向量embedding。处理完所有证据后，Judge根据$t_\tau \in (0,1)$ 评判查询三元组q：</p><script type="math/tex; mode=display">t_\tau = \sigma (w^TReLU(W \Sigma_{i=1}^2 \Sigma_{n=1}^N y_n^{(i)})) \tag{8}</script><p>其中$w$ 表示可训练参数，$\sigma$ 表示sigmoid函数。</p><p>通过交叉熵loss给出了judge的目标函数：</p><script type="math/tex; mode=display">\mathcal L_q = \phi (q) log\ t_\tau + (1-\phi(q))(1-log\ t_\tau) \tag{9}</script><p>R2D2的总体架构如下图所示：</p><p><img src="https://raw.githubusercontent.com/rooki3ray/blogImage/main/2020.11.29/20201129205921.png" alt=""></p><p><strong>Rewards</strong> </p><p>为了体现两个Agent工作的不同，judge对每个证据分别计算每个Agent的得分：</p><script type="math/tex; mode=display">t_n^{(i)} =  w^TReLU(Wf ([\tau _n^{(i)}, q^J])) \ \ (11)</script><p>$t_n^{(i)}$ 只和Agent i的第n轮证据有关，奖赏函数为：</p><script type="math/tex; mode=display">R_n^{i} = \begin{cases} t_n^{(i)},  & \text{if i = 1} \\ -t_n^{(i)}, & \text{otherwise} \end{cases} \tag{12}</script><p><strong>Reward Maximization and Training Scheme</strong></p><p>Agent的累计奖赏为：</p><script type="math/tex; mode=display">G^(i) := \Sigma_{n=1}^N R_n^{(i)} \tag{13}</script><p>用强化学习的思想最大化累计奖赏的期望以训练Agent：</p><script type="math/tex; mode=display">\mathop{argmin} \limits_{\theta^{(i)}} \mathbb{E}_{q \sim \mathcal{KG+}} \mathbb{E}_{\tau_1^{(i)},\tau_2^{(i)},\cdots,\tau_N^{(i)} \sim \pi_{\theta^{(i)}}}[G^{(i)} | q] \tag{14}</script><p>其中$\mathcal{KG+}$ 是训练三元组，除了包含KG中三元组外，还包含未观察到的三元组。通常会通过将正确三元组$(s,p,o)$ 中的$o$ 替代为空来创建负例。但本文中采用了<strong>生成看似合理但却错误的三元组</strong>的方法：对$(s,p,o)\in \mathcal{KG}$ 生成一个$(s,p,\widetilde o) \notin \mathcal{KG}$，但$\widetilde o$出现在$p$相关的其他关系中，即$\mathcal{KG}_C := \{(s,p,\widetilde o) | (s,p,\widetilde o) \notin \mathcal{KG},\exist \widetilde s:(\widetilde s,p,\widetilde o) \in \mathcal{KG}\}$。这种方法不会在<strong>破坏隐形约束的三元组</strong>上浪费资源。</p><p>模型的训练采用交替训练方案，一次只训练Agent或Judge。</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>出现提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING:tensorflow:Entity &lt;bound method TensorFlowOpLayer._defun_call of &lt;tensorflow.python.eager.function.TfMethodTarget object at 0x000001805B549780&gt;&gt; could not be transformed and will be executed as-is. Please report this to the AutoGraph team. When filing the bug, <span class="built_in">set</span> the verbosity to 10 (on Linux, `<span class="built_in">export</span> AUTOGRAPH_VERBOSITY=10`) and attach the full output. Cause: Bad argument number <span class="keyword">for</span> Name: 3, expecting 4</span><br></pre></td></tr></table></figure><p>需要安装低版本gast</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gast==0.2.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> KG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KG </tag>
            
            <tag> Knowledge Reasoning </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internet安全协议与分析</title>
      <link href="2020/10/12/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>2020/10/12/Internet%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>复习《Internet安全协议与分析》。</p><a id="more"></a><p>[TOC]</p><h2 id="CH1：无线通信系统安全"><a href="#CH1：无线通信系统安全" class="headerlink" title="CH1：无线通信系统安全"></a>CH1：无线通信系统安全</h2><h3 id="网络与因特网"><a href="#网络与因特网" class="headerlink" title="网络与因特网"></a>网络与因特网</h3><p>网络连接许多计算机，因特网连接许多网络。</p><h4 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h4><ul><li>单个网络ARPANET向互联网发展：1983年TCP/IP协议成为ARPANET上的标准协议。</li><li>建成了三级结构的因特网：主干网、地区网和校园网（企业网）。</li><li>形成了多层次ISP（Internet Service Provider）结构的因特网。</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>边缘部分：所有连接在因特网上的主机组成。这部分是用户直接使用，用于通信和资源共享。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，为边缘部分提供服务（连通性和交换）。</li></ul><h4 id="协议体系结构"><a href="#协议体系结构" class="headerlink" title="协议体系结构"></a>协议体系结构</h4><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="无线通信安全历史"><a href="#无线通信安全历史" class="headerlink" title="无线通信安全历史"></a>无线通信安全历史</h3><h4 id="移动通信"><a href="#移动通信" class="headerlink" title="移动通信"></a>移动通信</h4><ul><li>第一代：几乎没有采取安全措施</li><li>第二代：基于<strong>私钥密码体制</strong>的安全机制，通过系统对用户进行鉴权来防止非法用户使用网络，通过加密技术防止对无线信道进行窃听，但在身份认证及加密算法等方面存在着许多安全隐患</li><li>第三代：三个层面、五个安全域上提供安全措施。</li></ul><h4 id="无线局域网标准"><a href="#无线局域网标准" class="headerlink" title="无线局域网标准"></a>无线局域网标准</h4><p>IEEE 802.11 802.11b 802.11i</p><h4 id="无线通信网的主要安全威胁"><a href="#无线通信网的主要安全威胁" class="headerlink" title="无线通信网的主要安全威胁"></a>无线通信网的主要安全威胁</h4><h5 id="四个概念"><a href="#四个概念" class="headerlink" title="四个概念"></a>四个概念</h5><ul><li>无线终端：移动台/移动终端</li><li>无线接入点：移动通信中指基站，无线局域网中指无线路由器，负责接收和发送无线信号。</li><li>网络基础设施：满足通信基本要求的各种硬件与服务的总称。移动通信系统中主要是指包括基站、交换机在内的基本通信设备及其软件。</li><li>空中接口：无线终端和无线接入点之间的接口，移动通信系统中“移动性”的集中体现。</li></ul><h5 id="三个威胁"><a href="#三个威胁" class="headerlink" title="三个威胁"></a>三个威胁</h5><ul><li>对传递信息的威胁：针对系统中传输的个人消息<ul><li><strong>侦听</strong>：非授权方可能获悉传输或存储在系统中的信息。</li><li><strong>篡改</strong>：非授权方更改系统中的各种信息。（非法修改和重放）</li><li><strong>抵赖</strong>：参与通信的一方否认或部分否认他的行为。（接受抵赖和源发抵赖）</li></ul></li><li>对用户的威胁：针对系统中用户的一般行为<ul><li>流量分析：指分析网络中的通信流量。<ul><li>防止方法：：对消息内容和可能的控制信息进行<strong>加密</strong>。（如果采用低级别（链路之间）加密通信，也可以采用其他模式进行统计分析，因此可以采用类似<strong>消息填充和插入虚假消息</strong>等作为加密措施的补充）</li></ul></li><li>监视：监视一个特殊用户的行为。<ul><li>防止方法：使用假名来实现匿名发送、接受和计费。</li></ul></li></ul></li><li>对通信系统的威胁：破坏整个系统的完整或功能<ul><li>拒绝服务：系统内外的非法攻击者故以削弱系统的服务能力或使系统无法提供服务。</li><li>资源的非授权使用：使用禁用资源或越权使用无线信道、设备、服务或系统数据库邓系统资源。</li><li>越权使用资源：用户允许使用一些资源，但访问的资源超越了权限范围。</li></ul></li></ul><h3 id="移动通信系统的安全需求"><a href="#移动通信系统的安全需求" class="headerlink" title="移动通信系统的安全需求"></a>移动通信系统的安全需求</h3><ul><li>能唯一标识用户</li><li>冒充合法用户是困难的</li><li>信令、传输数据和身份等信息应是保密的</li><li>双向认证：合法的用户、信任的网络和服务提供商。</li><li>机密性：用户和网络服务器之间需协商会话密钥用于消息加密。密钥协商通常是认证过程的最后部分，为了增强安全性，每次通信的会话密钥必须不同。</li><li>用户身份的匿名性</li><li>不可否认性</li><li>完整性：消息和业务的完整性</li><li>新鲜性：防重传攻击的重要手段，时间戳、随机数、计数器</li><li>公平性</li><li>端到端保密</li><li>合法的监视</li><li>调度功能：<ul><li>认证</li><li>通信的机密性</li><li>通信的完整性</li></ul></li></ul><h3 id="移动通信系统的安全体系"><a href="#移动通信系统的安全体系" class="headerlink" title="移动通信系统的安全体系"></a>移动通信系统的安全体系</h3><p>系统的任何一个安全措施都可以映射成这个三维空间的一个点，可以解释为每个安全措施都是在某个安全域内，为满足某个层次上的安全需求而提供的某种安全服务。</p><p><img src="https://s1.ax1x.com/2020/10/10/0y9KUI.png" alt="0y9KUI.png"></p><h4 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h4><ul><li>认证和密钥管理服务<ul><li>在移动终端接入网络或一次通话开始时鉴权；认证服务包括用户和网络之间鉴权、网络实体间的认证以及在终端内安全服务模块和终端的认证。</li><li>密钥管理是产生、分发、选择、删除、和管理在鉴权和加解密过程中使用的密钥的过程</li></ul></li><li>访问控制服务：防止对任何资源进行非授权访问</li><li>完整性服务</li><li>机密性服务</li><li>不可否认性服务</li></ul><h4 id="安全需求"><a href="#安全需求" class="headerlink" title="安全需求"></a>安全需求</h4><ul><li>管理层：对安全威胁的管理和制定合理的管理标准</li><li>用户层：提供事务处理的端到端安全</li><li>控制层：负责网络过程。</li><li>链路层：保证数据在无线电线路上传输的正确性和安全性。</li><li>物理层：由定时结构、无线电射频发射和接收等部分组成。</li></ul><h4 id="安全域"><a href="#安全域" class="headerlink" title="安全域"></a>安全域</h4><ul><li>网络接入域安全：安全接入服务</li><li>网络域安全：网络实体间的认证、数据传输机密性和完整性、攻击信息的监视等</li><li>用户域安全：主要提供终端安全服务模块域用户间的认证以及终端安全服务模块域移动终端间的认证。</li></ul><h3 id="移动通信系统安全"><a href="#移动通信系统安全" class="headerlink" title="移动通信系统安全"></a>移动通信系统安全</h3><h4 id="GSM系统"><a href="#GSM系统" class="headerlink" title="GSM系统"></a>GSM系统</h4><p>GSM系统主要由移动终端（ MS ）、基站子系统 （BSS ）、网络子系统（NSS ）、介于操作人员与系统设备之间的操作与维护子系统 （OSS ）和各子系统之间的接口共同组成。</p><h5 id="GSM系统的安全目标"><a href="#GSM系统的安全目标" class="headerlink" title="GSM系统的安全目标"></a>GSM系统的安全目标</h5><ul><li>防止未经授权的用户接入网络：通过鉴权机制<ul><li>用户身份认证</li></ul></li><li>用户的隐私权保护：通过加解密技术<ul><li>数据机密性</li><li>用户身份（IMSI，国际移动用户标识）保密</li></ul></li></ul><h5 id="GSM系统的安全实体"><a href="#GSM系统的安全实体" class="headerlink" title="GSM系统的安全实体"></a>GSM系统的安全实体</h5><ul><li>SIM</li><li>GSM手机和基站</li><li>GSM网络子系统</li></ul><h5 id="GSM系统的鉴权过程"><a href="#GSM系统的鉴权过程" class="headerlink" title="GSM系统的鉴权过程"></a>GSM系统的鉴权过程</h5><p><img src="https://s1.ax1x.com/2020/10/13/0fdQYV.png" alt="0fdQYV.png"></p><ul><li>GSM网络侧从业务请求<strong>提取TMSI或IMSI</strong>，并查看是否保存有认证向量三元组triplet（RAND，XRES，Kc），有则可以<strong>直接给MS发送RAND</strong>作为挑战信息，否则继续。</li><li>VLR<strong>向鉴权中心AuC发送认证数据请求</strong>，其中包含用户的IMSI。</li><li>认证中心<strong>根据用户的IMSI找到用户的密钥Ki</strong>，然后利用<strong>自己产生的随机数RAND</strong>，利用A3算法，产生预期响应<strong>XRES</strong>，利用A8算法产生用于加密的密钥Kc，即产生认证向量三元组：triplet（RAND，XRES，Kc），发送到MSC/VLR；</li><li>MSC/VLR将其中的RAND发送给MS，MS中的SIM卡<strong>根据收到的RAND和存储在卡中的Ki</strong>，利用A3和A8算法分别计算出用于认证的响应<strong>RES</strong>和用于加密的密钥（Kc），并将RES回送到MSC/VLR中；</li><li>在MSC/VLR里，比较来自MS的RES和来自认证中心的XRES，若不同，则认证失败，拒绝用户接入网络；若相同，则认证成功，用户可以访问网络服务，并且在后续的通信过程中，用户和基站之间无线链路的通信利用加密密钥Kc和A5算法进行加密。</li></ul><h5 id="GSM系统的加密机制"><a href="#GSM系统的加密机制" class="headerlink" title="GSM系统的加密机制"></a>GSM系统的加密机制</h5><p>被加密数据包括信令消息、业务信道上的用户数据和信令信道上无连接的用户数据。</p><p>这一机制涉及 4 种网络功能：加密方法协商、密钥设置、加解密过程的发起、加/解密的同步。加密算法采用流密码 A5 算法，待加密数据和 A5 的输出逐比特异或。</p><h5 id="GSM系统的匿名机制"><a href="#GSM系统的匿名机制" class="headerlink" title="GSM系统的匿名机制"></a>GSM系统的匿名机制</h5><ul><li>为保证用户身份的机密性，对用户的鉴权成功之后，网络为用户分配<strong>临时移动用户标识 TMSI</strong> 来替代国际移动用户标识 IMSI ，使第三方无法在无线信道上跟踪 GSM 用户。</li></ul><h5 id="GSM系统的安全性分析"><a href="#GSM系统的安全性分析" class="headerlink" title="GSM系统的安全性分析"></a>GSM系统的安全性分析</h5><ul><li>安全算法方面：算法安全性未经公众验证。 A3/A8 算法易受到选择质询（ chosen challenge ）攻击 A5 语音保密算法被已知明文攻击攻破。</li><li>安全机制设计方面：只在空中接口实施了单项鉴权和加密，在固定网内没有定义安全功能，攻击者如果在固定网窃取认证向量三元组，就可以冒充网络单元。</li><li>系统对用户进行 <strong>单向实体认证</strong> ，很难防止中间人攻击和假基站攻击<ul><li>获取正常基站的GSM频率后，使用该GSM频率并以更高功率伪装诱骗连接。</li></ul></li><li>GSM 系统本身不提供端到端的加密；</li><li>用户数据和信令数据缺乏完整性保护机制。</li></ul><h4 id="3G系统"><a href="#3G系统" class="headerlink" title="3G系统"></a>3G系统</h4><h5 id="3G系统实体"><a href="#3G系统实体" class="headerlink" title="3G系统实体"></a>3G系统实体</h5><ul><li>移动终端<ul><li>ME ：移动设备 Mobile Equipment </li><li>USIM ：全球用户识别模块 Universal Subscriber Identity Module</li></ul></li><li>无线接入系统：UTRAN、GERAN</li><li>核心网：分组交换域PS、电路交换域CS</li></ul><h5 id="3G安全架构"><a href="#3G安全架构" class="headerlink" title="3G安全架构"></a>3G安全架构</h5><p>特点：</p><ul><li>基于IP网络</li><li><strong>非话音服务</strong>的多样性和重要性</li><li>将增强用户服务范围的控制和对其终端能力的控制</li><li>存在对用户的主动攻击</li><li>终端将用作电子商务应用和其它应用的平台</li></ul><p>安全域：</p><ul><li>接入域</li><li>网络域</li><li>用户域</li><li>应用域：用户域服务提供商在应用层面安全交换数据。</li><li>安全的可视性和可配置性：使用户知道网络的安全性服务是否在运行，以及它所使用的服务是否安全。</li></ul><h4 id="LTE网络"><a href="#LTE网络" class="headerlink" title="LTE网络"></a>LTE网络</h4><p>由UE、E-UTRAN、EPC三部分构成</p><p>LTE的网络从空口无线侧开始就是 IP 网络，同时智能终端只要开启电源就会附着 IP 地址，因而智能终端、 LTE 无线接入侧、传输网侧和 EPC 都面临着原来 IP 网络固有的安全威胁：</p><ul><li>无线侧智能终端面临僵木蠕、恶意代码等攻击；</li><li>无线智能侧终端成为 DDoS 攻击源对整个 LTE EPS 网络发起 DDoS 攻击；</li><li>EPC 核心网元面临信令风暴问题；</li><li>智能终端通过 LTE EPC 、 Internet 等非信任网络时进行明文传输敏感数据时，面临泄露数据的问题；</li><li>LTE EPS 综合业务平台面临攻击的威胁；</li><li>EPC Pi 口 (P GW&lt;—&gt; 面临来自 Internet 攻击的威胁；</li></ul><h3 id="无线局域网安全（WLAN）"><a href="#无线局域网安全（WLAN）" class="headerlink" title="无线局域网安全（WLAN）"></a>无线局域网安全（WLAN）</h3><p>基于IEEE802.11协议的无线局域网分为基础结构（infrastructrue）模式和自组织（ad-hoc）模式</p><p>基础结构模式网络结构由AP（固定接入点）和STA（无线设备）组成。</p><h4 id="无线局域网关联过程"><a href="#无线局域网关联过程" class="headerlink" title="无线局域网关联过程"></a>无线局域网关联过程</h4><p>AP以固定的时间间隔（通常为每秒钟10次）发送信标，它们能使无线设备发现AP的标识。STA初始化后，开始寻找AP。STA会依次调谐到每个无线频段（称为信道）上，并收听信标消息。这个过程称为<strong>扫描</strong>。</p><ul><li>STA-&gt;AP 认证请求</li><li>AP-&gt;STA  认证响应</li><li>STA-&gt;AP 关联请求</li><li>AP-&gt;STA 关联响应</li></ul><p>三种消息：</p><ul><li>控制</li><li>管理</li><li>数据</li></ul><h4 id="IEEE802-11-认证"><a href="#IEEE802-11-认证" class="headerlink" title="IEEE802.11 认证"></a>IEEE802.11 认证</h4><ul><li><p>开放系统认证（默认认证机制）</p><p>整个认证过程以明文形式进行，包括认证请求和响应</p></li><li><p>共享密钥认证</p><p>响应工作站根据当前请求工作站是否拥有合法的密钥来决定是否允许接入，但不要求在空中接口传送这个密钥。</p><ul><li>请求工作站-&gt;响应工作站 请求认证</li><li>响应工作站-&gt;请求工作站 随机质询文本</li><li>请求工作站-&gt;响应工作站 共享密钥加密文本</li></ul></li></ul><h4 id="IEEE802-11-加密"><a href="#IEEE802-11-加密" class="headerlink" title="IEEE802.11 加密"></a>IEEE802.11 加密</h4><p>802.11 定义了 WEP Wired Equivalent Privacy ）来为无线通信提供和有线网络相近的安全性来有效的防止窃听。</p><p>WEP基于RC4算法，必须在每帧重新初始化密钥流，需要引入IV和ICV。</p><h5 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h5><p><img src="https://s1.ax1x.com/2020/10/16/0H3Fwd.png" alt="0H3Fwd.png"></p><h5 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h5><p><img src="https://s1.ax1x.com/2020/10/16/0H3lwj.png" alt="0H3lwj.png"></p><h4 id="WEP的分析"><a href="#WEP的分析" class="headerlink" title="WEP的分析"></a>WEP的分析</h4><ul><li><p>认证及其弱点</p><p>IEEE802.11认证手段不能有效实现认证目的，且是<strong>单向认证</strong>，伪装AP的攻击很容易实现（会话劫持和中间人攻击）</p><ul><li>开放系统认证：空认证</li><li>共享密钥认证：一旦攻击者得到密钥流，就可以完成认证</li><li>服务组标识符SSID：SSID是用来逻辑分割无线网络，以防止一个工作站意外连接到邻居AP 上，它并不是为提供网络认证服务而设计的。一明文形式传送，不提供用户认证。</li><li>MAC地址控制：迫使只有注册了MAC的工作站才能连接到AP上，但用户可以重新配置无线网卡的MAC地址，并不能阻止非授权用户访问。</li></ul></li><li><p>完整性分析</p><ul><li>ICV采用CRC-32实现，只用来检查随即错误，不具备身份认证能力；且CRC-32对异或运算是线性的，不能抵御对明文的篡改。</li><li>WEP的完整性保护只应用于数据载荷，而不保护地址以及防止重放等。</li></ul></li><li><p>机密性分析</p><ul><li>弱密钥问题：RC4算法密钥空间存在大量弱密钥</li><li>静态共享密钥和IV空间：没有密钥管理方法，使用静态共享密钥；IV管理很困难，易重用。</li></ul></li></ul><h4 id="IEEE802-11安全问题"><a href="#IEEE802-11安全问题" class="headerlink" title="IEEE802.11安全问题"></a>IEEE802.11安全问题</h4><ul><li>认证协议简单且为单向认证</li><li>完整性算法CRC-32不能阻止攻击者篡改数据</li><li>WEP不能抵抗<strong>重放</strong>攻击</li><li>IV和Share Key级联在RC4算法下容易产生<strong>弱密钥</strong></li><li>IV易发生重用冲突</li></ul><h3 id="移动自组网络安全（Ad-Hoc）"><a href="#移动自组网络安全（Ad-Hoc）" class="headerlink" title="移动自组网络安全（Ad Hoc）"></a>移动自组网络安全（Ad Hoc）</h3><p>AdHoc网络中的每个移动终端兼备路由器和主机两种功能：</p><ul><li>主机需要运行面向用户的应用程序；</li><li>路由器需要运行相应的路由协议，根据路由策略和路由表参与分组转发和路由维护工作。</li></ul><p>Ad Hoc 网络节点间的路由通常由多个网段（跳）组成，由于终端的无线传输范围有限，两个无法直接通信的终端节点往往要通过多个中间节点的转发来实现通信。</p><h4 id="移动Ad-Hoc网络的特点"><a href="#移动Ad-Hoc网络的特点" class="headerlink" title="移动Ad Hoc网络的特点"></a>移动Ad Hoc网络的特点</h4><ul><li>网络的自组织性</li><li>动态的网络拓扑</li><li>多跳的通信路由</li><li>有限的无线通信带宽</li><li>有限的主机能源</li><li>网络的分布式特点</li><li>安全性较差</li></ul><h4 id="移动Ad-Hoc网络的安全弱点"><a href="#移动Ad-Hoc网络的安全弱点" class="headerlink" title="移动Ad Hoc网络的安全弱点"></a>移动Ad Hoc网络的安全弱点</h4><ul><li>传输信道：采用无线信号作为传输媒介，容易被窃听/干扰；</li><li>移动节点：节点是自主移动的，安全性比较脆弱；</li><li>动态拓扑：节点位置不固定，网络拓扑不断变化；</li><li>路由协议：路由协议假定了所有节点相互合作。</li></ul><h4 id="移动Ad-Hoc网络的密钥管理"><a href="#移动Ad-Hoc网络的密钥管理" class="headerlink" title="移动Ad Hoc网络的密钥管理"></a>移动Ad Hoc网络的密钥管理</h4><ul><li>部分分布的CA：每个节点拥有证书签名密钥的一部分，可产生部分证书，但只有组合k个才能得到有效证书。</li><li>自安全方案：CA功能完全分布到系统每个节点。</li></ul><h4 id="移动Ad-Hoc网络的安全路由"><a href="#移动Ad-Hoc网络的安全路由" class="headerlink" title="移动Ad Hoc网络的安全路由"></a>移动Ad Hoc网络的安全路由</h4><p>移动Ad Hoc网络不能采用常规路由协议，因为：</p><ul><li>主机间的无线信道可能存在单向信道</li><li>动态变化的拓扑结构</li><li>有限的无线传输带宽</li><li>无线移动终端的局限性</li></ul><p>Ad Hoc网络的拓扑结构主要有平面结构和分级结构两种，协议也划分为平面结构的路由协议和分簇式路由协议。</p><h5 id="针对Ad-Hoc网络路由协议的攻击"><a href="#针对Ad-Hoc网络路由协议的攻击" class="headerlink" title="针对Ad Hoc网络路由协议的攻击"></a>针对Ad Hoc网络路由协议的攻击</h5><ul><li><p>路由破坏攻击</p><ul><li>篡改</li><li>删除</li><li>虫洞</li><li>伪造路由错误</li><li>rushing</li></ul></li><li><p>资源消耗攻击</p><ul><li>Dos</li><li>伪造路由发现</li><li>路由表溢出</li></ul></li></ul><h5 id="Ad-Hoc网络路由协议的特点"><a href="#Ad-Hoc网络路由协议的特点" class="headerlink" title="Ad Hoc网络路由协议的特点"></a>Ad Hoc网络路由协议的特点</h5><ul><li>协议能够抵抗单攻击者的安全威胁，对于联合攻击如Worm hole无法抵抗</li><li>协议强调了安全性而忽视了可用性，节点算力弱，电池和通信带宽有限</li><li>屏蔽了路由协议的某些功能，降低了路由协议的有效性</li><li>有的协议要求网络中存在集中服务器，有单点失效的风险</li></ul><h5 id="Ad-Hoc网络的入侵检测"><a href="#Ad-Hoc网络的入侵检测" class="headerlink" title="Ad Hoc网络的入侵检测"></a>Ad Hoc网络的入侵检测</h5><ul><li>无公信结点集中控制节点的认证</li><li>没有集中网络流量的节点，无法集中监控</li><li>正常节点和恶意节点的行为区别不明显</li><li>资源和带宽有限</li></ul><h3 id="无线传感器网络（WSN）"><a href="#无线传感器网络（WSN）" class="headerlink" title="无线传感器网络（WSN）"></a>无线传感器网络（WSN）</h3><p>WSN系统包括传感器节点、汇聚节点（基站/网关）和管理节点。</p><ul><li>传感器节点随机部署在监测区域内部或附近，通过自组织方式构成网络，用于收集数据，并且将数据路由至汇聚节点；</li><li>汇聚节点与管理节点通过广域网络(如Internet网络、移动通信网络或者卫星网络等)或直接进行通信，从而将收集到的数据传送到管理节点；</li><li>用户通过管理节点对传感器网络进行配置和管理、发布监测任务以及收集监测数据。</li></ul><h4 id="WSN的特点"><a href="#WSN的特点" class="headerlink" title="WSN的特点"></a>WSN的特点</h4><ul><li>无控制中心</li><li>自组织性</li><li>动态拓扑</li><li>多跳路由</li><li>节点数量大、分布广</li><li>与应用相关的网络</li><li>资源有限</li></ul><h4 id="WSN面临的安全威胁和措施"><a href="#WSN面临的安全威胁和措施" class="headerlink" title="WSN面临的安全威胁和措施"></a>WSN面临的安全威胁和措施</h4><ul><li><p>物理层</p><ul><li><p>信号干扰/阻塞</p><p>扩频通信</p></li><li><p>窃听</p><p>加密敏感信息</p></li><li><p>节点被俘</p><p>实行篡改证明，但成本较高，WSN中不用。</p></li></ul></li><li><p>数据链路层</p><ul><li><p>碰撞</p><p>使用纠错码</p></li><li><p>资源耗尽</p><p>对MAC访问许可进行控制；时分复用；邻居节点监视反常行为</p></li><li><p>不公平访问（弱Dos）</p></li></ul></li><li><p>网络层</p><ul><li><p>仿冒节点</p><p>网络各节点之间相互认证</p></li><li><p>虫洞</p></li><li><p>HELLO洪泛：以能量足够大的信号广播，使节点认为攻击者使直接邻居，导致网络混乱</p><p>建立对密钥，以便任意两个邻居节点相互验证；利用基站检查节点身份和邻居关系</p></li><li><p>确认欺骗：使发送者相信一条差链路</p></li><li><p>虚假路由</p></li><li><p>选择性转发</p><p>使用多条路径同时发送或采取协议检测恶意节点</p></li><li><p>槽洞（sinkhole）：尽可能地引诱一个区域中的流量通过恶意节点</p><p>采用随机密钥预分配机制和基站入侵检测与响应</p></li><li><p>女巫（Sybil）：位于某个位置的单个恶意节点不断的声明其有多重身份（如多个位置等），使得它在其它节点面前具有多个不同的身份。</p><p>建立对密钥，以便任意两个邻居节点相互验证</p></li></ul></li><li><p>传输层</p><ul><li>洪泛：当需要一个协议来<strong>维护一个连接两端的状态</strong>时，通过洪泛攻击可以使内存很快耗尽。攻击者可能重复建立新的连接请求直到每个连接需要的资源耗尽或达到上限。无论是哪种情况，接下来的合法请求都会被拒绝。</li><li>分离式同步：是指中断一个已有的连接。比如，攻击者可能重复地对一个终端主机发送欺骗信息而引起主机要求重发丢失的包。如果时间恰当，攻击者就能够降低甚至阻止终端主机成功交换数据，因此，发送端将不断地试图恢复实际并不存在的错误而无法进行正常的通信。</li></ul></li><li><p>应用层</p></li></ul><h2 id="CH2：安全协议概述"><a href="#CH2：安全协议概述" class="headerlink" title="CH2：安全协议概述"></a>CH2：安全协议概述</h2><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><ul><li>协议：两个或以上的参与者采取一系列步骤已完成某项特定的任务</li><li>安全协议：密码体制基础上的一种高互通协议</li></ul><h4 id="安全协议常见类型"><a href="#安全协议常见类型" class="headerlink" title="安全协议常见类型"></a>安全协议常见类型</h4><ul><li>密钥交换协议：用于完成会话密钥的建立</li><li>认证协议：实体、身份、数据源、消息。用来防止篡改、假冒、否认等攻击</li><li>认证和密钥交换协议：互联网密钥交换协议IKE、分布认证安全服务DASS、Kerberos认证协议等</li><li>电子商务协议：协议双方存在利益矛盾，需要保证公平。电子商务SET协议</li></ul><h4 id="安全协议系统模型"><a href="#安全协议系统模型" class="headerlink" title="安全协议系统模型"></a>安全协议系统模型</h4><ul><li>环境定义<ul><li>系统环境：消息的发送和接收者、攻击者（恶意网络环境）、管理消息发送和接收的规则</li><li>恶意网络环境：攻击者</li><li>攻击者操作：截取、重放、篡改、级联、分离、加密、解密</li><li>被动攻击者：知晓信息</li><li>主动攻击者：操纵信息</li></ul></li><li>攻击行为<ul><li>转发消息到特定接收者处</li><li>延迟消息的送达</li><li>篡改后转发</li><li>合并消息</li><li>改变部分或全部消息的去处</li><li>重放消息</li></ul></li></ul><h4 id="安全协议的性质及实现"><a href="#安全协议的性质及实现" class="headerlink" title="安全协议的性质及实现"></a>安全协议的性质及实现</h4><p>目的通过协议消息的传递来达成通信主体身份的<strong>识别与认证</strong>，并在此基础上为下一步的秘密通信分配所使用的<strong>会话密钥</strong></p><ul><li><p>认证性实现</p><p>通过共享秘密实现：可以对抗假冒攻击，确保身份</p><ul><li>声称者用仅他和验证者知道的密钥封装消息</li><li>声称者用私钥签名，验证者用公钥验证签名</li><li>声称者通过可信第三方证明自己</li></ul></li><li><p>秘密性实现</p><ul><li>目的：保护协议消息不泄露；攻击者无法根据消息格式提炼消息</li><li>实现方法：对消息明文加密</li></ul></li><li><p>完整性实现</p><ul><li>目的：保护协议消息不被非法篡改、删除和替代</li><li>实现方法：封装和签名</li></ul></li><li>不可否认性实现<ul><li>目的：通过通信主体提供对方参与协议交换的证据来保证合法利益不受侵害</li><li>实现方法：签名消息</li><li>协议特点：证据的正确性，交易的公平性。 次要：适时中止性、可追究性</li></ul></li></ul><h4 id="协议设计准则"><a href="#协议设计准则" class="headerlink" title="协议设计准则"></a>协议设计准则</h4><ul><li><p>消息独立完整性原则：一条消息的解释应完全由该条消息的内容决定，不必借助上下文推断</p><ul><li><p>常用的协议消息描述格式：</p><p>&lt;序列号&gt;发送者标识-&gt;接收者标识：消息</p><p><2>A-&gt;B：m   m应包含A、B的标识，否则易造成攻击</p></li></ul></li><li><p>消息前提准确原则：与消息的执行相关的先决前提条件应当明确指出，且正确性和合理性能够验证，由此判断消息是否应当被接收，即<strong>每条消息所基于的假设是否能够成立</strong>。</p></li><li>主体身份标识原则：主体标识重要时应在消息中明确附上主体名称<ul><li>显式：明文主体名字</li><li>隐式：加密或签名</li></ul></li><li>加密目的原则：加密可实现多种安全目的（秘密性、完整性、认证性），使用加密算法前确定目的</li><li>签名原则：主体对加密消息签名并不表明主题知道加密消息的内容，如果主体先签名再加密，则表明主体知道消息内容。同时使用加密和签名时，应<strong>先签名后加密</strong>。</li><li>随机数的使用原则：使用随机数的目的是提供消息的新鲜性。关键问题是随机数的真正随机性。</li><li>时戳的使用原则：考虑各机器的时钟与当地标准时间的差异，时戳的使用主要依赖于时钟同步。</li><li>编码原则：明确指出具体的编码格式</li></ul><h4 id="安全协议缺陷分类"><a href="#安全协议缺陷分类" class="headerlink" title="安全协议缺陷分类"></a>安全协议缺陷分类</h4><ul><li>基本协议缺陷：设计时很少考虑攻击者</li><li>口令/密钥猜测缺陷<ul><li>可检测的口令在线猜测攻击：不成功的登录能被检测并记录</li><li>不可检测的口令在线猜测攻击：攻击者从响应中逐渐推导出正确的口令</li><li>可离线的口令猜测攻击：攻击者使用认证协议消息附件，猜测口令并离线验证</li><li>改进措施：只响应新鲜的请求；只响应可验证的真实性。</li></ul></li><li>陈旧消息缺陷：消息的新鲜性——消息重放攻击</li><li>并行会话缺陷：攻击者通过交换一定的协议消息获得重要的消息</li><li>内部协议缺陷：协议参与者中至少有一方不能完成所有必须的动作</li><li>密码系统缺陷：密码算法的安全强度问题</li></ul><h4 id="消息重放攻击及对策"><a href="#消息重放攻击及对策" class="headerlink" title="消息重放攻击及对策"></a>消息重放攻击及对策</h4><p>攻击利用其消息再生能力生成诚实用户所期望的消息格式并重放，分为本协议的轮内攻击和轮外攻击。</p><p>消息去向：发送方——反射攻击；第三方——第三方攻击；接收方但被延迟——直接攻击</p><p>对策：</p><ul><li><p>序列号机制——接收方通过比较消息中的序列号以判断消息是新产生的还是重放的</p><p>问题：开销增大，小型系统适用</p></li><li><p><strong>挑战-应答机制</strong>——消息的时间变量参数由接收方在该消息传递前明确地向消息发送方说明</p><p>问题：系统开销增加</p></li><li><p>时戳机制——当消息上地时戳与本地时间差值在一定范围内才有效</p><p>问题：需要全局时钟，但仍难以同步</p></li></ul><h2 id="CH3：IPSec协议"><a href="#CH3：IPSec协议" class="headerlink" title="CH3：IPSec协议"></a>CH3：IPSec协议</h2><h3 id="IP安全问题"><a href="#IP安全问题" class="headerlink" title="IP安全问题"></a>IP安全问题</h3><p>IP协议从本质上来说是不安全的，修改IP包重新计算校验和很容易。</p><p>IPv4没有安全选项，缺乏通信双方真实<strong>身份验证</strong>、<strong>数据完整性和机密性保护</strong>……</p><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><p>IPSec随着IPv6产生，有三种机制共同保障：<strong>认证、信息机密性和密钥管理</strong></p><p>IPSec 提供访问控制、无连接完整性、数据源鉴别、载荷机密性和有限流量机密等安全服务。</p><h3 id="IPSec体系结构"><a href="#IPSec体系结构" class="headerlink" title="IPSec体系结构"></a>IPSec体系结构</h3><p><a href="https://imgchr.com/i/BSUWod" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSUWod.png" alt="BSUWod.png"></a></p><h4 id="安全联盟SA"><a href="#安全联盟SA" class="headerlink" title="安全联盟SA"></a>安全联盟SA</h4><p>SA是两个通信实体间建立的一个简单单向协定，由安全参数索引SPI和目标地址组成，单个IPSec连接至少需要两个SA。</p><h4 id="安全策略库SPD"><a href="#安全策略库SPD" class="headerlink" title="安全策略库SPD"></a>安全策略库SPD</h4><p>用于提供安全策略配置，其中的动作指定某些数据流必须绕过IPSec的处理、某些丢弃、其余的必须经过IPSec模块的处理。</p><p>含有规则列表：<TrafficSelector, action></p><ul><li>Traffic Selectors: IP addresses and/or ports, protocol;</li><li>Actions: Discard; Bypass IPsec; Apply IPsec</li></ul><h4 id="安全关联数据库SAD"><a href="#安全关联数据库SAD" class="headerlink" title="安全关联数据库SAD"></a>安全关联数据库SAD</h4><p>包含了所有活跃SA的所有参数信息。</p><p>流出数据由SPD数据项包含指向某SAD数据项的指针，决定数据包使用的SA。</p><p>流入数据由SAD决定如何对数据包做处理。</p><h4 id="认证头AH"><a href="#认证头AH" class="headerlink" title="认证头AH"></a>认证头AH</h4><p>为IP通信提供数据源认证，数据完整性和反重播保证，可防篡改，不防窃听，<strong>无机密性保护</strong></p><p>原理：在每一个数据包上添加身份验证报头，包含一个带密钥的hash散列，提供<strong>完整性保护</strong>。</p><h5 id="AH传输模式"><a href="#AH传输模式" class="headerlink" title="AH传输模式"></a>AH传输模式</h5><p><a href="https://imgchr.com/i/BSaXnO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSaXnO.png" alt="BSaXnO.png"></a></p><p>AH被插在原始IP头之后但在所有的传输层协议或其他IPSec协议头之前 。</p><p>使用原始的明文IP头，安全信息在AH中，可以保证整个IP包不被修改。</p><p><strong>AH在传输模式下和NAT是冲突的</strong>，因为NAT会修改源/目的IP地址。</p><h5 id="AH隧道模式"><a href="#AH隧道模式" class="headerlink" title="AH隧道模式"></a>AH隧道模式</h5><p><a href="https://imgchr.com/i/BSd3uT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSd3uT.png" alt="BSd3uT.png"></a></p><p>AH插在原始IP头之前，共同作为IP数据部分。加密整个IP数据报，用自己的地址作为源地址加入新的IP头。</p><p>验证整个IP包，<strong>AH在隧道模式下也与NAT冲突</strong>。</p><h4 id="封装安全载荷ESP"><a href="#封装安全载荷ESP" class="headerlink" title="封装安全载荷ESP"></a>封装安全载荷ESP</h4><p>ESP是插入IP数据包内的一个协议头，提供机密性、数据源认证、抗重播以及数据完整性等安全服务。</p><p>ESP将保护数据加密后封装在IP包中。也提供认证服务。</p><p><strong>ESP总是先使用，AH头在最外层</strong></p><h5 id="ESP传输模式与隧道模式"><a href="#ESP传输模式与隧道模式" class="headerlink" title="ESP传输模式与隧道模式"></a>ESP传输模式与隧道模式</h5><p><a href="https://imgchr.com/i/BSdzrT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSdzrT.png" alt="BSdzrT.png"></a></p><p><a href="https://imgchr.com/i/BSwSqU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/BSwSqU.png" alt="BSwSqU.png"></a></p><p>ESP在传输模式时会保护TCP/UDP头，但是并不保护IP 头，因此修改IP 地址并不会破坏整个数据包的完整性。但是如果数据包是TCP/UDP数据包，NAT设备就需要修改数据包的校验值（被ESP 所保护）。所以<strong>ESP在传输模式不能用于NAT穿越</strong>。</p><p>ESP隧道模式不验证IP包头，因此<strong>ESP隧道模式并不和NAT冲突</strong>。</p><p>ESP隧道模式对原IP地址也做了保护，有助于保护<strong>端对端隧道通信中数据的安全性</strong>。</p><h4 id="因特网密钥交换协议IKE"><a href="#因特网密钥交换协议IKE" class="headerlink" title="因特网密钥交换协议IKE"></a>因特网密钥交换协议IKE</h4><p>IKE是信令协议，提供自动协商交换密钥、建立安全联盟的服务。有自保护机制，可以在不安全的网络上工作。</p><p>IKE不在网络上直接传送密钥，而通过一系列数据交换，最终计算共享密钥（即使被截获所有交换数据，也不足以计算出真正的密钥）</p><p>IKE是<strong>UDP之上的一个应用层协议</strong>，为IPSec协商建立SA，并把参数和生成的密钥交给IPSec。</p><h5 id="IKE的安全机制"><a href="#IKE的安全机制" class="headerlink" title="IKE的安全机制"></a>IKE的安全机制</h5><ul><li>完善的前向安全性PFS：一个密钥被破解不影响其他密钥的安全性（由DH算法保障）</li><li>数据验证：数据完整性和身份保护</li><li>DH交换和密钥分发</li></ul><h5 id="IKE协商过程阶段一"><a href="#IKE协商过程阶段一" class="headerlink" title="IKE协商过程阶段一"></a>IKE协商过程阶段一</h5><p>在网络上建立IKE SA，为其他协议的协商提供保护和快速协商。</p><p>通过协商创建一个通信信道，并对该信道进行认证，为进一步IKE通信提供机密性、消息完整性以及消息源认证服务。</p><p>协商过程包含三对消息：</p><ul><li>SA交换：协商确认有关安全策略</li><li>密钥交换：交换DH公共值和辅助数据，加密物在这个阶段产生</li><li>ID信息和验证数据交换：进行身份验证和对整个SA交换进行验证</li></ul><h6 id="主模式协商"><a href="#主模式协商" class="headerlink" title="主模式协商"></a>主模式协商</h6><p><a href="https://imgchr.com/i/Bpdwlt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bpdwlt.png" alt="Bpdwlt.png"></a></p><p>适用于两设备的公网IP固定、且要实现设备之间点对点的环境</p><h6 id="野蛮模式协商"><a href="#野蛮模式协商" class="headerlink" title="野蛮模式协商"></a>野蛮模式协商</h6><p><a href="https://imgchr.com/i/Bp0mx1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bp0mx1.png" alt="Bp0mx1.png"></a></p><p>对于例如ADSL拨号用户，其获得的公网IP不是固定的，且可能存在NAT设备的情况下，<strong>用野蛮模式做NAT穿越</strong>，同时用name作为id-type。</p><h6 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h6><p><a href="https://imgchr.com/i/Bp01aD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/20/Bp01aD.png" alt="Bp01aD.png"></a></p><h5 id="IKE协商过程二"><a href="#IKE协商过程二" class="headerlink" title="IKE协商过程二"></a>IKE协商过程二</h5><p>使用快速模式交换，效果为协商出IPSec单向SA，为保护IPSec数据流而创建，整个协商过程受第一阶段ISAKMP/IKE SA保护。</p><p>主要功能：</p><ul><li>协商安全参数保护数据连接</li><li>周期更新密钥信息</li></ul><h2 id="CH4：SSL"><a href="#CH4：SSL" class="headerlink" title="CH4：SSL"></a>CH4：SSL</h2><p>利用数据加密、身份验证和消息完整性验证机制，为HTTP提供安全连接</p><p>SSL位于<strong>应用层和传输层之间</strong>，能够为基于TCP等可靠连接的应用层协议提供安全性保证</p><h3 id="SSL安全机制"><a href="#SSL安全机制" class="headerlink" title="SSL安全机制"></a>SSL安全机制</h3><ul><li>传输数据的机密性：对称密钥算法</li><li>身份验证机制：基于证书利用数字签名对server和client（可选）进行身份验证</li><li>消息完整性验证：MAC算法</li></ul><h3 id="SSL分层结构"><a href="#SSL分层结构" class="headerlink" title="SSL分层结构"></a>SSL分层结构</h3><h4 id="上层协议"><a href="#上层协议" class="headerlink" title="上层协议"></a>上层协议</h4><h5 id="SSL握手协议"><a href="#SSL握手协议" class="headerlink" title="SSL握手协议"></a>SSL握手协议</h5><p>SSL的<strong>核心协议部分</strong>，协商通信过程中使用的加密套件（加密算法、密钥交换算法、MAC算法等）、在S/C之间安全交换密钥、实现S和C的身份验证。</p><p><a href="https://imgchr.com/i/BCAnBT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCAnBT.png" alt="BCAnBT.png"></a></p><h6 id="阶段1：建立安全能力"><a href="#阶段1：建立安全能力" class="headerlink" title="阶段1：建立安全能力"></a>阶段1：建立安全能力</h6><p>启动逻辑连接，建立这个连接的安全能力。</p><p><a href="https://imgchr.com/i/BCEkVO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCEkVO.png" alt="BCEkVO.png"></a></p><p>client hello消息包括：</p><ul><li>支持的协议版本</li><li>一个客户端生成的随机数，用于生成对话密钥</li><li>支持的加密算法</li><li>支持的压缩方法</li></ul><p>server hello消息对client hello中的信息进行确认：</p><ul><li>确认使用的协议版本</li><li>一个服务器生成的随机数，用于生成对话密钥</li><li>确认加密方法</li><li>服务器证书</li></ul><h6 id="阶段2：服务器鉴别与密钥交换"><a href="#阶段2：服务器鉴别与密钥交换" class="headerlink" title="阶段2：服务器鉴别与密钥交换"></a>阶段2：服务器鉴别与密钥交换</h6><p><a href="https://imgchr.com/i/BCZr8J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCZr8J.png" alt="BCZr8J.png"></a></p><ul><li>certificate：服务器发送自己的证数</li><li>server_key_exchange：可选，包含被签名的两个随机数和服务器参数</li><li>certificate_request：非匿名server可以请求客户端证书</li></ul><h6 id="阶段3：客户机鉴别与密钥交换"><a href="#阶段3：客户机鉴别与密钥交换" class="headerlink" title="阶段3：客户机鉴别与密钥交换"></a>阶段3：客户机鉴别与密钥交换</h6><p><a href="https://imgchr.com/i/BCZs29" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCZs29.png" alt="BCZs29.png"></a></p><ul><li>客户根据服务器证书判断是否可以接受参数</li><li>如果服务器请求证书就首先发送certificate消息/no_certificate警告，然后发送client_key_exchange</li><li>certificate_verify包含对之前所有握手消息的MAC的签名</li></ul><h6 id="阶段4：完成"><a href="#阶段4：完成" class="headerlink" title="阶段4：完成"></a>阶段4：完成</h6><p><a href="https://imgchr.com/i/BCZDC4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCZDC4.png" alt="BCZDC4.png"></a></p><p>建立起一个安全的连接</p><ul><li>客户发送change_cipher_spec消息（是一个独立的协议，用于告知服务端客户端已经切换到协商好的CipherSuite的状态），并把协商得到的CipherSuite拷贝到当前连接</li><li>客户用新的算法、密钥参数发送finished消息</li><li>服务器同样发送，握手完成</li></ul><h5 id="SSLpassword变化协议"><a href="#SSLpassword变化协议" class="headerlink" title="SSLpassword变化协议"></a>SSLpassword变化协议</h5><p>C和S通过该协议通知对端：随后的报文都将使用新协商的加密套件和密钥进行保护和传输。</p><h5 id="SSL警告协议"><a href="#SSL警告协议" class="headerlink" title="SSL警告协议"></a>SSL警告协议</h5><p>向对端报告告警信息，包含告警的严重级别和描写叙述。</p><ul><li>致命消息：立即终止当前连接</li><li>警告消息</li></ul><h4 id="下层协议"><a href="#下层协议" class="headerlink" title="下层协议"></a>下层协议</h4><h5 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h5><p>负责对上层数据（上层协议和应用层协议报文）进行分块、计算并加入MAC值、加密，然后传送给对端</p><ul><li>机密性：协助双方产生共有的密钥对数据加密</li><li>消息完整性：产生另一把密钥计算出消息认证码</li></ul><p>操作流程</p><ul><li>分片</li><li>压缩</li><li>计算MAC</li><li>加密</li><li>附加SSL头</li></ul><h3 id="SSL基本过程"><a href="#SSL基本过程" class="headerlink" title="SSL基本过程"></a>SSL基本过程</h3><ul><li>建立一个会话<ul><li>协商算法</li><li>分享秘密</li><li>身份认证</li></ul></li><li>传送应用数据<ul><li>确保机密性和完整性</li></ul></li></ul><h4 id="SSL连接"><a href="#SSL连接" class="headerlink" title="SSL连接"></a>SSL连接</h4><ul><li>是一个提供一种合适类型服务的传输</li><li>点对点的关系</li><li>连接是暂时的，每个连接和一个会话关联</li></ul><h4 id="SSL会话"><a href="#SSL会话" class="headerlink" title="SSL会话"></a>SSL会话</h4><ul><li>一个SSL会话是在C和S之间的一个关联。会话由Handshake Protocol创建。定义了一组<strong>可供多个连接共享的密码安全参数</strong>。</li><li>会话用以<strong>避免</strong>每一个连接提供新的安全参数所需的<strong>协商代价</strong>。</li></ul><p><a href="https://imgchr.com/i/BCkZwD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BCkZwD.png" alt="BCkZwD.png"></a></p><h4 id="SSL协议的加密和认证算法"><a href="#SSL协议的加密和认证算法" class="headerlink" title="SSL协议的加密和认证算法"></a>SSL协议的加密和认证算法</h4><p>认证算法采用X.509电子证书标准，使用RSA算法进行数字签名实现</p><h4 id="SSL安全性分析"><a href="#SSL安全性分析" class="headerlink" title="SSL安全性分析"></a>SSL安全性分析</h4><ul><li>鉴别机制：公钥技术和数字证书</li><li>加密机制：混合密码体制，使用非对称密码体制协商处会话密钥，并选择对称加密算法</li><li>完整性机制：定义了共享的、可用来生成MAC的密钥</li><li>抗重放攻击：使用序列号作为数据包负载防重放。整个SSL握手中都有一个唯一的随机数标记这个SSL握手。</li></ul><h4 id="SSL脆弱性分析"><a href="#SSL脆弱性分析" class="headerlink" title="SSL脆弱性分析"></a>SSL脆弱性分析</h4><ul><li>客户端假冒：SSL并不默认要求进行客户鉴别（防止由于安全协议导致网络性能大幅下降）</li><li>无法提供基于UDP应用的安全保护</li><li>不能对抗通信流量分析：数据包的IP头和TCP头仍然暴露，只保护应用数据</li><li>进程中主密钥泄露：主密钥将会存留在SSL进程存储空间中</li></ul><h4 id="WTLS"><a href="#WTLS" class="headerlink" title="WTLS"></a>WTLS</h4><p>保证传输层安全，在TLS基础上，根据无线环境增加了一些新特性</p><h2 id="CH5：SET"><a href="#CH5：SET" class="headerlink" title="CH5：SET"></a>CH5：SET</h2><h3 id="电子交易主要模式"><a href="#电子交易主要模式" class="headerlink" title="电子交易主要模式"></a>电子交易主要模式</h3><h4 id="支付系统无安全措施模式"><a href="#支付系统无安全措施模式" class="headerlink" title="支付系统无安全措施模式"></a>支付系统无安全措施模式</h4><p><a href="https://imgchr.com/i/BC4jJA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BC4jJA.png" alt="BC4jJA.png"></a></p><ul><li>风险由商家承担</li><li>商家完全掌握用户的信用卡信息</li><li>信用卡信息的传递无安全保障</li></ul><h4 id="通过第三方经纪人支付的模型"><a href="#通过第三方经纪人支付的模型" class="headerlink" title="通过第三方经纪人支付的模型"></a>通过第三方经纪人支付的模型</h4><p><a href="https://imgchr.com/i/BC5rYd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/21/BC5rYd.png" alt="BC5rYd.png"></a></p><ul><li>用户账户的开设不通过网络</li><li>信用卡信息不在开放网络上传送</li><li>通过电子邮件确认用户身份</li><li>商家自由度大、风险小</li><li>支付是通过双方都信任的第三方完成的</li></ul><h4 id="数字现金支付模型"><a href="#数字现金支付模型" class="headerlink" title="数字现金支付模型"></a>数字现金支付模型</h4><p><a href="https://imgchr.com/i/Biyp40" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/Biyp40.png" alt="Biyp40.png"></a></p><ul><li>银行和商家之间应该有协议和授权关系</li><li>用户、商家和数字现金的发行都需要使用数字现金软件</li><li>适用于小额交易</li><li>身份验证由数字现金完成</li><li>数字现金的发行负责用户和商家之间的实际资金转移</li><li>数字现金和普通现金一样，可以存取转让</li></ul><h4 id="简单加密支付模型"><a href="#简单加密支付模型" class="headerlink" title="简单加密支付模型"></a>简单加密支付模型</h4><p><a href="https://imgchr.com/i/BiyigU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BiyigU.png" alt="BiyigU.png"></a></p><ul><li>信用卡等关键信息需要加密</li><li>使用对称和非对称加密技术</li><li>可能要启用身份认证系统</li><li>以数字签名确认信息的真实性</li><li>需要业务服务器和服务软件的支持</li></ul><h4 id="安全电子交易SET支付模式"><a href="#安全电子交易SET支付模式" class="headerlink" title="安全电子交易SET支付模式"></a>安全电子交易SET支付模式</h4><p><a href="https://imgchr.com/i/BiyVb9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BiyVb9.png" alt="BiyVb9.png"></a></p><p>SET协议的目标</p><ul><li>信息在互联网上安全传输，不能被窃听或篡改</li><li>用户资料要妥善保护，商家只能看到订货信息，看不到用户的账户信息</li><li>持卡人和商家相互认证，确定对方身份</li><li>软件遵循相同的协议和消息格式，具有兼容性和互操作性</li></ul><h3 id="SET（Secure-Electronic-Transaction-）"><a href="#SET（Secure-Electronic-Transaction-）" class="headerlink" title="SET（Secure Electronic Transaction ）"></a>SET（Secure Electronic Transaction ）</h3><h4 id="SET的动机和范围"><a href="#SET的动机和范围" class="headerlink" title="SET的动机和范围"></a>SET的动机和范围</h4><ul><li>Internet的不安全性</li><li>SET仅仅关心支付问题</li></ul><h4 id="交易中的主体"><a href="#交易中的主体" class="headerlink" title="交易中的主体"></a>交易中的主体</h4><p><a href="https://imgchr.com/i/BiyeER" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BiyeER.png" alt="BiyeER.png"></a></p><h4 id="主体证书"><a href="#主体证书" class="headerlink" title="主体证书"></a>主体证书</h4><ul><li>协议各方持有名字和密钥对</li><li>身份使用X.509v3证书和密钥关联</li></ul><p><a href="https://imgchr.com/i/Bicim4" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/Bicim4.png" alt="Bicim4.png"></a></p><h4 id="SET安全架构需求"><a href="#SET安全架构需求" class="headerlink" title="SET安全架构需求"></a>SET安全架构需求</h4><ul><li>支付订单信息的机密性</li><li>传输数据的完整性</li><li>卡持有者身份的合法性认证</li><li>商家的身份认证</li><li>保证参与方的利益</li><li>独立于传输安全</li><li>软件架构沟通性</li></ul><h4 id="SET电子支付流程"><a href="#SET电子支付流程" class="headerlink" title="SET电子支付流程"></a>SET电子支付流程</h4><p><a href="https://imgchr.com/i/BiWrrT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BiWrrT.png" alt="BiWrrT.png"></a></p><ul><li>客户在发卡行开户</li><li>客户持有银行签发的X.509v3证书</li><li>商家持有两个同类品牌的X.509v3证书（签名+密钥交换）</li><li>客户向商家发订单</li><li>商家发送证书拷贝向客户出示自己身份</li><li>客户发送订单和支付信息给商家</li><li>商家向支付网关请求支付授权</li><li>商家确认向客户订单</li><li>商家向客户提供商品或者服务</li><li>商家向支付网关请求支付</li></ul><h4 id="SET双重数字签名"><a href="#SET双重数字签名" class="headerlink" title="SET双重数字签名"></a>SET双重数字签名</h4><ul><li><p>将两个消息连接在一起，这两个消息面向的对象不同</p><ul><li>Order Information（OI）：客户给商家</li><li>Payment Information（PI）：客户给银行</li></ul></li><li><p>按需分发消息：</p><ul><li>商家不需要卡信息</li><li>银行需要订单信息</li><li>保护客户隐私</li></ul></li><li><p>具体操作</p><ul><li>将 $PI$ 和 $OI$ 分别初次hash</li><li>连接成 $[H(PI)||H(OI)]$ 再hash</li><li>客户私钥加密产生双重签名 $DS=E_{KRC}[H(H(PI)||H(OI))]$</li></ul><p><a href="https://imgchr.com/i/Bi2tOS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/Bi2tOS.png" alt="Bi2tOS.png"></a></p><ul><li>商家收到 $OI$ 校验签名</li><li>银行收到 $PI$ 校验签名</li><li>客户连接 $OI$ 和 $PI$，证明该关联</li></ul></li></ul><p><a href="https://imgchr.com/i/BiWQ2t" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BiWQ2t.png" alt="BiWQ2t.png"></a></p><h4 id="SET消息流"><a href="#SET消息流" class="headerlink" title="SET消息流"></a>SET消息流</h4><p><a href="https://imgchr.com/i/Bihn1I" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/Bihn1I.png" alt="Bihn1I.png"></a></p><p><a href="https://imgchr.com/i/Bihm9A" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/Bihm9A.png" alt="Bihm9A.png"></a></p><h5 id="支付过程初始化InitReq-InitRes"><a href="#支付过程初始化InitReq-InitRes" class="headerlink" title="支付过程初始化InitReq/InitRes"></a>支付过程初始化InitReq/InitRes</h5><p><a href="https://imgchr.com/i/BFWO9s" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFWO9s.png" alt="BFWO9s.png"></a></p><ul><li>持卡人浏览选择商品 , 下订单，选择银行卡；</li><li>持卡人向商家发送 <strong>初始请求</strong> ，请求指定交易环境，包括<ul><li>持卡人所使用的语言 , 交易 ID</li><li>使用的是何种交易卡等</li></ul></li><li>商家接受初始请求，产生 <strong>初始应答</strong> ，对初始应答生成消息摘要，对此消息摘要进行数字签名，将商家证书，网关证书，初始应答，消息摘要的数字签名等</li></ul><h5 id="购物请求"><a href="#购物请求" class="headerlink" title="购物请求"></a>购物请求</h5><p><a href="https://imgchr.com/i/BFfkC9" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFfkC9.png" alt="BFfkC9.png"></a></p><ul><li>持卡人接受初始应答，检查商家证书和网关证书。接着用商家公钥解开消息摘要的数字签名，用 HASH 算法产生初始应答的摘要，将两者比较，如果相同则表示数据在途中未被篡改，否则丢弃。</li><li>持卡人发出购物请求（ PReq ），它包含了真正的交易行为，由两部分组成<ul><li>发往商家的定单信息 (OI) : links to order description</li><li>通过商家转发往网关的支付信息 (PI): amount, card data, IDs</li></ul></li><li>通过双重数字签名将 OI 与 PI 进行关联</li></ul><h6 id="PReq消息结构"><a href="#PReq消息结构" class="headerlink" title="PReq消息结构"></a>PReq消息结构</h6><p><a href="https://imgchr.com/i/BFhPqf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFhPqf.png" alt="BFhPqf.png"></a></p><h6 id="PReq消息校验"><a href="#PReq消息校验" class="headerlink" title="PReq消息校验"></a>PReq消息校验</h6><p><a href="https://imgchr.com/i/BF5OaT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BF5OaT.png" alt="BF5OaT.png"></a></p><h5 id="商家验证卡用户的身份和授权"><a href="#商家验证卡用户的身份和授权" class="headerlink" title="商家验证卡用户的身份和授权"></a>商家验证卡用户的身份和授权</h5><ul><li>商家接受持卡人的购物请求，<strong>认证持卡人的证书</strong>。接着<strong>验证双重签名</strong>，看数据在传输过程中是否被篡改。如数据完整，则处理定单信息，<strong>产生支付请求</strong>。</li><li>将支付请求用 HASH 算法<strong>生成摘要，并签名</strong>，网关收到后用商家公钥解密，并确认支付请求是此商家所发在且在途中未被篡改。生成对称密钥对支付请求加密，并用网关公钥加密形成数字信封。</li><li>最后将商家证书，支付请求密文，商家数字签名，数字信封和持卡人通过商家转发的： $sign[H(OP)]$ , $OI$ 摘要，$PI$ 密文，持卡人数字信封，持卡人证书等发往支付网关。</li></ul><h5 id="支付网关认证过程"><a href="#支付网关认证过程" class="headerlink" title="支付网关认证过程"></a>支付网关认证过程</h5><ul><li>支付网关分别检查确认商家发来的数据和持卡人发来的数据用 HASH 算法作用于支付请求，形成摘要，与商家发来的支付请求摘要（解开数字签名所得）相比较，如果相同则表示数据完整，否则丢弃数据</li><li>网关检查持卡人证书，然后<strong>用私钥打开持卡人数字信封</strong>，得到他的<strong>帐号和对称密钥</strong>。用此对称密钥解开 PI 密文，得到 PI ，接着<strong>验证双重签名</strong>，生成 PI 的摘要，与 OI 摘要相连接，再次生成摘要，其结果与 H(OP) (解双重签名所得) 相比较，如果相同则数据完整，如果不同则丢弃。</li><li>网关将信息发送往银行<ul><li>支付网关和银行之间通过金融专用网相连</li></ul></li></ul><h5 id="收单银行处理"><a href="#收单银行处理" class="headerlink" title="收单银行处理"></a>收单银行处理</h5><ul><li>解密AuthReq</li><li>校验商家签名</li><li>解密来自持卡人的PI</li><li>校验双重签名</li><li>从PI中抽取卡数据</li></ul><p><a href="https://imgchr.com/i/BFHbUP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFHbUP.png" alt="BFHbUP.png"></a></p><p>确保 PI 和 AuthReq 的一致性，校验持卡人和商家对于订购行为的一致性 : H(Order) PI和 AuthReq，生成 AuthRes 及其 Capture Token。</p><h5 id="支付完成"><a href="#支付完成" class="headerlink" title="支付完成"></a>支付完成</h5><p><a href="https://imgchr.com/i/BFHHEt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFHHEt.png" alt="BFHHEt.png"></a></p><ul><li>完成授权 交易的支付</li><li>通过捕获令牌完成支付</li><li>可能多次AuthResponses的令牌积累后完成</li><li>Capture Token = 金额证据</li></ul><h5 id="下单的回复"><a href="#下单的回复" class="headerlink" title="下单的回复"></a>下单的回复</h5><p><a href="https://imgchr.com/i/BFHTHI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/22/BFHTHI.png" alt="BFHTHI.png"></a></p><ul><li>完成代码CompletionCode：交易状态</li><li>结果Results：交易的授权/捕获代码</li></ul><h5 id="SET中的核心技术"><a href="#SET中的核心技术" class="headerlink" title="SET中的核心技术"></a>SET中的核心技术</h5><ul><li>公钥加密：对称加密和非对称加密4次</li><li>数字签名：进行签名5次，验证签名6次</li><li>电子信封</li><li>电子安全证书：传递证书7次，验证9次</li></ul><h4 id="SET和SSL的不同之处"><a href="#SET和SSL的不同之处" class="headerlink" title="SET和SSL的不同之处"></a>SET和SSL的不同之处</h4><ul><li>首先，SET 远远<strong>不止是一个技术方面的协议</strong>，它还说明了每一方所持有的数字证书的含义，希望得到数字证书以及响应信息的各方应有的动作，与一笔交易紧密相关的责任分担。 SET 实现非常复杂，商家和银行都需要改造系统以实现互操作，并且还需要认证中心的支持。</li><li>SET 是一个<strong>多方的报文协议</strong>，它定义了银行、商家、持卡人之间的必须的报文规范。与此同时， SSL 只是简单地在两方之间建立一条安全连接。 SSL 是面向连接的，而 SET <strong>允许各方之间的报文交换不是实时的</strong>。</li><li>另外，SET 报文能够在银行内部网或者其他网络上传输，而 SSL 之上的卡支付系统只能与 Web 浏览器捆绑在一起。</li><li>最后，SSL 相对不安全，实际上当初它并不是为支持电子商务而设计的。很多银行和电子商务解决方案提供商仍然在使用 SSL 来构建更多的安全支付系统，但是如果没有经裁剪的客户方软件的话，基于 SSL 的系统式不能达到像 SET 这种银行卡专用支付协议所能达到的安全性的。</li></ul><h2 id="CH6：PGP"><a href="#CH6：PGP" class="headerlink" title="CH6：PGP"></a>CH6：PGP</h2><h3 id="电子邮件系统"><a href="#电子邮件系统" class="headerlink" title="电子邮件系统"></a>电子邮件系统</h3><p>E-mail是Internet上最大的应用，是唯一的广泛跨平台、跨体系结构的分布式应用</p><p>不是端到端服务，是一种<strong>存储转发式</strong>的服务</p><h4 id="电子邮件系统的主要成分"><a href="#电子邮件系统的主要成分" class="headerlink" title="电子邮件系统的主要成分"></a>电子邮件系统的主要成分</h4><p>一个完整的电子邮件系统具有三个主要成分：</p><ul><li>客户端用户代理 MUA(mail user agent)</li><li>邮件传输代理 MTA(mail transfer agent)</li><li>邮件投递代理 MDA(mail delivery agent)</li></ul><h4 id="电子邮件相关协议"><a href="#电子邮件相关协议" class="headerlink" title="电子邮件相关协议"></a>电子邮件相关协议</h4><ul><li><p>SMTP</p><p>简单邮件传输协议（ simple mail transfer protocol ），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式</p></li><li><p>POP3</p><p>POP 邮局协议负责从邮件服务器中检索邮件</p></li><li><p>IMAP</p><p>互联网信息访问协议（ IMAP ）是一种优于 POP 的新协议，它可以请求邮件服务器只下载所选中的邮件而不是全部邮件，客户可以先阅读邮件信息标题和发送者名字再决定是否下载邮件</p></li><li><p>MIME</p><p>多功能 Internet 邮件扩充服务，可使邮件包含一般文本之外，还可以加上彩色图片、视频、声音或二进制格式的文件</p></li></ul><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><ul><li>匿名转发<ul><li>发件人刻意隐瞒自己的信息，或通过某些方法提供错误的发件人信息</li><li>发送者首先将邮件发送给匿名转发系统，匿名转发邮件系统再转发给真正的收件者，并将自己的地址作为发信人地址显示在邮件的信息表头中。对安全要求高的用户必须使用<strong>邮件加密和数字签名技术</strong></li></ul></li><li>电子邮件欺骗<ul><li>假冒某用户的身份给其他用户发送邮件（SMTP本身不提供任何验证）。通过<strong>身份认证</strong>避免邮件欺骗。</li></ul></li><li>邮件炸弹和垃圾邮件<ul><li><strong>安装过滤器，预先检查发件人资料</strong></li></ul></li><li>邮件病毒<ul><li>通过<strong>预杀毒</strong>防止</li></ul></li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>端到端的安全电子邮件技术<ul><li>S/MIME和PGP，<strong>一般只对信体进行加密和签名，而信头必须保证原封不动</strong>。</li></ul></li><li>要求信头在传输过程中也保密，使用传输层技术作为后盾<ul><li>使用SSL SMTP和SSL POP</li><li>使用VPN或其他IP通道技术</li></ul></li><li>邮件服务器本身安全可靠</li></ul><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGP 提供可用于电子邮件和文件存储应用的保密与鉴别服务</p><h4 id="PGP功能"><a href="#PGP功能" class="headerlink" title="PGP功能"></a>PGP功能</h4><p><a href="https://imgchr.com/i/BACdAO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BACdAO.png" alt="BACdAO.png"></a></p><h4 id="PGP数字签名和认证"><a href="#PGP数字签名和认证" class="headerlink" title="PGP数字签名和认证"></a>PGP数字签名和认证</h4><p><a href="https://imgchr.com/i/BAPPDx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAPPDx.png" alt="BAPPDx.png"></a></p><ul><li>RSA的强度保证发送方身份</li><li>SHA-1强度保证签名的有效性</li><li>DSS/SHA-1可选替代方案</li></ul><h4 id="PGP保密性操作"><a href="#PGP保密性操作" class="headerlink" title="PGP保密性操作"></a>PGP保密性操作</h4><p><a href="https://imgchr.com/i/BAPMrt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAPMrt.png" alt="BAPMrt.png"></a></p><ul><li>对称和非对称加密的结合缩短了加密时间</li><li>用公钥算法解决 $K_s$ 的单向分发问题</li><li>每个消息都有自己的一次性密钥</li></ul><h4 id="PGP保密和认证的结合"><a href="#PGP保密和认证的结合" class="headerlink" title="PGP保密和认证的结合"></a>PGP保密和认证的结合</h4><p><a href="https://imgchr.com/i/BAPTiD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAPTiD.png" alt="BAPTiD.png"></a></p><h4 id="PGP压缩"><a href="#PGP压缩" class="headerlink" title="PGP压缩"></a>PGP压缩</h4><p>PGP用ZIP算法进行压缩</p><ul><li>节省空间</li><li>签名之后压缩</li><li>加密压缩之后的报文，冗余减少，加密强度增强</li></ul><h4 id="PGP密钥环"><a href="#PGP密钥环" class="headerlink" title="PGP密钥环"></a>PGP密钥环</h4><ul><li>PGP 在每个结点提供一对数据结构<ul><li>一个是存储该结点拥有的公开 私有密钥对——私有密钥环</li><li>另一个是存储该结点知道的其他所有用户的公开密钥——公开密钥环。</li></ul></li></ul><p><a href="https://imgchr.com/i/BAismt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAismt.png" alt="BAismt.png"></a></p><h4 id="PGP公钥的分发"><a href="#PGP公钥的分发" class="headerlink" title="PGP公钥的分发"></a>PGP公钥的分发</h4><p>无政府状态，由用户决定信任与否。</p><ul><li>获取某人的公钥并信任它</li><li>将其加入自己的PGP系统</li><li>公钥服务器</li></ul><h4 id="PGP信任网"><a href="#PGP信任网" class="headerlink" title="PGP信任网"></a>PGP信任网</h4><p>证书是可选的，彼此之间可以颁发证书（信任网）。</p><ul><li>通过自己的数字签名确认</li><li>通过自己完全信任的人的数字签名确认</li><li>通过自己有限信任的多个人的数字签名确认</li></ul><h2 id="CH7：Kerberos"><a href="#CH7：Kerberos" class="headerlink" title="CH7：Kerberos"></a>CH7：Kerberos</h2><h3 id="密钥管理问题"><a href="#密钥管理问题" class="headerlink" title="密钥管理问题"></a>密钥管理问题</h3><p>所有的密码系统都存在：如何安全 可靠地分配密钥</p><p>安全问题经常是密钥分配系统被破而不是密码算法被破</p><p>理想的情况是：密钥分配协议应得到形式化验证</p><h3 id="Kerberos认证服务协议"><a href="#Kerberos认证服务协议" class="headerlink" title="Kerberos认证服务协议"></a>Kerberos认证服务协议</h3><ul><li>提供一个在客户端跟服务器端之间或者服务器与服务器之间的身份验证机制 （并且是相互的身份验证机制）</li><li>解决的问题：<ul><li>在一个公开的分布式环境中，工作站上的用户希望访问分布在网络中的服务器上的服务</li><li>服务器希望能够限制授权用户的访问，并能对服务请求进行鉴别。</li></ul></li></ul><h4 id="Kerberos加密体制"><a href="#Kerberos加密体制" class="headerlink" title="Kerberos加密体制"></a>Kerberos加密体制</h4><ul><li>Kerberos 不是为每一个服务器构造一个身份认证协议，而是提供一个<strong>中心认证服务器</strong>，提供用户到服务器和服务器到用户的认证服务。</li><li>Kerberos 采用传统加密算法（无公钥体制）</li></ul><h4 id="Kerberos主要功能"><a href="#Kerberos主要功能" class="headerlink" title="Kerberos主要功能"></a>Kerberos主要功能</h4><p>在一个<strong>分布式</strong>的 client/server 体系机构中采用一个或多个 Kerberos 服务器提供一个认证服务。</p><p>总体方案是提供一个可信第三方的认证服务。</p><ul><li>用 tickets 验证</li><li>避免本地保存密码和在互联网上传输密码</li><li>包含一个可信的第三方</li><li>使用对称加密</li><li>客户端与服务器（非 KDC ）之间能够互相验证。</li></ul><p>满足的要求：</p><ul><li>安全</li><li>可靠</li><li>透明</li><li>可伸缩</li></ul><h4 id="Kerberos-Version-4"><a href="#Kerberos-Version-4" class="headerlink" title="Kerberos Version 4"></a>Kerberos Version 4</h4><ul><li>引入一个信任的<strong>第三方认证服务</strong>，采用一个基于Needham &amp; Schroeder 协议。</li><li>采用 DES ，精心设计协议，提供认证服务。</li></ul><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li>Principal 安全个体<br>被认证的个体，有一个名字(name)和口令(password)</li><li>KDC(Key distribution center)<br>是一个网络服务，提供 ticket 和临时的会话密钥</li><li>Ticket<br>一个记录，客户可以用它来向服务器证明自己的身份，其中包括客户的标识、会话密钥、时间戳，以及其他一些信息。 Ticket中的大多数信息都被加密，密钥为服务器的密钥</li><li>Authenticator<br>一个记录，其中包含一些最近产生的信息，产生这些信息需要用到客户和服务器之间共享的会话密钥</li><li>Credentials<br>一个 ticket 加上一个秘密的会话密钥</li><li>Authentication Server (AS)<ul><li>通过 long term key 认证客户</li><li>AS 给予客户 ticket granting ticket 和 short term key</li><li><strong>认证服务</strong></li></ul></li><li>Ticket Granting Server (TGS)<ul><li>通过 short term key 和 ticket granting ticket 认证客户 .</li><li>TGS 发放 tickets 给客户以访问其他的服务器</li><li><strong>授权和访问控制服务</strong></li></ul></li></ul><p>动机：</p><ul><li>认证和授权的逻辑分离</li><li>TGT（10 hours）和ST（5 minutes）的生命周期不同<ul><li>方便客户，降低密钥暴露时间</li></ul></li></ul><h5 id="认证服务交换：获得票据许可票据"><a href="#认证服务交换：获得票据许可票据" class="headerlink" title="认证服务交换：获得票据许可票据"></a>认证服务交换：获得票据许可票据</h5><p><a href="https://imgchr.com/i/BAGyB6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAGyB6.png" alt="BAGyB6.png"></a></p><h5 id="票据许可服务交换：获得服务许可票据"><a href="#票据许可服务交换：获得服务许可票据" class="headerlink" title="票据许可服务交换：获得服务许可票据"></a>票据许可服务交换：获得服务许可票据</h5><p><a href="https://imgchr.com/i/BAJnDx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAJnDx.png" alt="BAJnDx.png"></a></p><p><a href="https://imgchr.com/i/BAJ5iF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAJ5iF.png" alt="BAJ5iF.png"></a></p><h5 id="客户-服务器认证交换：获得服务"><a href="#客户-服务器认证交换：获得服务" class="headerlink" title="客户/服务器认证交换：获得服务"></a>客户/服务器认证交换：获得服务</h5><p><a href="https://imgchr.com/i/BAYEo8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAYEo8.png" alt="BAYEo8.png"></a></p><h5 id="Kerberos领域和多个域服务"><a href="#Kerberos领域和多个域服务" class="headerlink" title="Kerberos领域和多个域服务"></a>Kerberos领域和多个域服务</h5><p>一个完整的Kerberos环境（域）包括一个Kerberos服务器，一组工作站和一组应用服务器</p><ul><li>Kerberos服务器必须在其数据库中有所有用户的UID和口令散列表，<strong>所有用户均在Kerberos服务器上注册</strong></li><li>Kerberos服务器必须与灭一个服务器之间共享一个保密密钥。<strong>所有服务器均在Kerberos服务器上注册</strong></li></ul><p>不同域的鉴别机制：每个辖区的Kerberos服务器与其他辖区内的Kerberos服务器之间共享一个保密密钥，且<strong>相互注册</strong></p><p>跨域认证：</p><ul><li>获得本地TGS的访问权</li><li>请求远程TGS的TGT</li><li>向远程TGS申领SGT</li></ul><p><a href="https://imgchr.com/i/BAYXXn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BAYXXn.png" alt="BAYXXn.png"></a></p><h4 id="Kerberos-Version-5"><a href="#Kerberos-Version-5" class="headerlink" title="Kerberos Version 5"></a>Kerberos Version 5</h4><h5 id="基于v4的改进"><a href="#基于v4的改进" class="headerlink" title="基于v4的改进"></a>基于v4的改进</h5><ul><li>通用性：<ul><li>加密算法 v4 仅仅 DES, v5 扩展</li><li>网络协议地址 : v4 IP, v5 OSI</li><li>票据生命周期 : v4 最大值 1280 minutes, v5 不限制</li><li>认证转发 : v5 允许服务器在事务中代表一个客户端访问另一台服务器</li></ul></li><li>双重加密<ul><li>v4中的票据被重复加密</li></ul></li><li>消息重放<ul><li>AS-&gt;C 和 TGS-&gt;C消息在票据生命周期中可被重放，v5采用新鲜数避免</li><li>采用同一票据的多个CS连接使用相同的会话密钥，可被重放。v5采用subkey机制</li></ul></li></ul><h4 id="Kerberos优点"><a href="#Kerberos优点" class="headerlink" title="Kerberos优点"></a>Kerberos优点</h4><ul><li>密码不易被窃听</li><li>密码不在网上传输</li><li>密码猜测更困难</li><li>Single Sign on<ul><li>更便捷 一次使用口令登录</li><li>不用记忆多个口令</li></ul></li><li>票据被盗之后难以使用，因为需要配合认证头来使用</li></ul><h2 id="CH8：ban"><a href="#CH8：ban" class="headerlink" title="CH8：ban"></a>CH8：ban</h2><h3 id="安全协议的形式化分析"><a href="#安全协议的形式化分析" class="headerlink" title="安全协议的形式化分析"></a>安全协议的形式化分析</h3><ul><li>目前的技术主要用于对密钥正确的认证 </li><li>安全协议的形式化分析有助于减轻协议设计者的部分工作量： <ul><li>界定安全协议的边界,即协议系统与其运行环境的界面。 </li><li>更准确地描述安全协议的行为。 </li><li>更准确地定义安全协议的特性。 </li><li>证明安全协议满足其说明，以及证明安全协议在什么条件下不能满足其说明。</li></ul></li></ul><ul><li>基于推理结构性方法</li><li>基于攻击结构性方法</li><li>基于证明结构性方法</li></ul><h3 id="逻辑类分析方法"><a href="#逻辑类分析方法" class="headerlink" title="逻辑类分析方法"></a>逻辑类分析方法</h3><ul><li>逻辑：运用形式化方法研究和判定推理形式有效性</li><li><p>形式化方法 ：将一套特制的人工符号应用于演绎体系以使其严格化 、精确化的研究方法 。包含符号化和系统化 。</p><ul><li>符号化：将命题 (p,q,r) 和常项（如命题连接词）用符号标识</li><li>系统化：在符号化的基础上将一定范围内所有有效的推理形式形成一个形式系统</li></ul></li><li><p>狭义形式系统：形式语言和演绎装置。 </p></li><li>形式语言：系统的初始符号(字母表)，形成规 则(如何使用符号组成公式)。 </li><li>演绎装置：包括定义、公理和规则。 </li><li>广义形式系统：增加<strong>语义</strong>部分。即对初始符号 、公式和规则的解释。解释可把形式系统与一 定模型(代表客观实际)连接起来，从而赋予初始符号和公式一定的实际意义。</li></ul><h3 id="逻辑-推理结构性方法"><a href="#逻辑-推理结构性方法" class="headerlink" title="逻辑-推理结构性方法"></a>逻辑-推理结构性方法</h3><p>运用逻辑系统从用户接收和发送的消息出发，通过一系列的推理公理退证协议是否满足其安全说明。</p><ul><li>典型：BAN逻辑，Kailer逻辑，RV逻辑</li></ul><p>特点：</p><ul><li>简洁直观，易于使用</li><li>理想化方法，分析协议之前必须对协议进行形式化处理（用逻辑语言描述）</li><li>使用假设和推理规则<ul><li>假设不正确——不能得到正确的信念</li><li>公里和推理规则是否合理和完备也影响性能</li></ul></li></ul><h3 id="BAN逻辑系统"><a href="#BAN逻辑系统" class="headerlink" title="BAN逻辑系统"></a>BAN逻辑系统</h3><ul><li>定义：基于主体知识和信念推理的模态逻辑</li><li>过程：通过推导<strong>主体是否能够从接收到消息中获得信念</strong>来判断协议是否能够达到认证目标</li></ul><p><a href="https://imgchr.com/i/BESLTS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BESLTS.png" alt="BESLTS.png"></a></p><p><a href="https://imgchr.com/i/BESXFg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BESXFg.png" alt="BESXFg.png"></a></p><h4 id="推理规则——消息意义规则"><a href="#推理规则——消息意义规则" class="headerlink" title="推理规则——消息意义规则"></a>推理规则——消息意义规则</h4><p>从加密消息所使用密钥以及消息中包含的密码来推断消息发送者的身份</p><p><a href="https://imgchr.com/i/BE9a8J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BE9a8J.png" alt="BE9a8J.png"></a></p><h4 id="推理规则——随机数验证规则"><a href="#推理规则——随机数验证规则" class="headerlink" title="推理规则——随机数验证规则"></a>推理规则——随机数验证规则</h4><p><a href="https://imgchr.com/i/BE9wvR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BE9wvR.png" alt="BE9wvR.png"></a></p><h4 id="推理规则——仲裁规则"><a href="#推理规则——仲裁规则" class="headerlink" title="推理规则——仲裁规则"></a>推理规则——仲裁规则</h4><p>拓展主体的推知能力，使主体可以在基于其他主体已有的信仰之上推知新的信仰</p><p><a href="https://imgchr.com/i/BEPbcj" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEPbcj.png" alt="BEPbcj.png"></a></p><h4 id="推理规则——信仰规则"><a href="#推理规则——信仰规则" class="headerlink" title="推理规则——信仰规则"></a>推理规则——信仰规则</h4><p>反映信念在消息的级联和分割的不同操作中一致性以及信仰在此类操作中的传递性</p><p><a href="https://imgchr.com/i/BEikuR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEikuR.png" alt="BEikuR.png"></a></p><h4 id="推理规则——接收规则"><a href="#推理规则——接收规则" class="headerlink" title="推理规则——接收规则"></a>推理规则——接收规则</h4><p>定义了主体在协议运行中获取消息</p><p><a href="https://imgchr.com/i/BEim4O" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEim4O.png" alt="BEim4O.png"></a></p><h4 id="推理规则——新鲜规则"><a href="#推理规则——新鲜规则" class="headerlink" title="推理规则——新鲜规则"></a>推理规则——新鲜规则</h4><p><a href="https://imgchr.com/i/BEFRTP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEFRTP.png" alt="BEFRTP.png"></a></p><h4 id="推理规则——传递规则"><a href="#推理规则——传递规则" class="headerlink" title="推理规则——传递规则"></a>推理规则——传递规则</h4><p><a href="https://imgchr.com/i/BEFfFf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEFfFf.png" alt="BEFfFf.png"></a></p><h4 id="BAN逻辑的假设"><a href="#BAN逻辑的假设" class="headerlink" title="BAN逻辑的假设"></a>BAN逻辑的假设</h4><h5 id="时间假设"><a href="#时间假设" class="headerlink" title="时间假设"></a>时间假设</h5><ul><li>协议分析中区分current-time和past-time。<ul><li>current-time：起始于本次协议运行的开始阶段</li><li>past-time：current-time之前的时间</li></ul></li></ul><p>如果某一观点在协议开始时是成立的，那么在整个current-time中也是成立的</p><p>但在past-time中成立的观点在current-time中却并不一定成立</p><h5 id="密钥-主体-假设"><a href="#密钥-主体-假设" class="headerlink" title="密钥-主体-假设"></a>密钥-主体-假设</h5><ul><li>密钥不能从密文中推导</li><li>不拥有正确密钥不能解密</li><li>主体能够知道是否正确使用了解密密钥（错误解密无意义）</li></ul><h5 id="主体-假设"><a href="#主体-假设" class="headerlink" title="主体-假设"></a>主体-假设</h5><p>假设参与协议运行的主体都是诚实的</p><h5 id="自身消息可识别-假设"><a href="#自身消息可识别-假设" class="headerlink" title="自身消息可识别-假设"></a>自身消息可识别-假设</h5><p>假设接收方能分辨接收到的消息是否为自己发送过的消息</p><h5 id="应用BAN逻辑"><a href="#应用BAN逻辑" class="headerlink" title="应用BAN逻辑"></a>应用BAN逻辑</h5><ul><li>对协议进行理想化预处理（<strong>初始化</strong>）。</li><li>给出协议<strong>初始状态</strong>及其所基于的假设。 </li><li><strong>形式化</strong>说明协议将达成的<strong>安全目标</strong>。</li><li>运用公理和推理规则以及协议会话事实和 假设，从协议的开始进行<strong>推证</strong>直至验证协议 是否满足其最终运行目标。</li></ul><h5 id="BAN逻辑应用实例——NS协议漏洞"><a href="#BAN逻辑应用实例——NS协议漏洞" class="headerlink" title="BAN逻辑应用实例——NS协议漏洞"></a>BAN逻辑应用实例——NS协议漏洞</h5><p><a href="https://imgchr.com/i/BEVY9K" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVY9K.png" alt="BEVY9K.png"></a></p><p><a href="https://imgchr.com/i/BEV8tx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEV8tx.png" alt="BEV8tx.png"></a></p><p><a href="https://imgchr.com/i/BEV3A1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEV3A1.png" alt="BEV3A1.png"></a></p><p><a href="https://imgchr.com/i/BEVGh6" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVGh6.png" alt="BEVGh6.png"></a></p><p><a href="https://imgchr.com/i/BEVl7R" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVl7R.png" alt="BEVl7R.png"></a></p><p><a href="https://imgchr.com/i/BEVt1O" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVt1O.png" alt="BEVt1O.png"></a></p><p><a href="https://imgchr.com/i/BEVUje" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVUje.png" alt="BEVUje.png"></a></p><p><a href="https://imgchr.com/i/BEVNcD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVNcD.png" alt="BEVNcD.png"></a></p><p><a href="https://imgchr.com/i/BEVdnH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/23/BEVdnH.png" alt="BEVdnH.png"></a></p><h5 id="BAN逻辑的局限性"><a href="#BAN逻辑的局限性" class="headerlink" title="BAN逻辑的局限性"></a>BAN逻辑的局限性</h5><ul><li>省略掉对于推知主体信仰无用部分，如明文。 </li><li>协议的理想化过于依赖于分享者的直觉，使得原始协议与理想化协议间存在语义鸿沟。</li><li>协议的理想化是将协议过程语言中对协议主体行为的描述解释为用逻辑语言描述的主体的知识和信仰 ，并以此来表示协议说明的语义。现有的逻辑形式 化分析系统很难解决此问题。 </li><li>BAN证明没有问题，并不能保证该协议没有问题。</li></ul><p>BAN逻辑缺陷：</p><ul><li>不合理的假设<ul><li>BAN逻辑钟，初始状态的假设难以确定，从而无法确 认和自动验证假设的正确性和有效性</li><li>BAN逻辑系统认为参与协议运行的主体都是诚实的</li></ul></li><li>不能检查协议并发运行带来的攻击<ul><li>BAN缺少一个良好定义的语义</li></ul></li></ul><h2 id="CH9：csp"><a href="#CH9：csp" class="headerlink" title="CH9：csp"></a>CH9：csp</h2><h3 id="攻击结构型方法"><a href="#攻击结构型方法" class="headerlink" title="攻击结构型方法"></a>攻击结构型方法</h3><p>模型检测方法:给定模型M和性质P，检查M中P是否成立</p><ul><li>主体数目的有限性：通常分析有限主体实例，只说明在某个数目下未发现错误</li><li>无法解决状态空间爆炸问题：当协议只有三五条、主体数目只有四五个时，效率较高，超过时会出现内存和时间问题。</li><li>无法解释安全协议的内部机理</li></ul><h4 id="通用的形式化验证方法——通信顺序进程CSP"><a href="#通用的形式化验证方法——通信顺序进程CSP" class="headerlink" title="通用的形式化验证方法——通信顺序进程CSP"></a>通用的形式化验证方法——通信顺序进程CSP</h4><ul><li>专为描述并发系统消息交互而设计的抽象语言</li><li>将协议的安全问题描述为CSP进行是否满足其CSP规约的问题，并使用FDR对协议的性质进行分析和验证</li></ul><h5 id="CSP基本术语"><a href="#CSP基本术语" class="headerlink" title="CSP基本术语"></a>CSP基本术语</h5><ul><li>事件：协议系统通过其执行的一系列事件加以描述。c.i.j.m包括一个信道c、一个消息源i、一个目的地j和一个消息m</li><li>信道：不同事件类型看成不同信道，并规定它所传递的数据类型</li><li>进程：CSP通过用某一进程可能涉及的事件来描写该进程，从而提供了一种描述进程可达状态的方法<ul><li>执行状态中的一个动作（事件）+动作结束后的状态</li></ul></li></ul><p>常见的CSP进程：</p><p><a href="https://imgchr.com/i/B1wljJ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1wljJ.png" alt="B1wljJ.png"></a></p><p><a href="https://imgchr.com/i/B1spQO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1spQO.md.png" alt="B1spQO.md.png"></a></p><p><a href="https://imgchr.com/i/B1sieH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1sieH.png" alt="B1sieH.png"></a></p><p><a href="https://imgchr.com/i/B1s9yD" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1s9yD.png" alt="B1s9yD.png"></a></p><p><a href="https://imgchr.com/i/B1sSSK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1sSSK.png" alt="B1sSSK.png"></a></p><p><a href="https://imgchr.com/i/B1sCOe" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1sCOe.png" alt="B1sCOe.png"></a></p><h5 id="协议目标的CSP描述"><a href="#协议目标的CSP描述" class="headerlink" title="协议目标的CSP描述"></a>协议目标的CSP描述</h5><ul><li>保密性</li></ul><p><a href="https://imgchr.com/i/B1s1Ts" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1s1Ts.png" alt="B1s1Ts.png"></a></p><ul><li>认证性</li></ul><p><a href="https://imgchr.com/i/B1s8kn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/10/28/B1s8kn.png" alt="B1s8kn.png"></a></p><ul><li>完成安全协议的 CSP 建模及安全目标描述 以后，可以采用 基于模型检测的分析方法 对 安全协议进行分析。</li><li>基本原理：主要采用自动化分析工具 FDR（Failures Divergences Refinement, 故障发散提炼器） 工具 完成。</li><li>FDR 接受协议规范和协议实现的两个 CSP 作为输入：<ul><li>规范：一个抽象 的 系统 具有 一 定的 性 质 。</li><li>实现：较具体的系统，常希望其具备某种性 质 。</li></ul></li><li>FDR 检查协议的实现是否精炼了规范，即实现的每一个迹是否为协议规范的一个迹</li></ul>]]></content>
      
      
      <categories>
          
          <category> Internet安全协议与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet安全协议与分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV入门——环境配置和detectron2安装、基础图象操作预处理</title>
      <link href="2020/08/23/CV%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8Cdetectron2%E5%AE%89%E8%A3%85%E3%80%81%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%B1%A1%E6%93%8D%E4%BD%9C%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>2020/08/23/CV%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8Cdetectron2%E5%AE%89%E8%A3%85%E3%80%81%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%B1%A1%E6%93%8D%E4%BD%9C%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>CV入门——在Windows 10上安装detectron2，并介绍了一些基本图像操作</p><a id="more"></a><h1 id="环境配置和detectron2安装"><a href="#环境配置和detectron2安装" class="headerlink" title="环境配置和detectron2安装"></a>环境配置和detectron2安装</h1><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><ul><li>Python 3.7.3</li><li><a href="https://download.pytorch.org/whl/torch_stable.html" target="_blank" rel="noopener">Pytorch-1.6.0-cu101</a></li><li><a href="https://download.pytorch.org/whl/torch_stable.html" target="_blank" rel="noopener">torchvision-0.7.0</a></li><li><a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">CUDA 11.0.3</a></li><li><a href="https://github.com/philferriere/cocoapi" target="_blank" rel="noopener">pycocotools</a></li><li><a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">Visual Studio 2019-16.7.2</a></li></ul><h3 id="安装-torch与torchvision"><a href="#安装-torch与torchvision" class="headerlink" title="安装 torch与torchvision"></a>安装 torch与torchvision</h3><p>可以直接到<a href="https://download.pytorch.org/whl/torch_stable.html" target="_blank" rel="noopener">Pytorch的whl仓库</a>下载torch和torchvison的whl文件，然后执行以下命令进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install filename.whl</span><br></pre></td></tr></table></figure><p>需要注意的是，下载torch和torchvison的whl文件时应<strong>有相同的cu并且与Python版本一致</strong>。</p><p>测试是否安装完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">"import torch; print(torch.__version__)"</span></span><br></pre></td></tr></table></figure><p>也可以直接在<a href="https://pytorch.org/" target="_blank" rel="noopener">pytorch官网</a>，选择操作系统、安装工具、语言以及CUDA版本，然后直接执行官网给出的命令。</p><h3 id="安装-fvcore和pycocotools"><a href="#安装-fvcore和pycocotools" class="headerlink" title="安装 fvcore和pycocotools"></a>安装 fvcore和pycocotools</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/facebookresearch/fvcore</span><br><span class="line"></span><br><span class="line">pip install git+https://github.com/cocodataset/cocoapi.git<span class="comment">#subdirectory=PythonAPI</span></span><br></pre></td></tr></table></figure><h3 id="安装-Visual-Studio"><a href="#安装-Visual-Studio" class="headerlink" title="安装 Visual Studio"></a>安装 Visual Studio</h3><p>在微软的<a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">官网</a>上下载Visual Studio Installer，安装时添加<strong>工作负载-&gt;使用C++的桌面开发</strong>即可。</p><p>将以下路径添加到系统变量中（根据安装位置自行修改）。</p><blockquote><p>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\bin\Hostx86\x86</p></blockquote><p>测试cl是否正常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; cl</span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.27.29111 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure></p><h3 id="安装-detectron2"><a href="#安装-detectron2" class="headerlink" title="安装 detectron2"></a>安装 detectron2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/facebookresearch/detectron2.git</span><br></pre></td></tr></table></figure><p>在setup.py中找到以下内容将其注释掉即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># "pycocotools&gt;=2.0.1",</span></span><br></pre></td></tr></table></figure></p><p>随便下载一张图片，进行实例测试，（模型下载如果没有梯子会很慢）<br><img src="https://s1.ax1x.com/2020/08/24/dBBnyQ.jpg" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python demo/demo.py --config-file configs/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml   --input input1.jpg   --output ./out.jpg --opts MODEL.WEIGHTS detectron2://COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl</span><br></pre></td></tr></table></figure><p>输入的out.jpg如下所示，bingo！<br><img src="https://s1.ax1x.com/2020/08/24/dBB3F0.jpg" alt=""></p><p>如果代码报错，那么大概率是torch和torchvision的版本问题，应该重新检查是否<strong>版本对应</strong>。</p><h3 id="ninja错误"><a href="#ninja错误" class="headerlink" title="ninja错误"></a>ninja错误</h3><p>如果出现以下错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.CalledProcessError: Command <span class="string">'['</span>ninja<span class="string">', '</span>-v<span class="string">']'</span> returned non-zero <span class="built_in">exit</span> status 1.</span><br></pre></td></tr></table></figure></p><p>在以下路径中做如下修改即可。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路径：&#123;Your Path&#125;\Lib\site-packages\torch\utils\cpp_extension.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># command = ['ninja', '-v'] # 修改前</span></span><br><span class="line">command = [<span class="string">'ninja'</span>, <span class="string">'--v'</span>]  <span class="comment"># 修改后</span></span><br></pre></td></tr></table></figure></p><h3 id="cl编码错误"><a href="#cl编码错误" class="headerlink" title="cl编码错误"></a>cl编码错误</h3><p>如果出现以下错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error checking compiler version <span class="keyword">for</span> cl</span><br></pre></td></tr></table></figure></p><p>在以下路径中做如下修改即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路径：&#123;Your Path&#125;\Lib\site-packages\torch\utils\cpp_extension.py</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> sys.platform.startswith(<span class="string">'linux'</span>):</span><br><span class="line">            minimum_required_version = MINIMUM_GCC_VERSION</span><br><span class="line">            version = subprocess.check_output([compiler, <span class="string">'-dumpfullversion'</span>, <span class="string">'-dumpversion'</span>])</span><br><span class="line">            version = version.decode().strip().split(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minimum_required_version = MINIMUM_MSVC_VERSION</span><br><span class="line">            compiler_info = subprocess.check_output(compiler, stderr=subprocess.STDOUT)</span><br><span class="line">            <span class="comment"># match = re.search(r'(\d+)\.(\d+)\.(\d+)', compiler_info.decode().strip())     # 修改前</span></span><br><span class="line">            match = re.search(<span class="string">r'(\d+)\.(\d+)\.(\d+)'</span>, compiler_info.decode(<span class="string">' gbk'</span>).strip()) <span class="comment"># 修改后</span></span><br><span class="line">            version = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="keyword">if</span> match <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> match.groups() </span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        _, error, _ = sys.exc_info()</span><br><span class="line">        warnings.warn(<span class="string">'Error checking compiler version for &#123;&#125;: &#123;&#125;'</span>.format(compiler, error))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="cl连接错误"><a href="#cl连接错误" class="headerlink" title="cl连接错误"></a>cl连接错误</h3><p>如果出现以下错误，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detectron2 failed with <span class="built_in">exit</span> status 1181</span><br></pre></td></tr></table></figure><p>那么应该是cl中link.exe无法正确生成obj文件所致，本机解决方法暂时未知；但可以通过打包别人已安装好的detectron2中的以下路径覆盖到本地解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Your Path&#125;\detectron2\build\temp.win-amd64-3.7\Release\&#123;Your Path&#125;\detectron2\detectron2\layers\csrc</span><br></pre></td></tr></table></figure><h1 id="基础图像操作与处理"><a href="#基础图像操作与处理" class="headerlink" title="基础图像操作与处理"></a>基础图像操作与处理</h1><p>本章学习操作和处理图像的基础知识，将通过大量示例介绍处理图像所需的Python工具包，并学习用于读取图像、图像转换和缩放、计算导数、画图和保存结果等的基本工具。本章的内容将贯穿本书的剩余章节。</p><h2 id="PIL：-Python图像处理类库"><a href="#PIL：-Python图像处理类库" class="headerlink" title="PIL： Python图像处理类库"></a>PIL： Python图像处理类库</h2><p>PIL（Python Imaging Library）提供了通用的图像处理功能，比如图像缩放、裁剪、旋转、颜色转换等。</p><h3 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h3><p>使用PIL中最重要的Image模块，读取图像并返回PIL图像对象。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">pil_im = Image.open(<span class="string">'empire.jpg'</span>)   <span class="comment"># 读取图像</span></span><br><span class="line">pil_im_conv = pil_im.convert(<span class="string">'L'</span>)   <span class="comment"># 转换为灰度图像</span></span><br></pre></td></tr></table></figure><h3 id="创建缩略图"><a href="#创建缩略图" class="headerlink" title="创建缩略图"></a>创建缩略图</h3><p>使用PIL图像对象的thumbnail()方法，该方法接收一个元组参数，指定缩略图的大小。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pil_im.thumbnail((<span class="number">128</span>,<span class="number">128</span>))</span><br></pre></td></tr></table></figure><h3 id="复制和粘贴图像区域"><a href="#复制和粘贴图像区域" class="headerlink" title="复制和粘贴图像区域"></a>复制和粘贴图像区域</h3><p>用crop()方法可以从一幅图像中裁剪指定区域，该区域由元组参数指定，格式为（左，上，右，下）。使用paste()方法可以将图像粘贴。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box = (<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">400</span>)</span><br><span class="line">region = pil_im.crop(box)</span><br><span class="line">region = region.transpose(Image.ROTATE_180)</span><br><span class="line">pil_im.paste(region,box)</span><br></pre></td></tr></table></figure><p>效果如下所示（害怕）：<br><img src="https://s1.ax1x.com/2020/08/24/dsNaEq.png" alt="dsNaEq.png"><br><img src="https://s1.ax1x.com/2020/08/24/dsN4PK.png" alt="dsN4PK.png"></p><h3 id="调整尺寸和旋转"><a href="#调整尺寸和旋转" class="headerlink" title="调整尺寸和旋转"></a>调整尺寸和旋转</h3><p>调整尺寸可以直接使用resize()方法，参数同样是元组。<br>旋转图像可以使用逆时针方式表示旋转角度，调用rotate()方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out1 = pil_im.resize((<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">out2 = pil_im.rotate(<span class="number">45</span>)</span><br></pre></td></tr></table></figure><h3 id="转换图像格式"><a href="#转换图像格式" class="headerlink" title="转换图像格式"></a>转换图像格式</h3><p>通过Image的save方法，可以直接将图像保存为其他格式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> filelist:</span><br><span class="line">    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">".png"</span></span><br><span class="line"><span class="keyword">if</span> infile != outfile:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        Image.open(infile).save(outfile)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"cannot convert"</span>, infile</span><br></pre></td></tr></table></figure><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>处理数学运算、绘制图表，在图像上绘制点、直线和曲线时，尝试用Matplotlib库。</p><h3 id="绘制图像、点和线"><a href="#绘制图像、点和线" class="headerlink" title="绘制图像、点和线"></a>绘制图像、点和线</h3><p>在CV中，常用来绘制<strong>兴趣点、对应点以及检测出的物体</strong>。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 读取图像到数组中</span></span><br><span class="line">im = array(Image.open(<span class="string">'1.jpg'</span>))</span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">imshow(im)</span><br><span class="line"><span class="comment"># 一些点的横纵坐标</span></span><br><span class="line">x = [<span class="number">100</span>,<span class="number">400</span>,<span class="number">200</span>,<span class="number">200</span>]</span><br><span class="line">y = [<span class="number">200</span>,<span class="number">500</span>,<span class="number">200</span>,<span class="number">500</span>]</span><br><span class="line"><span class="comment"># 使用红色星状标记绘制点</span></span><br><span class="line">plot(x,y,<span class="string">'r*'</span>)</span><br><span class="line"><span class="comment"># 绘制连接前两个点的线</span></span><br><span class="line">plot(x[:<span class="number">2</span>],y[:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 添加标题，显示绘制的图像</span></span><br><span class="line">title(<span class="string">'Plotting: "1.jpg"'</span>)</span><br><span class="line"><span class="comment"># 不显示坐标轴</span></span><br><span class="line"><span class="comment"># axis('off') </span></span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>该例子的绘制结果如下 所示。show() 命令首先打开图形用户界面（GUI），然后新建一个图像窗口。该图形用户界面会循环阻断脚本，然后暂停，直到最后一个图像窗口关闭。在每个脚本里，只能调用一次show() 命令，而且通常是在脚本的结尾调用。</p><p><img src="https://s1.ax1x.com/2020/08/24/dsJRVP.png" alt=""></p><p>PyLab库绘图时的基本颜色格式命令如下</p><div class="table-container"><table><thead><tr><th>命令格式</th><th>颜色</th></tr></thead><tbody><tr><td>‘b’</td><td>蓝色</td></tr><tr><td>‘g’</td><td>绿色</td></tr><tr><td>‘r’</td><td>红色</td></tr><tr><td>‘c’</td><td>青色</td></tr><tr><td>‘m’</td><td>品红</td></tr><tr><td>‘y’</td><td>黄色</td></tr><tr><td>‘k’</td><td>黑色</td></tr><tr><td>‘w’</td><td>白色</td></tr></tbody></table></div><p>PyLab库绘图时的基本线型格式命令如下</p><div class="table-container"><table><thead><tr><th>命令格式</th><th>颜色</th></tr></thead><tbody><tr><td>‘-‘</td><td>实线</td></tr><tr><td>‘—‘</td><td>虚线</td></tr><tr><td>‘:’</td><td>点线</td></tr></tbody></table></div><p>PyLab库绘图时的基本绘制标记格式命令如下</p><div class="table-container"><table><thead><tr><th>命令格式</th><th>颜色</th></tr></thead><tbody><tr><td>‘.’</td><td>点</td></tr><tr><td>‘o’</td><td>圆圈</td></tr><tr><td>‘s’</td><td>正方形</td></tr><tr><td>‘*’</td><td>星形</td></tr><tr><td>‘+’</td><td>加号</td></tr><tr><td>‘x’</td><td>叉号</td></tr></tbody></table></div><h3 id="图像轮廓和直方图"><a href="#图像轮廓和直方图" class="headerlink" title="图像轮廓和直方图"></a>图像轮廓和直方图</h3><p>绘制图像的轮廓（或者其他二维函数的等轮廓线）在工作中非常有用。因为绘制轮廓需要对每个坐标[x, y] 的像素值施加同一个阈值，所以首先需要将图像灰度化。使用contour()即可绘制轮廓。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 读取灰度图像到数组中</span></span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line"><span class="comment"># 新建一个图像</span></span><br><span class="line">figure()</span><br><span class="line"><span class="comment"># 不使用颜色信息</span></span><br><span class="line">gray()</span><br><span class="line"><span class="comment"># 在原点的左上角显示轮廓图像</span></span><br><span class="line">contour(im, origin=<span class="string">'image'</span>)</span><br><span class="line">axis(<span class="string">'equal'</span>)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>图像的直方图用来表征该图像<strong>像素值的分布情况</strong>。用一定数目的小区间（bin）来指定表征像素值的范围，每个小区间会得到落入该小区间表示范围的像素数目。该（灰度）图像的直方图可以使用hist() 函数绘制，其第一个参数必须是一维数组输入，因此需要用flatten()方法按行优先展平，第二个参数指定了小区间的数目。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">figure()</span><br><span class="line">hist(im.flatten(),<span class="number">128</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>图像轮廓和直方图的效果如下所示（害怕*2）：<br><img src="https://s1.ax1x.com/2020/08/24/dsUvwR.png" alt="dsUvwR.png"><br><img src="https://s1.ax1x.com/2020/08/24/dsaq4P.png" alt="dsaq4P.png"></p><h3 id="交互式标注"><a href="#交互式标注" class="headerlink" title="交互式标注"></a>交互式标注</h3><p>有时候需要用户交互来标记某些点或者标注训练数据，使用ginput()函数就可以实现交互式标注。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>))</span><br><span class="line">imshow(im)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Please click 3 points'</span>)</span><br><span class="line">x = ginput(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'you clicked:'</span>,x)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>首先绘制一幅图像，然后等待用户在绘图窗口的图像区域点击三次。程序将这些点击的坐标[x, y] 自动保存在列表中。</p><h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy是著名的Python科学计算工具包。NumPy 中的数组对象几乎贯穿用于本书的所有例子中，数组对象可以帮助实现数组中重要的操作，比如矩阵乘积、转置、解方程系统、向量乘积和归一化，这为图像变形、对变化进行建模、图像分类、图像聚类等提供了基础。</p><h3 id="图像数组表示"><a href="#图像数组表示" class="headerlink" title="图像数组表示"></a>图像数组表示</h3><p>先前的例子中已经调用过array()方法将图像转换成NumPy的数组对象。NumPy的数组对象是多维的，可以用来表示向量、矩阵和图像。</p><p>对于图像数据，运行以下实例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>))</span><br><span class="line"><span class="keyword">print</span> (im.shape, im.dtype)</span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>),<span class="string">'f'</span>)</span><br><span class="line"><span class="keyword">print</span> (im.shape, im.dtype)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(763, 720, 3) uint8</span><br><span class="line">(763, 720) float32</span><br></pre></td></tr></table></figure><p>其中每行的第一个元组表示图像数组的大小（行、列、颜色通道），紧接着的字符串表示数组元素的数据类型。因为图像通常被编码成无符号八位整数（uint8），所以在第一种情况下，载入图像并将其转换到数组中，数组的数据类型为“uint8”。</p><p>在第二种情况下，对图像进行灰度化处理，并且在创建数组时使用额外的参数“f”；该参数将数据类型转换为浮点型。注意，由于灰度图像没有颜色信息，所以在形状元组中，它只有两个数值。</p><p>数组中的元素可以使用下标访问，如果仅用一个下标，则该下标为行下标。位于坐标i、j，以及颜色通道k 的像素值可以像下面这样访问：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = im[i,j,k]</span><br></pre></td></tr></table></figure><p>同样也可以数组切片方式访问，例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">im[i,:] = im[j,:] <span class="comment"># 将第j 行的数值赋值给第i 行</span></span><br><span class="line">im[:,i] = <span class="number">100</span> <span class="comment"># 将第i 列的所有数值设为100</span></span><br><span class="line">im[:<span class="number">100</span>,:<span class="number">50</span>].sum() <span class="comment"># 计算前100 行、前50 列所有数值的和</span></span><br><span class="line">im[<span class="number">50</span>:<span class="number">100</span>,<span class="number">50</span>:<span class="number">100</span>] <span class="comment"># 50~100 行，50~100 列（不包括第100 行和第100 列）</span></span><br><span class="line">im[i].mean() <span class="comment"># 第i 行所有数值的平均值</span></span><br><span class="line">im[:,<span class="number">-1</span>] <span class="comment"># 最后一列</span></span><br><span class="line">im[<span class="number">-2</span>,:] (<span class="keyword">or</span> im[<span class="number">-2</span>]) <span class="comment"># 倒数第二行</span></span><br></pre></td></tr></table></figure><p>array()变换的逆操作可以用PIL的fromarray()函数完成：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pil_im = Image.fromarray(im)</span><br><span class="line">pil_im = Image.fromarray(uint8(im)) <span class="comment"># 如果通过一些操作将uint8转换为其他类型</span></span><br></pre></td></tr></table></figure><h3 id="图像灰度变换"><a href="#图像灰度变换" class="headerlink" title="图像灰度变换"></a>图像灰度变换</h3><p>将图像读入NumPy数组对象后，就可以对他们执行数学操作，如灰度变换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">im2 = <span class="number">255</span> - im <span class="comment"># 对图像进行反相处理</span></span><br><span class="line">im3 = (<span class="number">100.0</span>/<span class="number">255</span>) * im + <span class="number">100</span> <span class="comment"># 将图像像素值变换到100...200 区间</span></span><br><span class="line">im4 = <span class="number">255.0</span> * (im/<span class="number">255.0</span>)**<span class="number">2</span> <span class="comment"># 对图像像素值求平方后得到的图像</span></span><br></pre></td></tr></table></figure><p>输出图像结果如下：<br><img src="https://s1.ax1x.com/2020/08/24/dyWXqI.png" alt="dyWXqI.png"><br><img src="https://s1.ax1x.com/2020/08/24/dyWvZt.png" alt="dyWvZt.png"><br><img src="https://s1.ax1x.com/2020/08/24/dyfpi8.png" alt="dyfpi8.png"></p><h3 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h3><p>NumPy并没有提供对图像进行缩放处理的方法，可以使用PIL实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imresize</span><span class="params">(im,sz)</span>:</span></span><br><span class="line"><span class="string">""" 使用PIL 对象重新定义图像数组的大小"""</span></span><br><span class="line">    pil_im = Image.fromarray(uint8(im))</span><br><span class="line">    <span class="keyword">return</span> array(pil_im.resize(sz))</span><br></pre></td></tr></table></figure><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图均衡化是指<strong>将一幅图像的灰度直方图变平，使变换后的图像中每个灰度值的分布概率都相同</strong>，<br>在对图像做进一步处理之前，直方图均衡化通常是对图像灰度值进行归一化的一个非常好的方法，并且可以增强图像的对比度。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histeq</span><span class="params">(im,nbr_bins=<span class="number">256</span>)</span>:</span></span><br><span class="line">    <span class="string">""" 对一幅灰度图像进行直方图均衡化"""</span></span><br><span class="line">    <span class="comment"># 计算图像的直方图</span></span><br><span class="line">    imhist,bins = histogram(im.flatten(),nbr_bins,normed=<span class="literal">True</span>)</span><br><span class="line">    cdf = imhist.cumsum() <span class="comment"># cumulative distribution function</span></span><br><span class="line">    cdf = <span class="number">255</span> * cdf / cdf[<span class="number">-1</span>] <span class="comment"># 归一化</span></span><br><span class="line">    <span class="comment"># 使用累积分布函数的线性插值，计算新的像素值</span></span><br><span class="line">    im2 = interp(im.flatten(),bins[:<span class="number">-1</span>],cdf)</span><br><span class="line">    <span class="keyword">return</span> im2.reshape(im.shape), cdf</span><br></pre></td></tr></table></figure><p>该函数有两个输入参数，一个是灰度图像，一个是直方图中使用小区间的数目。函数返回直方图均衡化后的图像，以及用来做像素值映射的累积分布函数。注意，函数中使用到累积分布函数的最后一个元素（下标为-1），目的是将其归一化到0…1范围。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""直方图均衡化"""</span></span><br><span class="line"><span class="keyword">import</span> utils</span><br><span class="line">histeq_out = utils.histeq(im)</span><br><span class="line">imshow(histeq_out[<span class="number">0</span>])</span><br><span class="line">figure()</span><br><span class="line">hist(im.flatten(),<span class="number">128</span>)</span><br><span class="line">figure()</span><br><span class="line">hist(histeq_out[<span class="number">1</span>],<span class="number">128</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>直方图均衡化的输出结果如下。<br><img src="https://s1.ax1x.com/2020/08/25/dcszjI.png" alt="dcszjI.png"><br><img src="https://s1.ax1x.com/2020/08/25/dcyab6.png" alt="dcyab6.png"><br><img src="https://s1.ax1x.com/2020/08/25/dcywVK.png" alt="dcywVK.png"></p><h3 id="图像平均"><a href="#图像平均" class="headerlink" title="图像平均"></a>图像平均</h3><p>图像平均操作是减少图像噪声的一种简单方式，通常用于艺术特效。可以简单地从图像列表中计算出一幅平均图像。假设所有的图像具有相同的大小，可以将这些图像简单地相加，然后除以图像的数目，来计算平均图像。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_average</span><span class="params">(imlist)</span>:</span></span><br><span class="line">    <span class="string">""" 计算图像列表的平均图像"""</span></span><br><span class="line">    <span class="comment"># 打开第一幅图像，将其存储在浮点型数组中</span></span><br><span class="line">    averageim = array(Image.open(imlist[<span class="number">0</span>]), <span class="string">'f'</span>)</span><br><span class="line">    <span class="keyword">for</span> imname <span class="keyword">in</span> imlist[<span class="number">1</span>:]:</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        averageim += array(Image.open(imname))</span><br><span class="line">      <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> imname + <span class="string">'...skipped'</span></span><br><span class="line">    averageim /= len(imlist)</span><br><span class="line">    <span class="comment"># 返回uint8 类型的平均图像</span></span><br><span class="line">    <span class="keyword">return</span> array(averageim, <span class="string">'uint8'</span>)</span><br></pre></td></tr></table></figure><p>该函数可以计算多个图像的平均图像。也可以用mean()函数计算平均图像，但是可能会占用很多内存。</p><p><img src="https://s1.ax1x.com/2020/08/25/dcjrFS.png" alt="dcjrFS.png"></p><h3 id="图像主成分分析（PCA）"><a href="#图像主成分分析（PCA）" class="headerlink" title="图像主成分分析（PCA）"></a>图像主成分分析（PCA）</h3><p>PCA（Principal Component Analysis，主成分分析）是一个非常有用的<strong>降维技巧</strong>。它可以在使用尽可能少维数的前提下，尽量多地保持训练数据的信息。由于图像具有很高的维数，在许多计算机视觉应用中，我们经常使用降维操作。PCA 产生的投影矩阵可以被视为将原始坐标变换到现有的坐标系，坐标系中的各个坐标按照重要性递减排列。</p><p>将变平的图像堆积起来，我们可以得到一个矩阵，矩阵的一行表示一幅图像。在计算主方向之前，所有的行图像按照平均图像进行了中心化。我们通常使用SVD（SingularValue Decomposition，奇异值分解）方法来计算主成分；但当矩阵的维数很大时，SVD 的计算非常慢，所以此时通常不使用SVD 分解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">""" 主成分分析：</span></span><br><span class="line"><span class="string">    输入：矩阵X ，其中该矩阵中存储训练数据，每一行为一条训练数据返回：投影矩阵（按照维度的重要性排序）、方差和均值"""</span></span><br><span class="line">    <span class="comment"># 获取维数</span></span><br><span class="line">    num_data,dim = X.shape</span><br><span class="line">    <span class="comment"># 数据中心化</span></span><br><span class="line">    mean_X = X.mean(axis=<span class="number">0</span>)</span><br><span class="line">    X = X - mean_X</span><br><span class="line">    <span class="keyword">if</span> dim&gt;num_data:</span><br><span class="line">        <span class="comment"># PCA- 使用紧致技巧</span></span><br><span class="line">        M = dot(X,X.T) <span class="comment"># 协方差矩阵</span></span><br><span class="line">        e,EV = linalg.eigh(M) <span class="comment"># 特征值和特征向量</span></span><br><span class="line">        tmp = dot(X.T,EV).T <span class="comment"># 这就是紧致技巧</span></span><br><span class="line">        V = tmp[::<span class="number">-1</span>] <span class="comment"># 由于最后的特征向量是我们所需要的，所以需要将其逆转</span></span><br><span class="line">        S = sqrt(e)[::<span class="number">-1</span>] <span class="comment"># 由于特征值是按照递增顺序排列的，所以需要将其逆转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(V.shape[<span class="number">1</span>]):</span><br><span class="line">          V[:,i] /= S</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># PCA- 使用SVD 方法</span></span><br><span class="line">        U,S,V = linalg.svd(X)</span><br><span class="line">        V = V[:num_data] <span class="comment"># 仅仅返回前nun_data 维的数据才合理</span></span><br><span class="line">        <span class="comment"># 返回投影矩阵、方差和均值</span></span><br><span class="line">    <span class="keyword">return</span> V,S,mean_X</span><br></pre></td></tr></table></figure><p>PCA的过程无需了解，用下面的脚本可以计算图像的主成分。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pca <span class="keyword">import</span> *</span><br><span class="line">im = array(Image.open(imlist[<span class="number">0</span>])) <span class="comment"># 打开一幅图像，获取其大小</span></span><br><span class="line">m,n = im.shape[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取图像的大小</span></span><br><span class="line">imnbr = len(imlist) <span class="comment"># 获取图像的数目</span></span><br><span class="line"><span class="comment"># 创建矩阵，保存所有压平后的图像数据</span></span><br><span class="line">immatrix = array([array(Image.open(im).convert(<span class="string">'L'</span>)).flatten()</span><br><span class="line">                    <span class="keyword">for</span> im <span class="keyword">in</span> imlist],<span class="string">'f'</span>)</span><br><span class="line"><span class="comment"># 执行PCA 操作</span></span><br><span class="line">V,S,immean = pca(immatrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示一些图像（均值图像和前3 个模式）</span></span><br><span class="line">figure()</span><br><span class="line">gray()</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">imshow(immean.reshape(m,n))</span><br><span class="line">axis(<span class="string">'off'</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">2</span>)</span><br><span class="line">    imshow(V[i].reshape(m,n))</span><br><span class="line">    axis(<span class="string">'off'</span>) </span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>结果如下所示（害怕*3）：<br><img src="https://s1.ax1x.com/2020/08/26/d2dbNQ.png" alt="d2dbNQ.png"></p><h3 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h3><p>如果想要保存一些结果或者数据以方便后续使用，Python 中的pickle 模块非常有用。pickle 模块可以接受几乎所有的Python 对象，并且将其转换成字符串表示，该过程叫做封装（pickling）。从字符串表示中重构该对象，称为拆封（unpickling）。这些字符串表示可以方便地存储和传输。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存均值和主成分数据</span></span><br><span class="line">f = open(<span class="string">'font_pca_modes.pkl'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(immean,f)</span><br><span class="line">pickle.dump(V,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入均值和主成分数据</span></span><br><span class="line">f = open(<span class="string">'font_pca_modes.pkl'</span>, <span class="string">'rb'</span>)</span><br><span class="line">immean = pickle.load(f)</span><br><span class="line">V = pickle.load(f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>使用with语句处理文件读写操作，可以自动打开和关闭文件（即使在文件打开时发生错误）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件并保存</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'font_pca_modes.pkl'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">pickle.dump(immean,f)</span><br><span class="line">pickle.dump(V,f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并载入</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'font_pca_modes.pkl'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">immean = pickle.load(f)</span><br><span class="line">V = pickle.load(f)</span><br></pre></td></tr></table></figure><p>NumPy也提供读写文本文件的简单函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">savetxt(<span class="string">'test.txt'</span>,x,<span class="string">'%i'</span>)</span><br><span class="line">x = loadtxt(<span class="string">'test.txt'</span>)</span><br></pre></td></tr></table></figure><h2 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h2><p>SciPy 是建立在NumPy 基础上， 用于数值运算的开源工具包。<br>SciPy 提供很多高效的操作，可以实现数值积分、优化、统计、信号处理，以及图像处理功能。</p><h3 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h3><p>图像的高斯模糊是非常经典的图像卷积例子。本质上是将灰度图像I和一个高斯核进行卷积操作：</p><script type="math/tex; mode=display">I_\sigma = I * G_\sigma</script><p>其中 $G_\sigma$ 是标准差为 $\sigma$ 的二维高斯核，定义为：</p><script type="math/tex; mode=display">G_\sigma = \frac{1}{2\pi\sigma} e^{-(x^2+y^2)/2\sigma^2}</script><p>高斯模糊通常是其他图像处理操作的一部分，比如图像插值操作、兴趣点计算以及很多其他应用。</p><p>SciPy 有用来做滤波操作的scipy.ndimage.filters 模块。该模块使用快速一维分离的方式来计算卷积。你可以像下面这样来使用它：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>)</span><br><span class="line">    im2 = filters.gaussian_filter(im,<span class="number">5</span>*i)</span><br><span class="line">    imshow(im2)</span><br><span class="line">    axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>上面guassian_filter() 函数的最后一个参数表示标准差，其中$\sigma =0,5,10,15$的高斯滤波结果如下所示,$\sigma$越大，处理后的图像细节丢失越多。</p><p><img src="https://s1.ax1x.com/2020/08/26/dWxrqJ.png" alt="dWxrqJ.png"></p><p>如果打算模糊一幅彩色图像，只需简单地对每一个颜色通道进行高斯<br>模糊：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>))</span><br><span class="line">im2 = zeros(im.shape)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    im2[:,:,i] = filters.gaussian_filter(im[:,:,i],<span class="number">5</span>)</span><br><span class="line">im2 = uint8(im2)</span><br><span class="line">imshow(im2)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>$\sigma = 5$时，彩色图像的高斯模糊结果如下。</p><p><img src="https://s1.ax1x.com/2020/08/26/dWzUwd.png" alt="dWzUwd.png"></p><h3 id="图像导数"><a href="#图像导数" class="headerlink" title="图像导数"></a>图像导数</h3><p>图像强度的变化可以用灰度图像$I$（对于彩色图像，通常对每个颜色通道分别计算导数）的x和y 方向导数 $I_x$ 和 $I_y$ 进行描述。</p><p>图像的梯度向量为 $\nabla I = [I_x , I_y]^T$。梯度有两个重要的属性，一是梯度的大小：</p><script type="math/tex; mode=display">| \nabla I | = \sqrt{I_x^2 + I_y^2}</script><p>它描述了图像强度变化的强弱，一是梯度的角度：</p><script type="math/tex; mode=display">\alpha = arctan2 (I_y, I_x)</script><p>描述了图像中在每个点（像素）上强度变化最大的方向。NumPy 中的arctan2() 函数返回弧度表示的有符号角度，角度的变化区间为-π…π。</p><p>可以用离散近似的方式来计算图像的导数。图像导数大多数可以通过卷积简单地实现：</p><script type="math/tex; mode=display">I_x=I * D_x , I_y=I * D_y</script><p>对于 $D_x$ 和 $D_y$ ，通常选用Prewitt滤波器：</p><script type="math/tex; mode=display">D_x = \begin{vmatrix}-1 & 0 & 1 \\ -1 & 0 & 1 \\ -1 & 0 & 1 \\ \end{vmatrix}</script><script type="math/tex; mode=display">D_y = \begin{vmatrix}-1 & -1 & -1 \\ 0 & 0 &  0 \\ 1 & 1 & 1 \\ \end{vmatrix}</script><p>或Sobel滤波器：</p><script type="math/tex; mode=display">D_x = \begin{vmatrix}-1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \\ \end{vmatrix}</script><script type="math/tex; mode=display">D_y = \begin{vmatrix}-1 & -2 & -1 \\ 0 & 0 &  0 \\ 1 & 2 & 1 \\ \end{vmatrix}</script><p>这些导数滤波器可以使用scipy.ndimage.filters 模块的标准卷积操作来简单地实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line"><span class="comment"># Sobel 导数滤波器</span></span><br><span class="line">imx = zeros(im.shape)</span><br><span class="line">filters.sobel(im,<span class="number">1</span>,imx)</span><br><span class="line">imy = zeros(im.shape)</span><br><span class="line">filters.sobel(im,<span class="number">0</span>,imy)</span><br><span class="line">magnitude = sqrt(imx**<span class="number">2</span>+imy**<span class="number">2</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">imshow(imx)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">imshow(imy)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">imshow(magnitude)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>使用Sobel导数滤波器的输出如下所示<br><img src="https://s1.ax1x.com/2020/08/26/dftNuV.png" alt="dftNuV.png"></p><p>这种方法计算图像导数需要滤波器尺度随着图像分辨率变化而变化，为了在<strong>图像噪声方面更稳健</strong>，以及<strong>在任意尺度上计算导数</strong>，我可以使用<strong>高斯导数滤波器</strong>：</p><script type="math/tex; mode=display">I_x=I*G_{\sigma x} , I_y=I*D_{\sigma y}</script><p>其中$G_{\sigma x}$ 和 $G_{\sigma x}$ 表示 $G_\sigma$ 在$x$和$y$方向上的导数， $G_{\sigma x}$ 为标准差为 $\sigma$ 的高斯函数。</p><p>之前用于模糊的 filters.gaussian_filter()函数可以接收额外的参数，用于计算高斯导数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigma = <span class="number">5</span> <span class="comment"># 标准差</span></span><br><span class="line"></span><br><span class="line">imx = zeros(im.shape)</span><br><span class="line">filters.gaussian_filter(im, (sigma,sigma), (<span class="number">0</span>,<span class="number">1</span>), imx)</span><br><span class="line"></span><br><span class="line">imy = zeros(im.shape)</span><br><span class="line">filters.gaussian_filter(im, (sigma,sigma), (<span class="number">1</span>,<span class="number">0</span>), imy)</span><br></pre></td></tr></table></figure><p>该函数的第三个参数指定对每个方向计算哪种类型的导数，第二个参数为使用的标准差。</p><h3 id="对象计数"><a href="#对象计数" class="headerlink" title="对象计数"></a>对象计数</h3><p>形态学（或数学形态学）是度量和分析基本形状的图像处理方法的基本框架与集合。形态学通常用于<strong>处理二值图像</strong>，也可以用于<strong>灰度图像</strong>。二值图像是指图像的每个像素只能取两个值，通常是0和1。二值图像通常是，在计算物体的数目，或者度量其大小时，对一幅图像进行阈值化后的结果。</p><p>scipy.ndimage 中的morphology 模块可以实现形态学操作。你可以使用scipy.ndimage 中的measurements 模块来实现二值图像的计数和度量功能。计算该图像中的对象个数可以通过下面的脚本实现：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements,morphology</span><br><span class="line"><span class="comment"># 载入图像，然后使用阈值化操作，以保证处理的图像为二值图像</span></span><br><span class="line">im = array(Image.open(<span class="string">'./image/1.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">im = <span class="number">1</span>*(im&lt;<span class="number">128</span>)</span><br><span class="line">labels, nbr_objects = measurements.label(im)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Number of objects:"</span>, nbr_objects)</span><br><span class="line">imshow(im)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>上面的脚本首先载入图像，通过阈值化确保该图像是二值图像。使用label() 函数寻找单个的物体，并且按照它们属于哪个对象将整数标签给像素赋值。下图是labels 数组的图像。图像的灰度值表示对象的标签。可以看到，在一些对象之间有一些小的连接。进行二进制开（binary open）操作，我们可以将其移除：</p><p><img src="https://s1.ax1x.com/2020/09/11/wNK4MV.png" alt="wNK4MV.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 形态学开操作更好地分离各个对象</span></span><br><span class="line">im_open = morphology.binary_opening(im,ones((<span class="number">5</span>,<span class="number">5</span>)),iterations=<span class="number">2</span>)</span><br><span class="line">labels_open, nbr_objects_open = measurements.label(im_open)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Number of objects:"</span>, nbr_objects_open)</span><br><span class="line">imshow(im_open)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br></pre></td></tr></table></figure><p>经过开操作后的图像如下图所示。<br><img src="https://s1.ax1x.com/2020/09/11/wNMiid.png" alt="wNMiid.png"></p><p>binary_opening() 函数的第二个参数指定一个数组结构元素。该数组表示以一个像素为中心时使用的相邻像素。在这种情况下，我们在y 方向上使用9 个像素（上面4 个像素、像素本身、下面4 个像素），在x 方向上使用5 个像素。可以指定任意数组为结构元素，数组中的非零元素决定使用哪些相邻像素。参数iterations 决定执行该操作的次数。binary_closing() 函数实现相反的操作。</p><h3 id="一些有用的SciPy模块"><a href="#一些有用的SciPy模块" class="headerlink" title="一些有用的SciPy模块"></a>一些有用的SciPy模块</h3><p>SciPy中的io和misc模块可以用于输入和输出。</p><h4 id="读写-mat文件"><a href="#读写-mat文件" class="headerlink" title="读写.mat文件"></a>读写.mat文件</h4><p>数据以Matlab的.mat文件格式存储时，可以用scipy.io模块进行读取</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = scipy.io.loadmat(<span class="string">'test.mat'</span>)</span><br></pre></td></tr></table></figure><p>上面代码中data 对象包含一个<strong>字典</strong>，字典中的键对应于保存在原始.mat 文件中的变量名。由于这些变量是数组格式的，因此可以很方便地保存到.mat 文件中。仅需创建一个字典（其中要包含你想要保存的所有变量），然后使用savemat() 函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">'x'</span>] = x</span><br><span class="line">scipy.io.savemat(<span class="string">'test.mat'</span>,data)</span><br></pre></td></tr></table></figure><h4 id="以图像形式保存数组"><a href="#以图像形式保存数组" class="headerlink" title="以图像形式保存数组"></a>以图像形式保存数组</h4><p>将数组直接保存为图像文件非常有用。imsave() 函数可以从scipy.misc 模块中载入。要将数组im 保存到文件中，可以使用下面的命令：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imsave</span><br><span class="line">imsave(<span class="string">'test.jpg'</span>,im)</span><br></pre></td></tr></table></figure><p>scipy.misc 模块同样包含了著名的Lena 测试图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena &#x3D; scipy.misc.lena()</span><br></pre></td></tr></table></figure><p>该脚本返回一个512×512 的灰度图像数组。</p>]]></content>
      
      
      <categories>
          
          <category> CV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复试的重点专业问题</title>
      <link href="2020/07/14/%E5%A4%8D%E8%AF%95%E7%9A%84%E9%87%8D%E7%82%B9%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/"/>
      <url>2020/07/14/%E5%A4%8D%E8%AF%95%E7%9A%84%E9%87%8D%E7%82%B9%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>几个专业问题的总结。<br><a id="more"></a></p><!-- TOC --><ul><li><a href="#防火墙主要作用分为哪几种类型各自的特点和可抵御的攻击">防火墙主要作用？分为哪几种类型，各自的特点和可抵御的攻击？</a></li><li><a href="#vpn原理-ipsec和ssl协议簇比较">VPN原理 IPSec和SSL协议簇比较</a></li><li><a href="#缓冲区溢出">缓冲区溢出</a></li><li><a href="#入侵检测技术目的类型-系统组成原理">入侵检测技术目的、类型 系统组成、原理</a></li><li><a href="#对称密码与非对称密码">对称密码与非对称密码</a></li><li><a href="#pe文件格式-壳保护原理">PE文件格式 壳保护原理</a></li><li><a href="#黑客攻击过程">黑客攻击过程</a></li><li><a href="#数据库系统可能存在的威胁和防护措施">数据库系统可能存在的威胁和防护措施</a></li></ul><h3 id="防火墙主要作用？分为哪几种类型，各自的特点和可抵御的攻击？"><a href="#防火墙主要作用？分为哪几种类型，各自的特点和可抵御的攻击？" class="headerlink" title="防火墙主要作用？分为哪几种类型，各自的特点和可抵御的攻击？"></a>防火墙主要作用？分为哪几种类型，各自的特点和可抵御的攻击？</h3><ul><li>防火墙是建立在<strong>内外网络边界</strong>上的过滤封锁机制，是一种用于保护本地系统或者网络不受基于网络的安全威胁的有效方法。</li><li>包过滤 使用特定的规则对IP包进行过滤 网络层</li><li>状态检测 实现TCP连接的跟踪功能</li><li>应用层网关 代理服务器代替链接并充当服务的网关 应用层</li><li>电路层网关 在两个主机首次建立TCP连接时创立一个电子屏障（充当中介，建立两个TCP连接） 会话层</li></ul><h3 id="VPN原理-IPSec和SSL协议簇比较"><a href="#VPN原理-IPSec和SSL协议簇比较" class="headerlink" title="VPN原理 IPSec和SSL协议簇比较"></a>VPN原理 IPSec和SSL协议簇比较</h3><p>IPSec VPN</p><p>基于网络层，对上层应用透明</p><ul><li>通过相应的隧道技术</li><li>支持端对端（LAN to LAN）的加密，无法保护特定数据在通道内的传输安全 通过点到应用的保护，对每一个应用都可以设定安全策略</li><li>需要安装、配置和调试客户端软件</li></ul><p>SSL VPN</p><ul><li>基于安全套接层，技术实力强的厂商可以提供对应用的全面支持</li><li>无需手动安装任何VPN客户端软件</li><li>对某些操作系统和软件存在兼容性问题 兼容性好，支持各种操作系统和终端（如PDA、SmartPhone等）</li></ul><p>IPSec VPN技术是被设计用于连接和保护在信任网络中的数据流，因此更适合为不同的网络提供通信安全保障，而SSL VPN则更适合应用于远程分散移动用户的安全接入。</p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>缓冲区溢出攻击又称堆栈溢出：简单地说就是程序对接受的输入数据没有进行有效检测导致的错误，后果可能造成程序崩溃或者是执行攻击者的命令。缓冲区溢出漏洞在系统软件和应用软件中是大量存在的。</p><p>利用缓冲区溢出攻击可以导致：系统宕机、系统重启动、程序运行失败、获得非授权指令得到系统特权等</p><p>在某些情况下，如果用户输入的数据长度超过应用程序给定的缓冲区，就会覆盖其他数据区。这就称“缓冲区溢出”。</p><h3 id="入侵检测技术目的、类型-系统组成、原理"><a href="#入侵检测技术目的、类型-系统组成、原理" class="headerlink" title="入侵检测技术目的、类型 系统组成、原理"></a>入侵检测技术目的、类型 系统组成、原理</h3><p>利用审计跟踪数据监视入侵活动的思想。</p><p>基于主机的IDS、基于网络的IDS、混合IDS</p><ul><li>信息搜集</li><li>信息分析 <ul><li>统计分析 实时</li><li>模式匹配 实时</li><li>完整性分析 事后</li></ul></li><li>入侵检测<ul><li>基于行为</li><li>基于规则</li></ul></li><li>信息响应<ul><li>主动响应</li><li>被动响应</li></ul></li><li>审计记录</li></ul><h3 id="对称密码与非对称密码"><a href="#对称密码与非对称密码" class="headerlink" title="对称密码与非对称密码"></a>对称密码与非对称密码</h3><ul><li>对称加密的优点<ul><li>速度快,处理量大，适用于对应用数据的直接加密。</li><li>加密密钥长度相对较短,如40比特—-256比特。</li><li>除了加密，还可构造各种加密体制，如产生伪随机数等。</li></ul></li><li>对称加密的缺点<ul><li>密钥在双方都要一致、保密，传递较难。</li><li>大型网络中密钥量大，难以管理，一般需要KDC。</li><li>密钥需要经常更换。</li></ul></li></ul><ul><li>公钥加密的优点<ul><li>只有私钥保密，公钥公开,密钥保存安全。</li><li>网络上密钥管理不需在线，可以离线。</li><li>密钥生命周期相对较长。</li><li>许多公钥方案可以产生数字签名机制。</li></ul></li><li>公钥加密的缺点<ul><li>速度慢，处理量少，适用于密钥交换。</li><li>密钥长度相对较长。</li></ul></li></ul><p>A用B的公钥加密密钥后再用自己的私钥加密，B拿到后用A的公钥解密再用自己的私钥解密得到密钥</p><h3 id="PE文件格式-壳保护原理"><a href="#PE文件格式-壳保护原理" class="headerlink" title="PE文件格式 壳保护原理"></a>PE文件格式 壳保护原理</h3><ul><li>MZ头</li><li>DOS stub 桩程序</li><li>PE头</li><li>section table 节表</li><li>多个section</li></ul><p>外壳代码将加壳的可执行文件解压缩或解密到内存中，此时内存中才会有原始代码，磁盘上仍是加密的代码。</p><p>压缩壳<br>加密壳</p><h3 id="黑客攻击过程"><a href="#黑客攻击过程" class="headerlink" title="黑客攻击过程"></a>黑客攻击过程</h3><ul><li>预攻击 踩点 扫描 手机信息</li><li>攻击 入侵 获取权限 提权</li><li>后攻击 清除痕迹 安插后门</li></ul><h3 id="数据库系统可能存在的威胁和防护措施"><a href="#数据库系统可能存在的威胁和防护措施" class="headerlink" title="数据库系统可能存在的威胁和防护措施"></a>数据库系统可能存在的威胁和防护措施</h3><ul><li>数据篡改</li><li>数据损坏</li><li><p>数据窃取</p></li><li><p>SQL注入</p></li><li>权限滥用</li><li>审计记录不足</li><li>拒绝服务</li><li>备份数据暴露</li><li>身份验证不足</li><li>通信协议</li></ul><p>完整性</p><ul><li>字段有效性检查</li><li>访问控制</li><li>修改日志</li><li>两阶段修改技术</li></ul><p>机密性</p><ul><li>主体身份识别</li><li>访问操作的鉴别和控制</li><li>数据信息加密</li><li>审计和跟踪</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 复试问题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网复习日记</title>
      <link href="2020/07/12/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0-/"/>
      <url>2020/07/12/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0%E6%97%A5%E8%AE%B0-/</url>
      
        <content type="html"><![CDATA[<p>复习《计算机通信网络》。</p><a id="more"></a><p>[TOC]</p><hr><h3 id="计算机通信网"><a href="#计算机通信网" class="headerlink" title="计算机通信网"></a>计算机通信网</h3><h4 id="计算机通信网三要素"><a href="#计算机通信网三要素" class="headerlink" title="计算机通信网三要素"></a>计算机通信网三要素</h4><ul><li>两台以上自治计算机互联</li><li>通道（通信子系统）连接</li><li>通信协议</li></ul><h4 id="计算机通信网的组成"><a href="#计算机通信网的组成" class="headerlink" title="计算机通信网的组成"></a>计算机通信网的组成</h4><p><img src="https://s1.ax1x.com/2020/07/12/U88AyT.png" alt=""></p><ul><li>计算机的通信子系统是核心的要素</li><li>数据通信系统为计算机之间的信息交互提供了传输媒介，并提供可靠的数据传送能力</li></ul><h4 id="通信子网和资源子网"><a href="#通信子网和资源子网" class="headerlink" title="通信子网和资源子网"></a>通信子网和资源子网</h4><p>计算机通信网就是一个由通信子网承载的、传输和共享资源子网的各类信息的系统。</p><ul><li>通信子网负责数据的无差错和有序传递，其处理功能包括差错控制、流量控制、路由选择、网络互连等。</li><li>资源子网是计算机通信的本地系统环境，包括主机、终端和应用程序等，主要功能是：用户资源配置、数据的处理和管理、软件和硬件共享以及负载均衡等。</li></ul><h4 id="主要网络类型"><a href="#主要网络类型" class="headerlink" title="主要网络类型"></a>主要网络类型</h4><ol><li>局域网（LAN）：单位内部使用的高速宽带网络，分为共享型和交换型。</li><li>城域网（MAN）：与LAN类似</li><li>广域网（WAN）：使用分组交换和路由技术</li><li>互联网（internet）：通过WAN连接起来的LAN集合，中间通过网关使不同网络兼容。</li></ol><h3 id="网络软件及协议体系结构"><a href="#网络软件及协议体系结构" class="headerlink" title="网络软件及协议体系结构"></a>网络软件及协议体系结构</h3><h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>定义：相互通信的双方（或多方）对如何进行信息交换所必须遵守的一整套规则。</p><p>作用：完成计算机之间有序的信息交换。</p><p>建立连接要遵守的规则：</p><ol><li>要保证在源-宿点之间存在<strong>物理的传输资源</strong>。</li><li><strong>多路接入技术</strong>必须与所使用的设备配合，执行某种协议</li><li><strong>差错处理功能</strong>的实现需要由两个端设备之间运行的协议来处理（ARQ）</li><li>必须保证信息到达正确的目的地，需要<strong>寻址和路由</strong></li><li>端节点或交换节点上<strong>存储</strong>所收到的信息，直至等待这些信息得到服务或再<strong>转发</strong>出去。这需要协议来协调设备之间的动作</li><li><strong>流量控制</strong>，防止缓冲器溢出，防止拥挤</li><li>保证接入通路能与用户的<strong>特性协调一致</strong>。如：消息格式、字符编码等。</li></ol><h4 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h4><p><img src="https://s1.ax1x.com/2020/07/12/U8ts8s.png" alt=""></p><ul><li>面向应用的协议：TCP/IP：FTP、TELNET、SMTP</li><li>系统到系统的协议：端系统特定应用进程之间</li><li>端到端协议：TCP、UDP</li><li>其他网内协议：流量控制、寻址和路由协议</li><li>点到点协议：直接相连的节点之间。HDLC和PPP</li><li>网络接入协议：MAC</li><li>网间互联协议：不同网络用户的寻址、异构网络协议转换</li></ul><h4 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h4><ul><li>语法</li><li>语义</li><li>时序</li></ul><h4 id="分层的协议体系结构"><a href="#分层的协议体系结构" class="headerlink" title="分层的协议体系结构"></a>分层的协议体系结构</h4><p>将庞大复杂的协议分层不同的层次。各层完成不同的功能。</p><ul><li>分层的基本思想：把整套的协议体系分成一些小块（层），下一层对它的上一层提供服务。</li><li>分层的基本原则：定义每一层向上一层提供的服务，以保证每层功能的相互独立，但不规定如何完成这些服务。</li></ul><h4 id="OSI-RM"><a href="#OSI-RM" class="headerlink" title="OSI/RM"></a>OSI/RM</h4><ul><li>物理层：bit</li><li>数据链路层：帧</li><li>网络层：分组<br><em>（通信子网边界）</em></li><li>传输层：报文(TPDU) 高三层与低三层的接口，第一个端到端的层次。<br><em>（资源子网边界）</em></li><li>会话层：SPDU</li><li>表示层：PPDU</li><li>应用层：APDU</li></ul><h5 id="各层功能"><a href="#各层功能" class="headerlink" title="各层功能"></a>各层功能</h5><ul><li><p>物理层</p><ul><li>提供建立、维护和释放物理链路所需的机械、电气功能和规程等特性；</li><li>通过传输介质进行数据流(比特流)的物理传输、故障监测和物理层管理；</li><li>从数据链路层接收帧，将比特流转换成底层物理介质上的信号。</li></ul></li><li><p>数据链路层</p><ul><li>在<strong>物理链路</strong>的两端之间传输数据；</li><li>在网络层实体间提供<strong>数据传输功能和控制</strong>；</li><li>提供数据的<strong>流量控制</strong>；</li><li>检测和纠正<strong>物理链路产生的差错</strong></li><li>格式化的消息称为帧</li></ul></li><li><p>网络层</p><ul><li>负责<strong>端到端</strong>的数据的路由或交换，为透明地传输数据建立连接</li><li><strong>寻址</strong>并解决与数据在<strong>异构网络</strong>间传输相关的所有问题</li><li>使用上面的传输层和下面的数据链路层的功能；</li><li>格式化的消息称为分组</li></ul></li><li><p>传输层</p><ul><li>提供<strong>无差错的数据传输</strong>；</li><li>接收来自会话层的数据，如果需要，将数据<strong>分割</strong>成更小的分组，向网络层传送分组并确保分组完整和正确到达它们的目的地；</li><li>在系统之间提供<strong>可靠</strong>的透明的数据传输,提供<strong>端到端的错误恢复和流量控制</strong></li></ul></li><li><p>会话层</p><ul><li>提供<strong>节点之间通信过程的协调</strong></li><li>负责执行会话规则（如：连接是否允许半双工或全双工通信？）、同步数据流以及当故障发生时重新建立连接</li><li>使用上面的表示层和下面的传输层的功能。</li></ul></li><li><p>表示层</p><ul><li>提供<strong>数据格式、变换和编码转换</strong>；</li><li>涉及正在传输数据的语法和语义；</li><li>将消息以合适电子传输的格式编码；</li><li>执行该层的数据<strong>压缩和加密</strong>；</li><li>从应用层接收消息，转换格式，并传送到会话层，该层常合并在应用层中</li></ul></li><li><p>应用层</p><ul><li>包括<strong>各种协议</strong>，它们定义了具体的面向拥护的应用：如电子邮件、文件传输和虚拟终端等；</li></ul></li></ul><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ul><li>应用层（application）：TELNET FTP SMTP DNS NNTP HTTP</li><li>传输层（transport）： TCP UDP NVP</li><li>网际层（internet）： IP ICMP ARP RARP</li><li>网络接口（network interface）</li></ul><h3 id="协议分层的基本原理"><a href="#协议分层的基本原理" class="headerlink" title="协议分层的基本原理"></a>协议分层的基本原理</h3><h4 id="分层原理"><a href="#分层原理" class="headerlink" title="分层原理"></a>分层原理</h4><ul><li>分层是一种构造技术<ul><li>将网络看成一些逻辑上相连的层次组成</li><li>每层在下层提供的服务上增加一定的功能，然后再为上层提供服务</li><li>分层能将一个完整的问题，分成许多较小的问题</li></ul></li><li>保证层次间独立<ul><li>只规定提供的服务，而与如何完成无关</li><li>用户只需知道功能，不必知道内部细节</li></ul></li></ul><h4 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h4><h5 id="面向连接服务"><a href="#面向连接服务" class="headerlink" title="面向连接服务"></a>面向连接服务</h5><ul><li>需要连接建立、数据传送、连接释放三个阶段</li><li>数据交换前必须建立连接，结束后必须释放连接</li><li>传送数据时，顺序传送</li></ul><h5 id="无连接服务"><a href="#无连接服务" class="headerlink" title="无连接服务"></a>无连接服务</h5><ul><li>不需要事先建立连接</li><li>不需要两个实体同时活跃</li><li>不能防止报文丢失、失序，是不可靠服务</li></ul><h4 id="N层"><a href="#N层" class="headerlink" title="N层"></a>N层</h4><ul><li>N层的SAP（服务访问点）是N+1层访问N层服务的地方</li><li>一个(N)SAP只能被一个N实体使用，并且只能被一个N+1实体使用</li><li>一个N/N+1实体可以使用多个(N)SAP<br>(N)SAP的标识符称为(N)地址，可以唯一地标识与某个(N+1)实体相连的一个特定(N)SAP。</li></ul><h5 id="N服务与N协议"><a href="#N服务与N协议" class="headerlink" title="N服务与N协议"></a>N服务与N协议</h5><ul><li>服务是上下关系，是各层向上层提供的原语</li><li>协议是水平关系，同层对等实体间通信</li><li>服务和协议是完全分离的</li></ul><h4 id="连接及其操作"><a href="#连接及其操作" class="headerlink" title="连接及其操作"></a>连接及其操作</h4><h5 id="N-连接"><a href="#N-连接" class="headerlink" title="(N)连接"></a>(N)连接</h5><ul><li>两个或多个对等N+1实体之间交换数据时，必须在N层内使用N协议在N+1实体之间建立联系。</li><li>在同一对SAP之间也可以存在若干条连接。这些连接彼此之间的区分是通过连接端点来标识的。</li><li>在一个(N)SAP上的一条连接的端点称为(N)连接端点，(N)CEP。</li></ul><h5 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h5><ul><li>有序释放</li><li>常规释放</li><li>异常释放</li></ul><h5 id="连接复用和分用"><a href="#连接复用和分用" class="headerlink" title="连接复用和分用"></a>连接复用和分用</h5><ul><li>连接的映射关系<ul><li>一对一映射：每条N连接建立在对应得一条N-1连接上</li><li>多对一映射（复用）：若干条N连接建立在同一条N-1连接上</li><li>一对多映射（分用）：一条N连接建立在若干条N-1连接上, N连接的通信量可以分解到若干条N-1连接上.</li></ul></li><li>复用的目的<br>提高使用效率,节省费用;在只有一条N-1连接时,提供多条N连接.</li><li>分用的目的<br>在有多条N-1连接可用时,提高可靠性;提高吞吐量和其他服务质量;利用廉价的多条N-1连接提高经济效益</li></ul><h5 id="PDU-IDU-SDU"><a href="#PDU-IDU-SDU" class="headerlink" title="PDU IDU SDU"></a>PDU IDU SDU</h5><ul><li>(N)与(N)对等实体间<br>(N)PCI + (N)SDU = (N)PDU</li><li>(N)与(N-1)相邻层间<br>(N-1)ICI + (N-1)ID = (N-1)IDU </li></ul><h5 id="数据传送方式"><a href="#数据传送方式" class="headerlink" title="数据传送方式"></a>数据传送方式</h5><ul><li>张昌数据传送</li><li>加速数据传送</li><li>特权数据传送</li></ul><h5 id="数据单元分合"><a href="#数据单元分合" class="headerlink" title="数据单元分合"></a>数据单元分合</h5><ul><li>分段和合段 (N)PCI (N)SDU1 + (N)PCI (N)SDU2 -&gt; (N)PCI (N)SDU</li><li>拼块和分块 (N)PCI (N)SDU (N)PCI (N)SDU</li><li>拼接和分割 (N)PDU + (N)PDU -&gt; (N-1)SDU</li></ul><h4 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h4><ul><li>request</li><li>indication</li><li>response</li><li><p>confirm</p></li><li><p>无确认服务<br>request -&gt; indication -&gt; </p></li><li>确认服务<br>request -&gt; indication -&gt;<br>&lt;- confirm &lt;- response</li></ul><h3 id="数据传输相关概念"><a href="#数据传输相关概念" class="headerlink" title="数据传输相关概念"></a>数据传输相关概念</h3><h4 id="波特率-比特率"><a href="#波特率-比特率" class="headerlink" title="波特率 比特率"></a>波特率 比特率</h4><ul><li>波特率：每秒信号变化次数，码元速率</li><li>比特率：每秒传输的位数</li></ul><p>信号分为V级，比特率=log2V*波特率</p><h4 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h4><p>在假定的理想条件（无噪声）下，为了避免码间串扰，码元的传输速率的上限值。<br>在无噪声信道中，当带宽为W Hz时，<br>码元传输速率的上限值 = 2W Baud</p><h4 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h4><p>带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。<br>在噪声信道中，当带宽为W Hz，信噪比为S/N，则：<br>最大数据传输速率(b/s) = Wlog2(1+S/N)</p><h4 id="基带传输-宽带传输"><a href="#基带传输-宽带传输" class="headerlink" title="基带传输 宽带传输"></a>基带传输 宽带传输</h4><ul><li>基带传输：信号源产生的原始电信号称为基带信号，即将数字数据0、1直接用两种不同的电压表示，然后送到线路上去传输。</li><li>宽带传输：将基带信号进行调制后形成模拟信号，然后采用频分复用技术实现宽带传输。</li></ul><h4 id="信号编码技术"><a href="#信号编码技术" class="headerlink" title="信号编码技术"></a>信号编码技术</h4><h5 id="数模调制"><a href="#数模调制" class="headerlink" title="数模调制"></a>数模调制</h5><p>调幅ASK(Amplitude Shift Keying)<br>调频FSK(Frequency Shift Keying)<br>调相PSK(Phase Shift Keying)<br>正交调相QPSK(Quadrature Phase Shift Keying)</p><h5 id="数数编码"><a href="#数数编码" class="headerlink" title="数数编码"></a>数数编码</h5><ul><li>不归零编码：不能携带时钟信号，无法表示无数据传输。一个时钟周期表示1bit，一次采样得到1bit，效率最高</li><li>曼切斯特编码：低-高跳变为1。能携带时钟信号，且可表示没有数据传输。一个时钟周期表示1bit，2次采样得到1bit</li><li>差分曼切斯特编码：位中间跳变，位间也跳变，表示下一个bit为0。抗干扰性更强。<br>4B/5B编码：用5bit来表示4bit。至少有两个1，即保证在传输中信号码元至少发生两次跳变，以便接收端提取出时钟信号。</li></ul><h5 id="模数编码"><a href="#模数编码" class="headerlink" title="模数编码"></a>模数编码</h5><p>脉冲编码调制PCM技术</p><h5 id="模模调制"><a href="#模模调制" class="headerlink" title="模模调制"></a>模模调制</h5><ul><li>调幅AM (Amplitude Modulation)：载波的振幅随模拟数据的数值变化。</li><li>调频FM (Frequency Modulation)：载波的频率随模拟数据的数值变化。</li><li>调相PM (Phase Modulation)：载波的初始相位随模拟数据的数值变化。</li></ul><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><ul><li>频分复用FDM(Frequency Division Multiplexing)</li><li>时分复用TDM(Time Division Multiplexing)</li><li>统计时分复用STDM(Statistic TDM)</li><li>波分复用 WDM(Wavelength Division Multiplexing)</li><li>码分复用 CDM(Code Division Multiplexing)</li><li>正交频分复用OFDM(Orthogonal Frequency Division Multiplexing)</li></ul><h4 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h4><h5 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h5><p>指交换系统为通信的双方寻找并建立一条全程物理通路，以供双方传输信息，直到信息交换结束。</p><ul><li>空分交换 多级矩阵</li><li>时分交换</li></ul><p>优点</p><ul><li>数据传输时延小</li><li>对用户透明</li><li>吞吐量高<br>缺点：</li><li>必须有一个<strong>呼叫建立</strong>的过程（时延较大）</li><li>专供通信的双方使用，占用固定的带宽，<strong>信道带宽利用率低</strong></li><li>存在呼叫损失现象</li><li>难以实施差错控制措施</li><li>难以适应计算机和各种终端传输速率不一致等情况<br>——不适合具有突发性的计算机数据传输</li></ul><h5 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h5><p>数据的传输不需建立连接，数据的传输是一站一站往下送，所以数据中必须包含目的地址，并采用存储-转发（store-forward）机制</p><ul><li>在数据传输前，不必建立端到端的连接</li><li>只要下一个节点空闲，即可传输</li><li>线路的<strong>利用率较高</strong></li><li>数据中必须包含<strong>地址域</strong></li><li>在数据传输过程中，除了信号传播的延时之外，还有<strong>存储和转发的延时</strong>，而且延时不可估计</li><li>每个中间站点都必须有<strong>足够大的缓存</strong>，但由于报文大小不定，所以缓存通常设置在硬盘中</li><li><p>报文交换的端到端时延</p><ul><li>传输时延</li><li>传播时延</li><li>存储-转发时延</li><li>排队等待时间</li><li>存入中间节点的处理时间</li><li>从存储器送到输出链路的处理时间</li></ul></li></ul><h5 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h5><p>与报文交换相似，只是将报文分为若干个定长的分组，每个分组为一个子报文。<br>管道化 pipelining</p><ul><li>每个分组中必须包含目的地址，并采用<strong>存储-转发机制</strong>。</li><li>收发顺序可能不同，需要<strong>重组</strong></li></ul><h6 id="数据报（无连接方式）"><a href="#数据报（无连接方式）" class="headerlink" title="数据报（无连接方式）"></a>数据报（无连接方式）</h6><p>每个分组独立处理，独自选择在网络中传输的路由。</p><h6 id="虚电路方式（面向连接方式）"><a href="#虚电路方式（面向连接方式）" class="headerlink" title="虚电路方式（面向连接方式）"></a>虚电路方式（面向连接方式）</h6><p>首先要建立传输路径，所有分组均在这个连接上进行传送，帧顺序和路径都是确定的。</p><ul><li>分组中没有目的地址，只有虚电路号</li></ul><h5 id="快速分组交换"><a href="#快速分组交换" class="headerlink" title="快速分组交换"></a>快速分组交换</h5><p>尽量简化底层对数据单元的操作，由端到端的高层协议保证——光纤<br>大大缩短分组长度——异步传输模式ATM</p><h5 id="分组最佳长度"><a href="#分组最佳长度" class="headerlink" title="分组最佳长度"></a>分组最佳长度</h5><p>设报文的总长度为M(bit)，令nh(bit)为附加到每个分组的开销，用Kmax表示包括附加开销在内的最大分组长度。</p><ul><li>以分组方式发送一个报文所必须传送的总比特数为<br>N = M + [M/(Kmax-nh)]nh</li><li>传送一个报文所需要的总时间T为第一个分组通过前面（j－1）条链路的时间加上整个报文通过最后一条链路的时间<br>T = ((j-1)Kmax + N)/R</li><li>运用求极值的常规方法，将上式对Kmax求导，并令导数等于零，于是得到分组最佳长度为<br>K = nh + 根号(E[M]*nh/(j-1))</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="需要数据链路层的理由"><a href="#需要数据链路层的理由" class="headerlink" title="需要数据链路层的理由"></a>需要数据链路层的理由</h4><p>传输数据的信道是不可靠的（即不能保证所传的数据不产生差错），并且还需要对数据的发送端进行流量控制</p><p>要解决的问题</p><ul><li>如何在有差错的线路上，进行无差错传输。</li></ul><p>数据链路层协议定义了<strong>一条链路的两个结点间</strong>交换的数据单元格式，以及结点发送和接收数据单元的动作。</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>对网络层提供服务接口，对网络层实体提供数据链路连接的建立、维持和释放</li><li>将bit流组装成帧frame</li><li>控制帧在物理链路上的传输 帧的同步、传输差错、速率匹配</li></ul><p>向网络层提供：</p><ul><li>无应答无连接服务</li><li>应答式无连接服务</li><li>面向连接的服务</li></ul><h4 id="frame的构成"><a href="#frame的构成" class="headerlink" title="frame的构成"></a>frame的构成</h4><ul><li>字符计数法</li><li>带字符填充的起始字符和终结字符法<ul><li>DLE STX</li><li>DLE ETX</li><li>DLE DLE</li></ul></li><li>带位填充的起始/终结标志法</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>反馈确认</li><li>超时机制</li><li>顺序编号</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li>协调发送速度与接受速度匹配</li><li>连续性ARQ中，必须对已发送出去但未被确认的数据帧的数目加以限制（浪费资源、附加的帧序号开销大）</li></ul><h5 id="滑动窗口式流量控制"><a href="#滑动窗口式流量控制" class="headerlink" title="滑动窗口式流量控制"></a>滑动窗口式流量控制</h5><ul><li>发送窗口：任何时刻发送端都保持着一组序号，对应于在还没有收到对方确认的条件下最多允许发送的帧。<br>发送窗口的上界表示要<strong>还能发送的帧的最大序号</strong>，下界表示<strong>等待确认的帧的最小编号</strong>。发送窗口大小 = 上界 - 下界，大小可变；<br>发送端每发送一个帧，序号取下界值加1；每接收到一个正确响应帧，上界加1；</li><li>接收窗口：对应于一组允许（或期望）接收的帧。<br>接收端有一个接收窗口，大小固定，但不一定与发送窗口相同。接收窗口的上界表示<strong>允许接收的序号最大的帧</strong>，下界表示<strong>希望接收的序号最小帧</strong>；<br>接收窗口容纳允许接收的信息帧，落在窗口外的帧均被丢弃。序号等于下界的帧被正确接收，并产生一个响应帧，上界、下界都加1。接收窗口大小不变</li></ul><h4 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h4><h5 id="前向纠错FEC"><a href="#前向纠错FEC" class="headerlink" title="前向纠错FEC"></a>前向纠错FEC</h5><p>接收端检测到接收信息有错后，通过一定的运算，确定差错的具体位置，并自动加以纠正。</p><h6 id="汉明定理"><a href="#汉明定理" class="headerlink" title="汉明定理"></a>汉明定理</h6><p>用d表示码组的最小汉明距离</p><ul><li>当码组用于检测错误时，设可检测e个位的错误，则<br>d &gt;= e + 1</li><li>若码组用于纠错，设可纠错t个位的错误，则<br>d &gt;= 2t+1</li><li>如果码组用于纠正t个错，同时检测e个错，则<br>d &gt;= 2t+e+1</li></ul><h6 id="循环冗余码CRC"><a href="#循环冗余码CRC" class="headerlink" title="循环冗余码CRC"></a>循环冗余码CRC</h6><p>校验和（checksum）加在帧尾，使带校验和的帧的多项式能被G(x)除尽；收方接收时，用G(x)去除它，若有余数，则传输出错。<br>生成多项式</p><h5 id="反馈重发ARQ"><a href="#反馈重发ARQ" class="headerlink" title="反馈重发ARQ"></a>反馈重发ARQ</h5><p>接收端检测到接收信息有错后，通过反馈信号要求发送端重发原信息，直到接收端肯定确认为止，从而达到纠正差错的目的。</p><ul><li>肯定确认ACK</li><li>否定确认NAK</li><li>超时重发 规定时间内未收到ACK/NAK</li></ul><h6 id="等待式ARQ"><a href="#等待式ARQ" class="headerlink" title="等待式ARQ"></a>等待式ARQ</h6><p>等待式ARQ方法为了获得通信的可靠性而牺牲了传输效率，过于浪费信道的有效带宽。</p><p>Ws = Wr = 1</p><h6 id="回退N帧ARQ"><a href="#回退N帧ARQ" class="headerlink" title="回退N帧ARQ"></a>回退N帧ARQ</h6><p>发送端连续发送一系列信息帧，不等前帧确认便发下一帧。因此，连续重发请求方案把等待时间利用起来，传输效率大大提高。然而在实现上相应地需要更大的缓冲存储空间。</p><p>回退N帧ARQ会回退到错误帧开始重发</p><p>1 &lt; Ws &lt;= 2**n - 1 , Wr = 1</p><h6 id="选择性重发ARQ"><a href="#选择性重发ARQ" class="headerlink" title="选择性重发ARQ"></a>选择性重发ARQ</h6><p>选择性重发ARQ只重发错误帧</p><p>Ws &lt;= 2**n - 1 , Ws + Wr &lt;= 2**n<br>Ws &gt;= Wr</p><h5 id="纠检混合的差错控制方式"><a href="#纠检混合的差错控制方式" class="headerlink" title="纠检混合的差错控制方式"></a>纠检混合的差错控制方式</h5><p>接收端对少量的接收差错自动纠正，而超过纠正能力的差错则通过反馈重发的方法加以纠正。</p><h4 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h4><p>面向字符的协议</p><p>a)初始状态<br>b)建立连接：建立成功到c)，否则到a)<br>c)选项协商：协商成功到d)，否则到g)<br>d)身份认证：认证成功到e)，否则到g)<br>e)配置网络：网络配置完后到f)<br>f)数据传输：数据传输完后到g)<br>g)释放链路：回到a)</p><p>PPP协议不提供纠错、流量控制、序号、多点线路</p><h4 id="高级数据链路控制-HDLC"><a href="#高级数据链路控制-HDLC" class="headerlink" title="高级数据链路控制 HDLC"></a>高级数据链路控制 HDLC</h4><p>面向bit的同步通信协议</p><ul><li>初始化</li><li>数据传输</li><li>断开连接</li></ul><h3 id="介质接入控制"><a href="#介质接入控制" class="headerlink" title="介质接入控制"></a>介质接入控制</h3><h4 id="广播信道分配问题"><a href="#广播信道分配问题" class="headerlink" title="广播信道分配问题"></a>广播信道分配问题</h4><p>信道使用产生竞争时，分配信道使用权。<br>用来决定广播信道中信道分配的功能及协议属于数据链路层的子层，称作介质接入控制MAC(Medium Access Control)子层。</p><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><ul><li>频分多路复用（FDM）</li><li>时分多路复用（TDM）</li><li>波分多路复用（WDM）</li></ul><h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><p>若干假设：</p><ul><li>数据站模型</li><li>单信道假设</li><li>冲突重传</li><li>连续时间与时间分槽 何时发送</li><li>载波侦听和无载波侦听 能否发送</li></ul><h4 id="动态分配技术"><a href="#动态分配技术" class="headerlink" title="动态分配技术"></a>动态分配技术</h4><h5 id="查询技术"><a href="#查询技术" class="headerlink" title="查询技术"></a>查询技术</h5><p>查询技术是常见的一种信道访问技术，该技术都需要一个中心控制站，中央控制站周期性地向各终端或工作站发送查询帧，各用户只有当被控制站查询时，才能发送信息。</p><p>传统查询：</p><ul><li>roll-call</li><li>hub<br>在轻负载的情况下，效率较低<br>在重负载的情况下，将引入较长的时延</li></ul><p>探查法：探查二叉树<br>（1）同时探查一组（两个或多个）站点。如果其中某个站点需发送数据，则它反馈以某种形式的信号；否则，系统就认为整个该组站点都是空闲的，直至下一次探查。<br>（2）将具有反馈信号的站点组（即其中有站点申请使用信道）分成两个子组，重复过程（1）。<br>（3）对于最终的探查（即组内只有一个站点），由控制站发送给该站点一个查询帧，使其可以发送数据。</p><p>自适应查询：探查+查询</p><h5 id="随机接入：ALOHA"><a href="#随机接入：ALOHA" class="headerlink" title="随机接入：ALOHA"></a>随机接入：ALOHA</h5><p>目的：解决信道的动态分配，基本思想可用于任何无协 调关系的用户争用单一共享信道使用权的系统；</p><h6 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h6><p>基本思想：当用户想要发送数据帧时，它就可以在任何时候发送。但是，不同用户发出的数据帧就有可能发生冲突。冲突的帧将被破坏，传输不成功，使吞吐量下降。</p><p>易受冲突时间2T<br>平均每个帧时产生S个新帧<br>帧发送的均值为G</p><p>S = G e<code>&lt;sup&gt;</code>-2G<code>&lt;sup&gt;</code><br>S<code>&lt;sub&gt;</code>max<code>&lt;sub&gt;</code> = 1/2e = 0.184</p><h6 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h6><ul><li>在一个时隙内产生的新帧，将在下一个时隙开始处发送，冲突危险区为T</li><li>新帧的产生是随机的，但是不允许随机发送</li><li>在一个时隙的起点没有其它帧发送的概率为：P0 = e<code>&lt;sup&gt;</code>-G<code>&lt;sup&gt;</code><br>S = G e<code>&lt;sup&gt;</code>-G<code>&lt;sup&gt;</code><br>S<code>&lt;sub&gt;</code>max<code>&lt;sub&gt;</code> = 1/e = 0.368<br>（0.37时隙为空，0.37时隙成功，0.26时隙冲突）</li><li>时隙ALOHA需要全网的同步机制，增加了复杂性</li></ul><h5 id="随机接入：CSMA"><a href="#随机接入：CSMA" class="headerlink" title="随机接入：CSMA"></a>随机接入：CSMA</h5><p>载波侦听多址接入，发送之前侦听信道，减少盲目性</p><ul><li>非持续型<ul><li>信道空闲则发送，忙则延迟一随机时长再侦听</li><li>限制信道利用率的进一步提高</li></ul></li><li>p-持续型<ul><li>信道空闲则以p概率发送，以1-p概率延迟一个时隙再侦听</li><li>随即延迟使吞吐特性变坏，但尽快发送和主动退避使其性能优于非持续型CSMA</li></ul></li><li>1-持续型<ul><li>空闲则发送</li><li>轻载性能好，重载时比持续型CSMA差，最大吞吐量只能达到0.53</li></ul></li></ul><p>0.01-持续&gt;0.1持续&gt;0.5持续&gt;1持续&gt;slotted-ALOHA&gt;pure-ALOHA</p><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><p>发送前进行载波侦听，发送过程中侦听是否冲突，检测到冲突后及时中断发送。</p><h6 id="冲突检测："><a href="#冲突检测：" class="headerlink" title="冲突检测："></a>冲突检测：</h6><ul><li>信号电平</li><li>过零点检测法（过零点将偏移）</li><li>自发自收</li></ul><h6 id="操作规程"><a href="#操作规程" class="headerlink" title="操作规程"></a>操作规程</h6><ul><li>竞争发送<ul><li>发送前侦听总线，空则发送，否则等待</li><li>发送后侦听冲突检测，若有冲突则干预总线——继续发送异常帧，延迟等待</li></ul></li><li>无冲突接收<ul><li>检测到冲突后发送不完全帧（冲突加强）</li><li>接受站点收到后，处理错误信息</li></ul></li></ul><h6 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h6><p>就是让发生碰撞的站在停止发送数据后，不是立即再发送数据，而是推迟（这叫做退避）一个随机时间。具体做法是：<br>（1）确定基本退避时间，一般是取为争用期2 τ 。<br>（2）定义参数k，它等于重传次数，但k不超过10，即k=Min(重传次数，10)。<br>（3）从离散整数集合[0,1,2,…,(2<code>&lt;sup&gt;</code>k<code>&lt;/sup&gt;</code>-1)]中随机地取出一个数，记为r。重传输所需的时间就是r倍的基本退避时间。<br>（4）当重传达16次仍不能成功时，则丢弃该帧，并向高层报告。</p><h6 id="最短帧长"><a href="#最短帧长" class="headerlink" title="最短帧长"></a>最短帧长</h6><p>如果帧的第一个比特到达电缆的远端前帧已经发完，那么即使发生冲突也无法检测，因此帧发送时间应该大于 2τ；</p><ul><li>10Mbps LAN，最大冲突检测时间为51.2微秒，最短帧长为64字节；</li><li>网络速度提高，最短帧长应增大或者站点间的距离要减小。</li></ul><h3 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h3><h4 id="局域网的低三层"><a href="#局域网的低三层" class="headerlink" title="局域网的低三层"></a>局域网的低三层</h4><p>IEEE 802.1标准规定局域网的低三层。<br>（1）物理层：与OSI/RM的物理层相对应，但所采用的具体协议标准直接与传输介质有关。<br>（2）介质接入控制（MAC）层：具体管理通信实体接入信道而建立数据链路的控制过程。尽力而为的数据报服务<br>（3）逻辑链路控制（LLC）层：提供一个或多个服务访问点，以复用的形式建立多点—多点之间的数据通信连接，并包括寻址、差错控制、顺序控制和流量控制等功能。</p><ul><li>LLC层向网络层提供多个服务访问点L-SAP。对同一个LLC可以提供多个MAC选择</li><li>MAC层向LLC层提供一个服务访问点M-SAP</li><li>物理层向MAC层也只需单一的服务访问点P-SAP</li><li><p>两个站点建立逻辑链路连接，需要两种地址：</p><ul><li>MAC物理地址，即某站在网络中的物理地址（48位网卡地址），由MAC帧负责传送；</li><li>L-SAP地址，即进程在站中的地址，由LLC帧负责传送。</li></ul></li><li>LLC层与局域网形态和传输介质无关</li><li>MAC层与局域网形态和传输介质直接相关</li></ul><h4 id="IEEE802协议"><a href="#IEEE802协议" class="headerlink" title="IEEE802协议"></a>IEEE802协议</h4><p>802.1 基本介绍和接口原语定义<br>802.2 逻辑链路控制（LLC）子层<br>802.3 采用CSMA/CD技术的局域网<br>802.4 采用令牌总线（Token Bus）技术的局域网<br>802.5 采用令牌环（Token Ring）技术的局域网</p><h4 id="公用信道的分配方法"><a href="#公用信道的分配方法" class="headerlink" title="公用信道的分配方法"></a>公用信道的分配方法</h4><div class="table-container"><table><thead><tr><th>方法/系统</th><th>说明</th></tr></thead><tbody><tr><td>纯ALOHA</td><td>在任何时候均非同步传输</td></tr><tr><td>时隙ALOHA</td><td>在定义恰当的时隙内随机传输</td></tr><tr><td>1－持续CSMA</td><td>标准的载波侦听多路访问</td></tr><tr><td>非持续CSMA</td><td>当侦听到信道忙时随机延迟</td></tr><tr><td>p－持续CSMA</td><td>CSMA，但持续概率为p</td></tr><tr><td>CSMA/CD</td><td>CSMA，但发生冲突时终止</td></tr><tr><td>以太网</td><td>采用CSMA/CD的局域网</td></tr><tr><td>令牌总线</td><td>在一条物理总线上的逻辑环</td></tr><tr><td>令牌环</td><td>在发送数据前必须获得令牌</td></tr></tbody></table></div><h4 id="无线局域网使用的CSMA-CA"><a href="#无线局域网使用的CSMA-CA" class="headerlink" title="无线局域网使用的CSMA/CA"></a>无线局域网使用的CSMA/CA</h4><p>带冲突避让的载波多路侦听CSMA/CA</p><ul><li>无线局域网很难检测信道</li><li>任何站在完成发送后必须等待一段很短的时间才能发送下一帧，这段时间称为帧间间隔IFS(InterFrame Space)。</li><li>争用：当信道从忙转为空闲时，任何站在发送数据前，都要采用二进制后退算法减少发生冲突的概率。与以太网不一样的是第i次后退是从2<code>&lt;sup&gt;</code>2+i<code>&lt;/sup&gt;</code>个时隙中选取一个</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层为一个网络连接的两个传输层实体间交换网络服务数据单元提供功能和规程的方法，它使传输层实体看不到下面资源的使用情况。</p><ul><li>网络层是处理端到端传输的最低层，通信子网的最高层。</li></ul><h4 id="网络层解决的问题"><a href="#网络层解决的问题" class="headerlink" title="网络层解决的问题"></a>网络层解决的问题</h4><ul><li>路由选择</li><li>拥塞控制</li></ul><h4 id="向传输层提供的服务"><a href="#向传输层提供的服务" class="headerlink" title="向传输层提供的服务"></a>向传输层提供的服务</h4><ul><li>面向连接的服务:将复杂的功能放在网络层(通信子网)</li><li>无连接服务:将复杂的功能放在传输层</li><li>通信子网提供的服务（面向连接或无连接）与通信子网结构（虚电路或数据报）没有必然联系。</li></ul><h4 id="网络层的两种实现方式-——-数据报和虚电路"><a href="#网络层的两种实现方式-——-数据报和虚电路" class="headerlink" title="网络层的两种实现方式 —— 数据报和虚电路"></a>网络层的两种实现方式 —— 数据报和虚电路</h4><ul><li>都属于分组交换，采用存储转发机制。<br><img src="https://s1.ax1x.com/2020/07/13/UJhRcn.png" alt=""></li></ul><h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4><h5 id="路由选择与流量控制的关系"><a href="#路由选择与流量控制的关系" class="headerlink" title="路由选择与流量控制的关系"></a>路由选择与流量控制的关系</h5><p>路由选择的时延反馈给流量控制，改变吞吐量</p><h5 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h5><ul><li>某节点路由表包括目的节点和下一节点</li><li>虚电路中的路由表使用虚电路号<br>从所有的源节点到一个给定的目的节点的最优路由的集合形成了一个以目的节点为根的树，称为汇集树；</li></ul><h5 id="路由选择算法-1"><a href="#路由选择算法-1" class="headerlink" title="路由选择算法"></a>路由选择算法</h5><h6 id="随机路由选择"><a href="#随机路由选择" class="headerlink" title="随机路由选择"></a>随机路由选择</h6><p>随机选择出口转发，可能造成分组在通信子网中长期中转</p><h6 id="洪泛路由选择"><a href="#洪泛路由选择" class="headerlink" title="洪泛路由选择"></a>洪泛路由选择</h6><p>基本思想:把收到的每一个包，向除了该包到来的线路外的所有输出线路发送。<br>优点：可靠性高，路径最短<br>主要问题:洪泛要产生大量重复包，浪费带宽。<br>解决措施:每个包头包含站点计数器，每经过一站计数器减1，为0时则丢弃该包；在每个节点上建立登记表，则数据包再次经过时丢弃</p><h6 id="固定式路由选择（静态）"><a href="#固定式路由选择（静态）" class="headerlink" title="固定式路由选择（静态）"></a>固定式路由选择（静态）</h6><ul><li>固定式单路由算法(绝对固定式路由选择)<ul><li>每个节点都有一张人工计算得到的固定路由表。</li><li>优点是简单、实现方便，可选择正常情况下的最佳路由。</li><li>缺点是路由表不能联机修改，不能适应网络的业务量及拓扑变化。</li></ul></li><li>固定式多路由算法（迂回式路由选择）<ul><li>固定式多路由算法是任何一对节点之间有多条可选路由。</li><li>缺点是路由表不能联机修改。</li></ul></li></ul><h6 id="动态路由选择"><a href="#动态路由选择" class="headerlink" title="动态路由选择"></a>动态路由选择</h6><p>自适应路由选择方法是从路径和时延两方面考虑的：</p><ul><li>孤立的自适应路由算法<ul><li>选择路由时，仅仅孤立地依据<strong>本节点自身</strong>的当前运行状态（流量和排队）信息来决定路由，而与网络其他各节点的状态无关。</li></ul></li><li>分布式自适应路由选择<ul><li>在网络相邻节点之间，每经过一定时间<strong>相互交换一次状态信息</strong>，各节点根据相邻节点送来的状态信息来修改自己的路由表。</li><li>距离矢量路由算法<ul><li>每个路由器维护一张矢量表，表中列出了该节点到每个目的地已知的最佳距离和路径。</li><li>相邻路由器交换信息</li></ul></li><li>链路状态（link state）算法<ul><li>与距离矢量算法不同，它是一种<strong>全局</strong>的路由选择算法</li><li>每个节点将链路状态包向网络中所有其他的节点广播。链路状态包包括节点的身份和它到相邻节点的代价信息。最后的结果是<strong>所有的节点都具有同样的网络拓扑图</strong>。</li></ul></li></ul></li></ul><h4 id="网络流量控制"><a href="#网络流量控制" class="headerlink" title="网络流量控制"></a>网络流量控制</h4><h5 id="网络拥塞的因素"><a href="#网络拥塞的因素" class="headerlink" title="网络拥塞的因素"></a>网络拥塞的因素</h5><ul><li>缓冲器容量不够<ul><li>缓冲器容量不足时，分组丢失；但缓冲器太大时，会发生超时</li></ul></li><li>处理器速度太低</li><li>链路带宽不够</li></ul><h5 id="拥塞控制和流量控制的关系"><a href="#拥塞控制和流量控制的关系" class="headerlink" title="拥塞控制和流量控制的关系"></a>拥塞控制和流量控制的关系</h5><ul><li>拥塞控制必须使得通信子网能够传送所有待传送的数据，它是一个<strong>全局性</strong>的问题，涉及到所有主机、路由器、路由器中的存储转发处理的行为。</li><li>流量控制是与某发送者和某接收者之间的<strong>点到点</strong>的业务量有关。它的任务是确保一个快速的发送者不能以比接收者能承受的速率更高的速度传输数据。</li><li>简单的说，流量控制是防止网络拥塞的一种机制。</li></ul><h5 id="流量控制的功能"><a href="#流量控制的功能" class="headerlink" title="流量控制的功能"></a>流量控制的功能</h5><ul><li>防止过载产生吞吐量降低、响应时间增长</li><li>避免死锁</li><li>资源合理分配</li><li>速率匹配</li></ul><h5 id="缓冲策略与流量控制"><a href="#缓冲策略与流量控制" class="headerlink" title="缓冲策略与流量控制"></a>缓冲策略与流量控制</h5><p>为了使没有得到确认的PDU可以超时重发，需要在缓冲区中暂存</p><ul><li>数据链路层 点对点通信 缓冲区大小根据滑窗协议而定</li><li>传输层 端到端通信 多个缓冲区动态分配和管理非常复杂</li></ul><h5 id="流量整形技术"><a href="#流量整形技术" class="headerlink" title="流量整形技术"></a>流量整形技术</h5><p>流量整形需要在网络的边沿实现以便控制进入网络的流量速率。<br>与之相比，TCP滑动窗口协议只是限制一次传送数据的数量，而不是传送的速率。</p><h6 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h6><p>这种策略相当于将非平稳的分组流变成了一个平稳的分组流，从而<strong>平滑了数据分组的突发性</strong>。<br>但是没有考虑突发业务流的大小，<strong>输出不具有突发性</strong>。</p><h6 id="令牌漏桶算法"><a href="#令牌漏桶算法" class="headerlink" title="令牌漏桶算法"></a>令牌漏桶算法</h6><p>在令牌漏桶算法中，漏桶中保留的不是数据分组，而是令牌。系统每隔ΔT个时间单位产生一个令牌，送入漏桶中。当漏桶满时，产生的新令牌将被丢弃。对于数据分组来说，只有获得了令牌才可以发送。当有多个分组要发送，可以根据获取的令牌数决定一次可发送的分组数，从而使漏桶的输出具有一定的突发性。</p><h4 id="网络拥塞控制"><a href="#网络拥塞控制" class="headerlink" title="网络拥塞控制"></a>网络拥塞控制</h4><h5 id="网络性能和网络负载的关系"><a href="#网络性能和网络负载的关系" class="headerlink" title="网络性能和网络负载的关系"></a>网络性能和网络负载的关系</h5><ul><li>当网络的负载较小时，吞吐量和负载呈线性关系；</li><li>当负载达到膝点（knee point)之后，随着负载的继续增加，吞吐量的增量变化很小；</li><li>当负载超过了崖点（cliff point)之后，吞吐量却急剧下降。<br>通常将膝点附近称为拥塞避免区，膝点和崖点间的区域成为拥塞恢复区，而崖点之后的区域称为拥塞崩溃区。</li></ul><h5 id="处理拥塞的控制方法"><a href="#处理拥塞的控制方法" class="headerlink" title="处理拥塞的控制方法"></a>处理拥塞的控制方法</h5><ul><li>分组删除</li><li>流量控制<ul><li>只限制两点流量，多源造成的拥塞仍会出现</li></ul></li><li>缓冲分配 能用于需电力技术中</li><li>抑制分组</li></ul><h5 id="网络中的拥塞控制机制"><a href="#网络中的拥塞控制机制" class="headerlink" title="网络中的拥塞控制机制"></a>网络中的拥塞控制机制</h5><ul><li>开环拥塞控制<ul><li>预防式</li><li>优点：控制算法性能不受传输影响</li><li>缺点：资源利用率低</li></ul></li><li>闭环拥塞控制<ul><li>反馈式</li><li>源算法：在主机和网络边缘设备中执行。根据反馈信息调整发送速率。</li><li>链路算法：在网络内部（如路由器和交换机）中执行，它的主要作用是检测网络拥塞的发生，生成拥塞反馈信息。</li></ul></li></ul><h4 id="TCP的流量控制和拥塞控制"><a href="#TCP的流量控制和拥塞控制" class="headerlink" title="TCP的流量控制和拥塞控制"></a>TCP的流量控制和拥塞控制</h4><p>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</p><p>可以用不同的机制来控制 TCP 报文段的发送时机:</p><ul><li>第一种机制是 TCP 维持一个变量，它等于<strong>最大报文段长度 MSS</strong>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>第二种机制是由发送方的<strong>应用进程指明要求发送</strong>报文段，即 TCP 支持的推送(push)操作。</li><li>第三种机制是发送方的一个<strong>计时器期限到了</strong>，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li></ul><h5 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h5><ul><li>TCP 为每一个连接设有一个持续计时器。</li><li>只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。</li><li>定时发送零窗口探测报文段。</li></ul><h5 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h5><p>数据接收窗口（R-window）和拥塞控制窗口（C-window）。接收窗口的大小由接收端的缓存容量决定，拥塞窗口的大小由网络的带宽决定。发送端所能发送的数据段的数量是接收窗口和拥塞窗口<strong>二者的最小值</strong>。</p><ul><li>TCP拥塞控制机制分为“<strong>慢启动</strong>”和“<strong>拥塞避免</strong>”两个阶段。数据段发送端用一个门限变量（或阈值）来区分两个阶段。当发送端开始发送数据时，首先处于“慢启动”阶段。</li></ul><p>“慢启动”用于探测网络的带宽,使用指数增长的方式;“拥塞避免”试图避免拥塞的发生。</p><ul><li>在慢开始门限ssthresh前为慢开始阶段，拥塞窗口<strong>指数增长</strong>：每经过一个传输轮次，拥塞窗口 cwnd 就加倍。</li><li>在门限后进入拥塞避免阶段，拥塞窗口<strong>线性增加</strong>（加法增大）</li><li>发生超时则慢开始门限改为拥塞窗口的一半（<strong>乘法减小</strong>），拥塞窗口设置为1</li></ul><h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><ul><li>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段。</li><li>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。而是将拥塞窗口设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ul><h3 id="网络互连"><a href="#网络互连" class="headerlink" title="网络互连"></a>网络互连</h3><h4 id="网际层IP协议"><a href="#网际层IP协议" class="headerlink" title="网际层IP协议"></a>网际层IP协议</h4><ul><li>地址解析协议 ARP(Address Resolution Protocol)</li><li>逆地址解析协议 RARP(Reverse Address Resolution Protocol)</li><li>网际控制报文协议 ICMP(Internet Control Message Protocol)</li><li>网际组管理协议 IGMP(Internet Group Management Protocol)</li></ul><h4 id="互连设备的类型"><a href="#互连设备的类型" class="headerlink" title="互连设备的类型"></a>互连设备的类型</h4><p>当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。</p><h5 id="物理层中继系统"><a href="#物理层中继系统" class="headerlink" title="物理层中继系统"></a>物理层中继系统</h5><p>转发器 集线器</p><ul><li>物理层设备，在电缆段之间拷贝比特；</li><li>对弱信号进行放大或再生，以便延长传输距离。</li></ul><h5 id="数据链路层中继系统"><a href="#数据链路层中继系统" class="headerlink" title="数据链路层中继系统"></a>数据链路层中继系统</h5><p>网桥、交换机</p><ul><li>数据链路层设备，在局域网之间存储转发帧；</li><li>网桥可以改变帧格式。</li></ul><h5 id="路由层中继系统"><a href="#路由层中继系统" class="headerlink" title="路由层中继系统"></a>路由层中继系统</h5><p>路由器</p><ul><li>网络层设备，在网络之间存储转发包；</li><li>必要时，做网络层协议转换。</li></ul><h5 id="高层中继系统"><a href="#高层中继系统" class="headerlink" title="高层中继系统"></a>高层中继系统</h5><p>网关</p><h4 id="互连方式"><a href="#互连方式" class="headerlink" title="互连方式"></a>互连方式</h4><ul><li><p>级联虚电路</p><ul><li>建立连接</li><li>传输数据</li><li>拆除连接</li></ul></li><li><p>无连接互连</p><ul><li>每个包单独路由</li><li>根据不同子网的需要做协议转换</li></ul></li><li><p>级联虚电路的优点</p><ul><li>路由器预留缓冲区等资源，保证服务质量；</li><li>包按序号传输；</li><li>短包头。</li></ul></li><li><p>级联虚电路的缺点</p><ul><li>路由器需要大量内存，存储虚电路信息；</li><li>一旦发生拥塞，没有其它路由；</li><li>健壮性差；</li><li>如果网络中有一个不可靠的数据报子网，级连虚电路很难实现。</li></ul></li><li><p>无连接网络互连的优点</p><ul><li>能够容忍拥塞，并能适应拥塞；</li><li>健壮性好；</li><li>可用于多种网络互连。</li></ul></li><li><p>无连接网络互连的缺点</p><ul><li>长包头；</li><li>包不能保证按序号到达；</li><li>不能保证服务质量。</li></ul></li></ul><h4 id="LAN的互连"><a href="#LAN的互连" class="headerlink" title="LAN的互连"></a>LAN的互连</h4><h5 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h5><p>使用hub连接的计算机共享一个“<strong>碰撞域</strong>”</p><ul><li>从某一端口A将收到的帧发送到所有端口</li><li>非广播帧时，地址与帧目的MAC地址相同的站响应用户A</li><li>广播帧时，所有用户都响应用户A</li></ul><h5 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h5><p>一种存储转发装置</p><ul><li>读取网络N1上的所有帧并接收那些指向N2的帧；</li><li>将接收的帧送到数据链路层，在该层上计算校验和并计算到达N2的路由；</li><li>将接受的帧用N2的MAC协议转发到N2上；</li></ul><p>不足：</p><ul><li>存储转发导致时延增加</li><li>无流量控制功能，负载重时会丢失帧</li><li>不能防止广播风暴（广播消息仍会泛滥到网桥所连接的各个网段）</li></ul><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>交换机利用“地址学习”的方法来动态建立和维护端口号/MAC地址映射表的。</p><ul><li>直接交换方式(只要接收并检测到目的地址字段就立即将该帧转发出去，而不管这一帧数据是否出错。)</li><li>存储转发方式(交换机先完整接收数据帧进行差错检测再转发 FCS检测)</li><li>改进的直接交换方式(接收数据帧的前64字节 判断字头段正确再转发)</li></ul><h6 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h6><p>建立在网络交换机基础上</p><p>优点：</p><ul><li>建立虚拟工作组，便于进行网络的管理</li><li>增强了网络安全性</li><li>抑制广播数据的泛滥</li><li>减少了处理用户站点移动所带来的开销</li></ul><p>一个VLAN就好像是一个孤立的网段，VLAN间不能直接通信，实现VLAN间互联必须借助于<strong>路由器</strong>。</p><p>MAC帧中有VLAN标记</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP = net id + host id</p><h5 id="IP分类"><a href="#IP分类" class="headerlink" title="IP分类"></a>IP分类</h5><p>A类 8+24  0……<br>B类 16+16 10……<br>C类 24+8 110……<br>D类 多播 1110……<br>E类 保留 1111……</p><p>后缀全1表示广播</p><h5 id="IP地址的重要特点"><a href="#IP地址的重要特点" class="headerlink" title="IP地址的重要特点"></a>IP地址的重要特点</h5><ul><li>IP分net和host的好处：<ul><li>IP地址管理机构只分发网络号</li><li>路由器只根据网络号进行路由</li></ul></li><li>一个路由器至少应有两个IP</li></ul><h5 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h5><p>TCP报文 = 首部 + 应用层数据<br>IP数据报 = 首部(含IP) + TCP报文<br>MAC帧 = 首部(含MAC地址) + IP数据报</p><h4 id="ARP和RARP"><a href="#ARP和RARP" class="headerlink" title="ARP和RARP"></a>ARP和RARP</h4><p>IP地址 -ARP-&gt; 物理地址</p><p>物理地址 -RARP-&gt; IP地址</p><p>每个主机中都设有一个ARP高速缓存，包含<strong>所在局域网</strong>上各主机和路由器的IP-MAC地址映射，对不同局域网应该找到路由器的硬件地址转发给下一网络。</p><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><ul><li>标志<br>DF = 0 表示本分组允许分段<br>= 1 表示本分组必须完整到达，途中不允许分段<br>MF = 0 表示本段为本分组的最后一个段<br>= 1 表示本段后面还有更多的分段</li><li>段偏移（fragmentation offset）：13位<br>实际偏移量 = 段偏移值 x 8 Byte</li></ul><h5 id="数据报分段与重组"><a href="#数据报分段与重组" class="headerlink" title="数据报分段与重组"></a>数据报分段与重组</h5><ul><li>每个分段头部copy原来的头部，与分段相关的重新生成</li><li>必须在各分段都到达目的地之后才进行重组：（可以不同路由、不按序）<br>要么重组成功，要么全部丢弃的原则</li></ul><h4 id="IP层转发分组流程"><a href="#IP层转发分组流程" class="headerlink" title="IP层转发分组流程"></a>IP层转发分组流程</h4><ul><li>主机号路由</li><li>特定主机路由</li><li>默认路由</li></ul><p>(1) 从数据报的首部提取目的主机的 IP 地址 D（划分子网情况下需要先相与）, 得出目的网络地址为 N。<br>(2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br>(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br>(4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。<br>(6) 报告转发分组出错。</p><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><h5 id="两级IP到三级IP"><a href="#两级IP到三级IP" class="headerlink" title="两级IP到三级IP"></a>两级IP到三级IP</h5><p>IP = net id + subnet id + host id</p><p>子网划分后对外仍是一个网络</p><p>子网掩码是一个网络或子网的重要属性，表示网络号+子网号的位数</p><p>IP地址和子网掩码与运算得到网络地址</p><h5 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h5><p>一个 CIDR 地址块可以表示很多地址—路由聚合/构成超网</p><p>IP = 网络前缀 + host id</p><ul><li>提高IP地址的利用率</li><li>缩短路由表</li></ul><p>使用CIDR时，路由表最长前缀匹配</p><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。</p><ul><li>ICMP 允许主机或路由器<strong>报告差错情况</strong>和提供有关异常情况的报告。</li><li>ICMP 不是高层协议，而<strong>是 IP 层的协议</strong>。</li><li>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。</li></ul><h5 id="ICMP报文种类"><a href="#ICMP报文种类" class="headerlink" title="ICMP报文种类"></a>ICMP报文种类</h5><ul><li>差错报告报文<ul><li>终点不可达</li><li>源抑制</li><li>超时</li><li>重定向</li><li>参数问题</li></ul></li><li>询问报文<ul><li>回送请求和回答</li><li>时间戳请求和回答</li></ul></li></ul><h5 id="不发送ICMP差错报文的情况"><a href="#不发送ICMP差错报文的情况" class="headerlink" title="不发送ICMP差错报文的情况"></a>不发送ICMP差错报文的情况</h5><ul><li>ICMP报文出错</li><li>对分片的数据报值只发送一个</li><li>多播地址和特殊地址不发送</li></ul><h5 id="ICMP应用"><a href="#ICMP应用" class="headerlink" title="ICMP应用"></a>ICMP应用</h5><h6 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h6><ul><li>使用了回送请求与回答报文</li><li>测试两个主机连通性</li></ul><h6 id="tarcert"><a href="#tarcert" class="headerlink" title="tarcert"></a>tarcert</h6><ul><li>使用超时报文</li><li>不断增大hop直至到达</li></ul><h6 id="得到路径中最小的MTU"><a href="#得到路径中最小的MTU" class="headerlink" title="得到路径中最小的MTU"></a>得到路径中最小的MTU</h6><ul><li>使用参数错误报文</li><li>置DF=1不允许分段，不断减小报文长度</li></ul><h4 id="自治系统AS"><a href="#自治系统AS" class="headerlink" title="自治系统AS"></a>自治系统AS</h4><p>一个AS对其他AS表现出单一和一致的路由选择策略</p><h4 id="内部网关协议IGP-域内路由选择"><a href="#内部网关协议IGP-域内路由选择" class="headerlink" title="内部网关协议IGP 域内路由选择"></a>内部网关协议IGP 域内路由选择</h4><h5 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h5><ul><li>分布式的基于距离向量的路由选择协议</li><li>要求每一个路由器维护从他自己到每一个目的网络的距离记录，定时和相邻路由器交换路由信息</li><li>各路由器中信息不同</li><li>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</li><li>RIP 不能在两个网络之间同时使用多条路由。</li><li>RIP 允许一条路径最多只能包含 15 个路由器。<br>“距离”的最大值为16 时即相当于不可达。可见 RIP 只适用于小型互联网。</li></ul><p><strong>RIP用UDP数据报传送</strong></p><p>优点：</p><ul><li>实现简单 开销较小<br>缺点：</li><li>网络出现故障时，时延较长(好消息传播得快，坏消息传播得慢)</li><li>距离最大为16，网络规模受限</li><li>路由表开销随网络规模增大</li></ul><h5 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h5><p>是分布式的链路状态协议</p><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</li></ul></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li></ul><p><strong>各路由器中信息一致</strong></p><p>OSPF可以将AS再划分成多个区域，减少洪泛法的通信量</p><p><strong>OSPF直接用IP数据报传送</strong>，数据报很短</p><p>特点：</p><ul><li>支持CIDR和变长子网划分</li><li>多路径负载均衡</li><li>对不同服务计算不同路由</li></ul><p>五种分组：</p><ul><li>类型1，问候(Hello)分组。</li><li>类型2，数据库描述(Database Description)分组。</li><li>类型3，链路状态请求(Link State Request)分组。</li><li>类型4，链路状态更新(Link State Update)分组，<br>用洪泛法对全网更新链路状态。<br>类型5，链路状态确认(Link State Acknowledgment)<br>分组。</li></ul><h4 id="外部网关协议EGP-域间路由选择"><a href="#外部网关协议EGP-域间路由选择" class="headerlink" title="外部网关协议EGP 域间路由选择"></a>外部网关协议EGP 域间路由选择</h4><h5 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h5><ul><li>在AS间交换“可达性”信息</li><li>边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而<strong>并非要寻找一条最佳路由</strong>。</li></ul><p>BGP发言人通常为边界路由器，两个BGP发言人通过一个共享网络连接</p><p><strong>BGP建立TCP连接以建立BGP会话</strong></p><p>特点：</p><ul><li>支持CIDR</li><li>BGP邻站只更新变化部分</li></ul><h4 id="网际组管理协议-IGMP-和多播路由选择协议"><a href="#网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="网际组管理协议 IGMP 和多播路由选择协议"></a>网际组管理协议 IGMP 和多播路由选择协议</h4><p>用于IP多播：</p><ul><li>IGMP：使路由器知道多播组成员的信息</li><li>多播路由选择协议：把多播数据报用最小代价传送给所有的组成员。这就需要使用。</li></ul><p>IGMP在本地使用，并不知道多播组的成员数，知识让多播路由器知道主机加入或退出<br><strong>IGMP 使用 IP 数据报</strong>，但它也向 IP 提供服务</p><p>多播路由选择协议必须动态适应成员变化</p><p>转发多播数据报使用的方法：</p><ul><li>洪泛与剪除<br>路由器转发多播数据报使用洪泛法。为了避免兜圈子，采用了叫做反向路径广播 RPB (Reverse Path Broadcasting)的策略。</li><li>隧道技术(tunneling)<br>使用隧道技术在单播网络中传递多播数据报</li><li>基于核心的发现技术</li></ul><h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><ul><li>本地地址——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</li><li>全球地址——全球唯一的IP地址，必须向因特网的管理机构申请。</li></ul><h5 id="隧道技术实现VPN"><a href="#隧道技术实现VPN" class="headerlink" title="隧道技术实现VPN"></a>隧道技术实现VPN</h5><p><img src="https://s1.ax1x.com/2020/07/13/UYTJjH.png" alt=""></p><h5 id="内联网和外联网"><a href="#内联网和外联网" class="headerlink" title="内联网和外联网"></a>内联网和外联网</h5><p>都是基于TCP/IP协议</p><ul><li>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联网(intranet)，表示部门 A和 B 都是在同一个机构的内部。</li><li>一个机构和某些外部机构共同建立的虚拟专用网 VPN 又称为外联网(extranet)。</li></ul><h5 id="远程接入VPN"><a href="#远程接入VPN" class="headerlink" title="远程接入VPN"></a>远程接入VPN</h5><p>VPN软件在PC和主机间建立隧道</p><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>把私有IP地址转换成公开IP地址</p><p>Router（Firewall）将对请求IP包和返回的应答IP包作NAT</p><p>返回的包到达源端：<br>利用传输层的源端口号字段，查询NAT中的映射表进行转换</p><h5 id="NAT存在的问题"><a href="#NAT存在的问题" class="headerlink" title="NAT存在的问题"></a>NAT存在的问题</h5><ul><li>NAT违反了IP的体系结构<br>IP规定一个IP地址对应一个网络接口，而在NAT中，某个地址可能会对应成千上万个地址</li><li>NAT将Internet的无连接服务变成了有连接服务<br>因为NAT必须包含所有经过它的连接信息</li><li>NAT违反了网络分层原则<br>在第三层用了第四层协议格式中的字段</li><li>如果IP包的载荷不是TCP或UDP，则NAT无法工作<br>因为在其他协议的信息中不包含源端口号</li><li>在有些应用中NAT可能会出错<br>在有些应用中，发送方会将源IP地址嵌在它的消息中，接收方必须从信息中取用源IP地址，但NAT不作此类处理，因而将导致错误</li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>更大的地址空间</li><li>首部简化</li><li>支持选项</li><li>安全性</li><li>服务质量 多媒体应用</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>面向通信部分的最高层，用户功能中的最低层，在通信子网中没有传输层。介于通信子网和资源子网之间。</p><h4 id="传输层的任务"><a href="#传输层的任务" class="headerlink" title="传输层的任务"></a>传输层的任务</h4><p>提供从源端到目的端（应用进程间）<strong>可靠</strong>而有效的数据传输，屏蔽低层网络的差异</p><h4 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h4><ul><li>用户数据报协议 UDP (User Datagram Protocol)：无连接，不可靠</li><li>传输控制协议 TCP (Transmission Control Protocol)：面向连接，可靠，不提供广播或多播服务</li></ul><p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU (Transport Protocol Data Unit)。</p><ul><li>TCP 传送的数据单位协议是 TCP 报文段(segment)</li><li>UDP 传送的数据单位协议是 UDP 报文或用户数据报。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>特点：</p><ul><li>面向连接</li><li>只能一对一</li><li>可靠交付</li><li>全双工</li><li>面向字节流</li></ul><h5 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h5><p>—-SYN=1,seq=x—-&gt;<br>&lt;—-SYN=1,ACK=1,seq=y,ack=x+1—-<br>—-ACK=1,seq=x+1,ack=y+1—-&gt;</p><p>正常流程：<br><img src="https://s1.ax1x.com/2020/07/11/UM7cqS.png" alt=""></p><p>避免的异常流程：</p><ul><li>重复的CR出现，主机2接受连接，但是主机1随即拒绝</li><li>同时有作废的CR和ACC出现，主机1的数据应该捎带确认该ACC，但是主机1并不会这样做</li></ul><h5 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h5><p>—-FIN=1,seq=u—-&gt;<br>&lt;—-ACK=1,seq=v,ack=u+1—-<br>…数据传送…<br>&lt;—-FIN=1,ACK=1,seq=w,ack=u+1—-<br>—-ACK=1,seq=u+1,ack=w+1—-&gt;<br>左边需等待2MSL才释放：</p><ul><li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</li><li>防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。</li><li>非对称释放</li><li><p>对称释放</p><ul><li>正常情况</li><li>最后的确认TPDU丢失，因超时释放</li><li>数据的应答丢失，因超时重发重新进行三次握手，传输完释放</li><li>应答和重发都丢失，因多次重发超时而释放</li></ul></li></ul><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><p>特点：</p><ul><li>无连接</li><li>尽最大努力交付，不可靠，无拥塞控制</li><li>面向报文</li><li>支持一/多对一/多</li><li>首部开销小</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口号 16bit 只具有本地意义<br>TCP和UDP都使用了端口号</p><ul><li>传输层地址，也称为传输服务访问点（TSAP）在TCP协议中传输层地址即TCP的端口号</li><li>网络层地址称为网络服务访问点NSAP（Network Service Access Point），NSAP在IP协议中即IP地址</li></ul><p>套接字 = IP + port</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器</li></ul><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><ul><li>主机向本地域名服务器的查询一般都是采用递归查询。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</li></ul><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>FTP 只提供文件传送的一些基本的服务，它使用<strong>TCP</strong> 可靠的运输服务。</p><ul><li>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：<ul><li>一个主进程，负责接受新的请求；</li><li>若干个从属进程，负责处理单个请求。</li></ul></li></ul><p>两个TCP连接：</p><ul><li>控制连接 客户端连接服务器21</li><li>数据连接 服务器20连接客户端</li></ul><h3 id="TELNET-远程终端协议"><a href="#TELNET-远程终端协议" class="headerlink" title="TELNET 远程终端协议"></a>TELNET 远程终端协议</h3><ul><li>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。</li><li>用户用 TELNET 就可在其所在地通过<strong>TCP</strong>连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</li><li>和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</li></ul><p>TELNET 使用网络虚拟终端 NVT 格式</p><h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><h4 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h4><p>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。<br>协议://主机:端口/路径</p><h4 id="HTTP-超文本传送协议"><a href="#HTTP-超文本传送协议" class="headerlink" title="HTTP 超文本传送协议"></a>HTTP 超文本传送协议</h4><p>是一个应用层协议，它使用 TCP 连接进行可靠的传送。</p><ul><li>分析超链指向页面的URL</li><li>浏览器向DNS请求解析域名的IP</li><li>DNS解析出IP</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取index.htm文件命令</li><li>服务器响应，把index.htm文件发给浏览器</li><li>TCP连接释放</li><li>浏览器显示index.htm文件的文本</li></ul><p>HTTP协议本身是无连接的<br>HTTP/1.1后使用持续连接</p><h5 id="代理服务器又称Web-Cache"><a href="#代理服务器又称Web-Cache" class="headerlink" title="代理服务器又称Web Cache"></a>代理服务器又称Web Cache</h5><ul><li>代表浏览器发出 HTTP 请求。</li><li>万维网高速缓存把最近的一些请求和响应暂存在代理服务器的本地磁盘中。</li></ul><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><p>一个邮件服务器既可以作为客户，也可以作为服务器</p><ul><li>发件人调用 PC 机中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</li><li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。</li><li>收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。</li></ul><h5 id="发送邮件-SMTP"><a href="#发送邮件-SMTP" class="headerlink" title="发送邮件 SMTP"></a>发送邮件 SMTP</h5><p>建立TCP连接传送邮件<br>端口号25</p><p>存在冒名发送邮件的漏洞</p><h5 id="接收邮件-POP3-IMAP"><a href="#接收邮件-POP3-IMAP" class="headerlink" title="接收邮件 POP3 IMAP"></a>接收邮件 POP3 IMAP</h5><p>POP3:<br>POP 也使用客户服务器的工作方式。<br>在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。</p><p>IMAP:<br>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。<br>因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。</p><h5 id="通用因特网邮件扩充-MIME"><a href="#通用因特网邮件扩充-MIME" class="headerlink" title="通用因特网邮件扩充 MIME"></a>通用因特网邮件扩充 MIME</h5><p>SMTP缺点：</p><ul><li>不能传送可执行文件</li><li>限于传送ASCII</li><li>长度限制</li><li>MIME 并没有改动 SMTP 或取代它。</li><li>MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。</li></ul><h4 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h4><p>使用UDP端口（需要广播）</p><p>协议配置需要配置的项目<br>(1) IP 地址<br>(2) 子网掩码<br>(3) 默认路由器的 IP 地址<br>(4) 域名服务器的 IP 地址</p><p>DHCP提供了即插即用的机制，不需要手动配置</p><p>步骤：</p><ul><li>需要IP的主句启动时向DHCP服务器广播发送<em>发现报文</em>，成为DHCP客户</li><li>只有DHCP服务器回答此广播报文（DNCP中继代理）</li><li>DHCP服务器在数据库中查找，若无则分配一个，发送<em>提供报文</em></li></ul><p><strong>租用期</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机通信网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机通信网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全导论日记</title>
      <link href="2020/07/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E6%97%A5%E8%AE%B0-/"/>
      <url>2020/07/08/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA%E6%97%A5%E8%AE%B0-/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;作为17级的人下人，我对学院不开《网络安全导论》这门课表示十分愤懑且无奈，可是夏令营/考研复试又涉及这门课，只能自学了。</p><a id="more"></a><p>[TOC]</p><hr><h2 id="网络信息安全概述"><a href="#网络信息安全概述" class="headerlink" title="网络信息安全概述"></a>网络信息安全概述</h2><p>本章主要内容是网络信息安全的概述，比较简单。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>&emsp;&emsp;COMSEC、INFOSEC、TCSEC、ITSEC、Information Assurance、IATF、深度防护战略、木桶原则</p><hr><h3 id="信息安全的发展阶段"><a href="#信息安全的发展阶段" class="headerlink" title="信息安全的发展阶段"></a>信息安全的发展阶段</h3><h4 id="通信保密阶段-40-60年代"><a href="#通信保密阶段-40-60年代" class="headerlink" title="通信保密阶段 40-60年代"></a>通信保密阶段 40-60年代</h4><p>&emsp;&emsp;在20世纪初期，通信技术还不发达，面对电话、电报、传真等信息交换过程中存在的安全问题，强调的主要是<strong>信息的保密性</strong>，安全理论和技术的研究侧重于<strong>密码学</strong>，这一阶段称为通信安全，即<strong>COMSEC(Communication Security)</strong></p><p>&emsp;&emsp;主要解决:<strong>发方和收方的信息源编码、信道编码和传输、通信协议和密码的问题。</strong></p><h4 id="信息安全阶段-80-90年代"><a href="#信息安全阶段-80-90年代" class="headerlink" title="信息安全阶段 80-90年代"></a>信息安全阶段 80-90年代</h4><p>&emsp;&emsp;20世纪60年代后，半导体和集成电路技术的飞速发展推动了计算机软硬件的发展，计算机和网络技术的应用进入了实用化和规模化阶段，安全扩展为<strong>以保密性、完整性和可用性为目标的信息安全阶段</strong>，即<strong>INFOSEC(Information Security)</strong>.</p><p>&emsp;&emsp;代表成果是美国国防部标准5200.28——可信计算系统评估准则（<strong>TCSEC 桔皮书</strong>）和欧洲四国（荷兰、法国、英国、德国）的信息技术安全评估准则（<strong>ITSEC 白皮书</strong>）的制定。</p><h4 id="信息保障阶段-90年代"><a href="#信息保障阶段-90年代" class="headerlink" title="信息保障阶段 90年代-"></a>信息保障阶段 90年代-</h4><p>&emsp;&emsp;20世纪80年代开始，信息对内对外都得到极大开放，由此产生的信息安全问题跨越了时间和空间，信息安全的焦点已经不仅仅是传统的保密性、完整性和可用性三个原则了，由此衍生出了诸如<strong>可控性、抗抵赖性、真实性</strong>等其他的原则和目标，信息安全也转化为<strong>从整体角度考虑其体系建设的信息保障(Information Assurance)阶段</strong>，代表是美国的<strong>IATF规范。</strong></p><h5 id="IATF技术框架"><a href="#IATF技术框架" class="headerlink" title="IATF技术框架"></a>IATF技术框架</h5><p>&emsp;&emsp;美国国家安全局制定的信息保障技术框架（IATF）1998年开始，已发布V3.0，IATF代表理论为”<strong>深度防护战略(Defense-in-Depth)</strong>“。IATF强调<strong>人、技术、操作三个核心原则</strong>，人借助技术的支持，实施一系列的操作过程，最终实现信息保障目标。</p><p><img src="https://s1.ax1x.com/2020/07/11/UM7rxP.png" alt=""></p><h4 id="网络空间安全阶段"><a href="#网络空间安全阶段" class="headerlink" title="网络空间安全阶段"></a>网络空间安全阶段</h4><p>&emsp;&emsp;物联网、云计算、大数据、移动互联网、人工智能等技术……</p><hr><h3 id="网络信息安全发展趋势"><a href="#网络信息安全发展趋势" class="headerlink" title="网络信息安全发展趋势"></a>网络信息安全发展趋势</h3><ul><li>网络边界的消失：网络基础设施扩展、无线/移动接入-&gt;网络固有边界消失</li><li>应用层威胁不断增加</li><li>漏洞威胁涌现、传播速度加快</li><li>网络攻击简单化、多样化</li><li>攻击技术与病毒技术、社交工程融合</li><li>新技术的安全威胁增加</li><li>人工智能在攻击与反制中的应用：APT（高级持续威胁）、0day攻击；网络流量分析、态势感知、漏洞挖掘、攻防对抗、行为分析……</li></ul><hr><h3 id="信息安全基本特征"><a href="#信息安全基本特征" class="headerlink" title="信息安全基本特征"></a>信息安全基本特征</h3><ul><li>相对性：相对安全；安全性在不同部件间可以转移。</li><li>时效性</li><li>安全攻击源与防范对象的不确定性</li><li>逆向思维与复杂的“人-机”关系</li><li>相关性：不同配置、新部件都会引入安全问题</li><li>信息结构的高度脆弱性和风险性：安全防护是全面保护过程。“木桶原理”</li></ul><h4 id="木桶原则"><a href="#木桶原则" class="headerlink" title="木桶原则"></a>木桶原则</h4><p>&emsp;&emsp;攻击者的攻击原则是 <strong>“最易渗透原则”</strong> ——攻击防守最薄弱的部分。同样，安全防御的目标也是提高整个系统的 <strong>“安全最低点”</strong>。</p><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>上次主要学习了信息安全发展的几个阶段、发展趋势和基本特征，提到了</p><ul><li>通信保密、信息安全（保密性、机密性、完整性，TCSEC、ITSEC）、信息保障（可控性、真实性、不可抵赖性，IATF、三保卫一支撑）；</li><li>网络边界消失、攻击简单多样化、应用层威胁增加、0day和APT攻击、漏洞被发现和传播的速度加快、AI的应用、网络攻击与社会工程学结合等；</li><li>相对性、时效性、不确定性、相关性、逆向思维、“木桶原则”。</li></ul><p>本章主要涉及计网基础的复习。</p><h3 id="关键词-1"><a href="#关键词-1" class="headerlink" title="关键词"></a>关键词</h3><p>计算机网络、OSI、TCP/IP、port、socket、MAC、DNS、三次握手、TCP、UDP</p><hr><h3 id="资源子网和通信子网"><a href="#资源子网和通信子网" class="headerlink" title="资源子网和通信子网"></a>资源子网和通信子网</h3><p>把计算机网络中实现<strong>网络通信</strong>功能的设备及其软件的集合称为网络的通信子网，而把网络中实现<strong>资源共享</strong>功能的设备及其软件的集合称为资源子网。</p><h3 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h3><p>计算机网络是指将地理位置不同，具有独立功能(或自治能力)的多个计算机系统用通信设备和线路连接起来，并以功能完善的网络软件（网络协议、网络操作系统等）进行信息交换，实现资源共享和协同工作的系统。具备以下特征：</p><ul><li>两台或以上地理位置不同、具有“自治能力”的计算机</li><li>各结点间有通道——传输介质实现<strong>物理互联</strong></li><li>各结点间能够通信，并遵守相应的协议，实现<strong>逻辑互联</strong></li><li>以实现数据通信和网络资源共享与协作为目的</li></ul><h3 id="计算机通信三要素"><a href="#计算机通信三要素" class="headerlink" title="计算机通信三要素"></a>计算机通信三要素</h3><ul><li>计算机构成的网络</li><li>通信信道</li><li>协议</li></ul><h3 id="网络层次模型"><a href="#网络层次模型" class="headerlink" title="网络层次模型"></a>网络层次模型</h3><p>底层物理媒体进行<strong>实通信</strong>，其他对等实体间进行<strong>虚通信</strong>——必须通过旗下各层的通信间接完成。</p><p><img src="https://s1.ax1x.com/2020/07/11/UM72Vg.png" alt=""></p><h4 id="OSI-Open-System-Interconnection-模型"><a href="#OSI-Open-System-Interconnection-模型" class="headerlink" title="OSI(Open System Interconnection)模型"></a>OSI(Open System Interconnection)模型</h4><p><img src="https://s1.ax1x.com/2020/07/11/UM7B8I.png" alt=""></p><p>各层功能及数据单元</p><ul><li>物理层（传递光、电信号）——比特流</li><li>数据链路层（定义访问方法，保证信号无差错）——数据帧</li><li>网络层（负责路由选择）——分组</li><li>传输层（对数据分组，保证数据的传输）——数据段</li><li>会话层（建立、保持和断开会话）——报文</li><li>表示层（编码，解/压缩，加/解密）——报文</li><li>应用层（定义用户程序之间的交互）——字节流</li></ul><h4 id="TCP-IP模型与协议"><a href="#TCP-IP模型与协议" class="headerlink" title="TCP/IP模型与协议"></a>TCP/IP模型与协议</h4><h5 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h5><p>TCP/IP是美国为ARPAnet制定的协议，包含了大量的协议，是由一组通信协议所组成的协议集，TCP和IP是其中最基本也是最重要的两个协议。</p><ul><li>IP协议实现两个基本功能:寻址(路由)和分段; IP协议仅限于将数据从源端传送到目的端,而不提供可靠的传输服务;</li><li>TCP协议：建立在IP协议的基础上用于分组交换计算机网络的主机到主机的协议,是面向连接的端到端的可靠协议,提供可靠的字节流传输和对上层应用提供连接服务;</li></ul><p>TCP/IP模型分为4层：</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>链路层（数据链路层和物理层）</li></ul><h5 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h5><p><img src="https://s1.ax1x.com/2020/07/11/UM76r8.png" alt=""></p><h5 id="端口号和套接字"><a href="#端口号和套接字" class="headerlink" title="端口号和套接字"></a>端口号和套接字</h5><ul><li>端口号：TCP和UDP的应用程序，都有标识其的端口号（用于区分各种应用）。端口号有16位。<ul><li>1-255作为公共端口，是保留号</li><li>256-1024用于UNIX服务</li><li>1024以上的端口号可以本地分配。</li></ul></li><li>套接字socket：是ip地址+TCP使用的端口号，唯一标识整个Internet中地一个网络进程。</li></ul><h5 id="TCP（transmission-control-protocol，传输控制协议）和UDP（user-datagram-protocol，用户数据报协议）"><a href="#TCP（transmission-control-protocol，传输控制协议）和UDP（user-datagram-protocol，用户数据报协议）" class="headerlink" title="TCP（transmission control protocol，传输控制协议）和UDP（user datagram protocol，用户数据报协议）"></a>TCP（transmission control protocol，传输控制协议）和UDP（user datagram protocol，用户数据报协议）</h5><p>同：</p><ul><li>都使用IP协议，即协议数据单元PDU作为IP数据报中的数据部分</li><li>都采用了端口与上层的应用进程进行通信</li></ul><p>异：</p><ul><li>UDP是不可靠的、以数据报为中心的传输协议。提供多路复用和差错检测功能，但是不提供纠错和重发，不保证数据的正确传送和重复出现。</li><li>TCP是面向连接的协议，提供双向的、可靠的、有流量控制的字节流服务，提供缓冲、流控、窗口、自适应重发来保证传输的可靠性。</li></ul><h5 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h5><ul><li>网络号+主机号</li><li>IPv4和IPv6相比（IPv4的缺点）：<ul><li>地址数量有限(32位)</li><li>IP报头复杂</li><li>难以实现扩展和可选机制</li><li>提供有限的不同类型的服务</li><li>缺少安全性和保密性</li></ul></li></ul><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><p>MAC地址就是网卡的物理地址（Physical address），现在的Mac地址一般都采用6字节48bit。</p><h5 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h5><ul><li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</li><li>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</li></ul><h5 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h5><p><img src="https://s1.ax1x.com/2020/07/11/UM7cqS.png" alt=""></p><ul><li>主机1发出的连接请求序号为x(seq=x)</li><li>主机2应答接受主机1的连接请求，并声明自己的序列号为y(seq=y,ACK=x)</li><li>主机1收到确认后发送第一个数据TPDU并确认主机2的序列号(seq=x,ACK=y)，至此，整个连接建立过程正常结束，客户端和服务器进入ESTABLISHED状态，数据传输已正式开始</li><li>CR：Connection Request（连接请求）<br>ACC：Connection Accepted（接受连接）</li></ul><blockquote><p>为什么是三次握手而不是两次握手？<br>  客户端收到服务端的应答后进入ESTABLISHED（已建立连接状态），而服务端在收到客户端的连接请求之后就进入了ESTABLISHED状态。<br>如果出现网络拥塞，客户端发送的连接请求报文A过了很久没有到达服务端，会超时重发请求报文B，服务端正确接受并确认应答，连接建立并开始通信传输数据，等通信结束之后释放连接。<br>此时，如果之前失效的连接请求A到达服务端，由于两次握手就能成功建立连接，服务端收到请求A之后进入ESTABLISHED已建立连接状态，等待发送数据或者主动发送数据，此时，客户端已经进入CLOSED断开连接状态，服务器会一直等下去，浪费服务器连接资源。</p></blockquote><h3 id="局域网基础"><a href="#局域网基础" class="headerlink" title="局域网基础"></a>局域网基础</h3><ul><li>结构复杂程度最低的计算机网络</li><li>仅在同一地点上经网络连在一起</li><li>常用的拓扑结构有总线型结构、环型结构、星型结构。</li><li>局域网中的机器通常离得很近，它是目前应用最广泛的一类网络。以太网是常见的局域网之一。</li></ul><h2 id="网络信息安全基础"><a href="#网络信息安全基础" class="headerlink" title="网络信息安全基础"></a>网络信息安全基础</h2><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p>上次主要复习了计网基础，涉及内容：</p><ul><li>计算机网络的定义</li><li>OSI协议的七层模型</li><li>TCP/IP协议的四层模型<ul><li>TCP和UDP</li><li>DNS域名解析</li><li>TCP三次握手</li><li>子网划分和CIDR</li></ul></li></ul><p>本章主要涉及网络信息安全基础。</p><h3 id="信息安全定义"><a href="#信息安全定义" class="headerlink" title="信息安全定义"></a>信息安全定义</h3><p>&emsp;&emsp;指在既定的安全密级条件下，信息系统通过预警、保护、检测、响应、恢复和反击机制，抵御意外事件或恶意行为攻击，确保信息系统避免非授权的访问、破坏或者服务中断，实现信息和资源的<strong>保密性、完整性、可用性、非否认性和可控性</strong>的能力。</p><h3 id="信息安全的属性-基本要素"><a href="#信息安全的属性-基本要素" class="headerlink" title="信息安全的属性/基本要素"></a>信息安全的属性/基本要素</h3><p>CIA三要素：</p><ul><li><strong>机密性</strong>：指保证信息与信息系统不被非授权者截获和未经授权使用。</li><li><strong>完整性</strong>：指信息是真实可信的，被传输、接收或存储的数据是完整的，其发布者不被冒充，来源不被伪造，内容不被篡改。</li><li><strong>可用性</strong>：指尽管存在可能的突发事件，保证信息与信息系统服务可被授权人正常使用。</li></ul><p>其他关联属性：</p><ul><li>信息的<strong>不可否认性Non-repudiation 或抗抵赖性</strong>：指能够保证信息行为人不能否认其信息行为,无论发送方还是接收方都不能抵赖所发生过的通信</li><li>信息的<strong>可控性(Controllability)</strong>：<ul><li>鉴别（或验证）  Authentication,确认实体是它所声明的。适用于用户、进程、系统、信息等的信息可信度, 真实性（Authenticity)</li><li>审计Accountability, 确保实体的活动可被跟踪</li></ul></li><li>信息的<strong>可存活性(Survivability)</strong>：面对各种攻击或错误的情况下继续提供核心的服务,而且能够及时地恢复全部的服务</li></ul><h3 id="OSI安全体系架构"><a href="#OSI安全体系架构" class="headerlink" title="OSI安全体系架构"></a>OSI安全体系架构</h3><p>OSI安全体系结构主要包括三部分内容：</p><ul><li>安全服务</li><li>安全机制</li><li>安全攻击</li></ul><h4 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h4><p>&emsp;&emsp;安全服务：一种用来增强数据处理系统安全性和信息传递安全性的措施或服务。目的在于使用1种或多种安全机制来阻止攻击。</p><p>ISO 7498-2对 OSI规定了五个方面的安全服务：</p><ul><li>认证服务：提供关于某个实体(人或事物)身份的保证</li><li>访问控制服务：实施授权的一种方法，防止对资源的未授权使用，包括防止以未授权方式使用某一资源</li><li>数据机密性：指保护信息不泄露或不暴露给那些未授权掌握这一信息的实体。</li><li>数据完整性：确保数据的价值和存在性没有改变，针对对数据进行修改、增加、删除或重新排序等攻击行为所采用的安全服务。</li><li>非否认(不可抵赖性)服务：是指用以阻止参与某次通信交换的一方在事后否认曾经发生过本次交换这一事实。</li></ul><h4 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h4><p>安全机制：用来检测、防范安全攻击并从中恢复系统的措施。</p><p>&emsp;&emsp;安全服务与安全机制有着密切的关系。安全服务体现了安全系统的功能；而安全机制则是安全服务的实现。一个安全服务可以由多个安全机制实现；而一个安全机制也可以用于实现多个安全服务中。</p><p>ISO 7498-2确定了8类安全机制，实现安全服务</p><ul><li>加密机制（密码机制）</li><li>数字签名机制</li><li>访问控制机制</li><li>数据完整性机制</li><li>通信业务流填充机制:提供针对流量分析的保护：填充流空余位，干扰流量分析；对抗攻击者在链路上监听数据并对其进行流量和流向分析；</li><li>路由控制机制：路由改变、物理通道的选择，选择特殊的路由，保证数据安全；</li><li>认证交换机制</li><li>公证机制</li></ul><p>&emsp;&emsp;OSI安全管理活动有3类：系统安全管理、安全服务管理和安全机制管理。<br>某些普遍性安全机制可认为属于安全管理方面:</p><ul><li>安全标签 （security labels）：为某一资源命名或指定安全属性</li><li>事件检测 （event detection）：对安全相关事件的检测</li><li>审计跟踪 （security audit trail）：对系统的记录与行为进行独立的评估考查，目的是测试系统的控制是否恰当，保证与既定策略和操作的协调一致。</li><li>安全恢复 （security recovery）</li></ul><h4 id="安全威胁和攻击"><a href="#安全威胁和攻击" class="headerlink" title="安全威胁和攻击"></a>安全威胁和攻击</h4><ul><li><p>安全威胁：可能造成攻击的潜在危险</p></li><li><p>被动攻击是企图了解和利用系统信息但不影响系统的资源</p></li><li><p>被动攻击：消息内容泄露、流量攻击</p></li><li><p>主动攻击试图改变系统的资源和影响系统操作；主动攻击包含改写数据流的改写和错误数据流的添加</p></li><li>主动攻击:假冒、重放、改写消息、拒绝服务</li></ul><h2 id="网络安全威胁与攻击技术"><a href="#网络安全威胁与攻击技术" class="headerlink" title="网络安全威胁与攻击技术"></a>网络安全威胁与攻击技术</h2><h3 id="回顾-2"><a href="#回顾-2" class="headerlink" title="回顾"></a>回顾</h3><p>上次学习了网络信息安全基础，涉及内容：</p><ul><li>CIA</li><li>OSI安全体系架构<ul><li>安全服务</li><li>安全机制</li><li>安全攻击<br>本章主要涉及网络信息安全威胁和技术。</li></ul></li></ul><h3 id="网络信息安全威胁的原因"><a href="#网络信息安全威胁的原因" class="headerlink" title="网络信息安全威胁的原因"></a>网络信息安全威胁的原因</h3><ul><li>物理安全因素（物理设备和通信线路）</li><li>方案设计因素</li><li>系统的安全因素</li><li>TCP/IP协议的安全因素：网络的开放性，因特网最初的设计只考虑该网会不会因为局部故障而影响信息的传输,基本没有考虑安全问题,因此TCP/IP协议族软件本身缺乏安全性。</li><li>人的因素</li></ul><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><ul><li>预攻击：网络攻击首先以分析目标信息系统的脆弱点入手，<strong>收集各类信息</strong></li><li>攻击：设法绕过对方的安全防护措施，寻找可利用的突破口，使用某种技术手段来突破外围防线。利用该缺口在内部网络中进行层层渗透，定位存储有重要信息的服务器或工作主机，<strong>设法取得对目标对象的控制权限</strong></li><li>后攻击：<strong>植入后门、消除痕迹</strong></li></ul><hr><h3 id="常用攻击手段"><a href="#常用攻击手段" class="headerlink" title="常用攻击手段"></a>常用攻击手段</h3><ul><li>网络监听：监视网络状态、数据流以及网络上传输信息</li><li>密码破解</li><li>会话劫持(Session Hijack)：是一种结合了嗅探以及欺骗技术在内的攻击手段。<br><img src="https://s1.ax1x.com/2020/07/11/UM7yKf.png" alt=""><br>会话劫持就是在一次正常的通信过程中，黑客作为第三方参与其中，或者是在数据流（例如基于TCP的会话）里注射额外的信息，或者监听双方会话，将双方的通信模式暗中改变，即从直接联系变成有黑客联系。<br>会话劫持利用了TCP/IP工作原理来设计攻击。TCP会话劫持的攻击方式可以对基于TCP的任何应用发起攻击，如HTTP、FTP、Telnet等。</li><li>缓冲区溢出攻击</li><li>拒绝服务攻击<ul><li>计算机网络带宽攻击</li><li>连通性攻击</li></ul></li><li>泛洪攻击</li><li>Smurf 攻击：Smurf攻击通过使用将回复地址设置成受害网络的广播地址的ICMP应答请求(ping)数据包，来淹没受害主机，最终导致该网络的所有主机都对此ICMP应答请求做出答复，导致网络阻塞。</li><li>网络蠕虫攻击</li><li>木马攻击</li><li>SQL注入攻击</li></ul><h3 id="APT和社会工程学"><a href="#APT和社会工程学" class="headerlink" title="APT和社会工程学"></a>APT和社会工程学</h3><h4 id="APT-Advanced-Persistent-Threat（高级持续性威胁）"><a href="#APT-Advanced-Persistent-Threat（高级持续性威胁）" class="headerlink" title="APT Advanced Persistent Threat（高级持续性威胁）"></a>APT Advanced Persistent Threat（高级持续性威胁）</h4><ul><li>极强的隐蔽能力</li><li>很强的针对性</li><li>0day收集</li></ul><h4 id="社会工程学（Social-Engineering）"><a href="#社会工程学（Social-Engineering）" class="headerlink" title="社会工程学（Social Engineering）"></a>社会工程学（Social Engineering）</h4><ul><li>一种通过受害者心里弱点、本能反应、好奇心、信任、贪婪等心里陷阱进行诸如欺骗、伤害等危害手段，取得自身利益的手法。</li><li>业务系统都是由系统软件和人组成，系统中最薄弱的一环——人。</li></ul><h2 id="网络信息安全模型"><a href="#网络信息安全模型" class="headerlink" title="网络信息安全模型"></a>网络信息安全模型</h2><h3 id="回顾-3"><a href="#回顾-3" class="headerlink" title="回顾"></a>回顾</h3><p>上期学习了网络安全的威胁与相关技术，涉及到：</p><ul><li>安全威胁的原因</li><li>网络攻击的过程</li><li>常用手段</li><li>APT</li><li>社会工程学</li></ul><p>本章涉及网络信息安全中的网络通信模型。</p><h3 id="网络安全模型—网络通信"><a href="#网络安全模型—网络通信" class="headerlink" title="网络安全模型—网络通信"></a>网络安全模型—网络通信</h3><p><img src="https://s1.ax1x.com/2020/07/11/UM7RaQ.png" alt=""></p><ul><li>为了在开放网络环境中保护信息的传输，需要提供安全机制和安全服务：<ul><li>对发送的信息进行与安全相关的转换，例如消息加密和数字签名。</li><li>由两个主体共享的秘密信息，而对开放网络是保密的，例如密钥。</li></ul></li><li>为了完成安全的处理，常常需要可信的第三方。</li><li>一种能被通信主体使用的协议，这种协议使用安全算法和秘密信息以便获得特定的安全服务。</li></ul><hr><h3 id="网络安全模型-访问安全"><a href="#网络安全模型-访问安全" class="headerlink" title="网络安全模型-访问安全"></a>网络安全模型-访问安全</h3><p><img src="https://s1.ax1x.com/2020/07/11/UM7D2t.png" alt=""></p><p>网络访问安全模型，该模型考虑了黑客攻击、病毒与蠕虫等的非授权访问。黑客攻击可以形成两类威胁：</p><ul><li>信息访问威胁，即非授权用户截获或修改数据；</li><li>服务威胁，即服务缺陷以禁止合法用户使用。<br>病毒和蠕虫是软件攻击的两个实例，这类攻击通常是通过移动存储介质引入系统，并隐藏在有用软件中；也可通过网络接入系统。</li></ul><p>两个层次：</p><ul><li>网闸 或看门人功能，组织非授权用户访问</li><li>内部安全控制（监控）：监测有害入侵者的存在</li></ul><hr><h3 id="网络安全模型—P2DR模型"><a href="#网络安全模型—P2DR模型" class="headerlink" title="网络安全模型—P2DR模型"></a>网络安全模型—P2DR模型</h3><ul><li>P2DR模型是可量化的、可由数学证明的、基于时间的的安全模型, 包含安全策略(Policy)、防护(Protection)、检测(Detection)和响应(Response);</li><li>安全策略是P2DR安全模型的核心,所有的防护、检测、响应都是依据策略实施的;</li><li>防护主要是预防安全事件的发生,发现存在的系统脆弱性和防止意外威胁和恶意威胁;</li><li>检测是P2DR中一个非常重要的环节,是静态防护转化为动态防护的关键,动态响应和加强防护的依据,同时也是强制落实安全策略的工具;</li><li>响应在安全系统中占有重要的地位,是解决安全潜在威胁最有效的方法。</li></ul><p>安全的目标实际上就是尽可能地增大保护时间,尽量地减少检测时间和响应时间。  </p><ul><li>P2DR2 ：网络安全=风险分析（A）+安全策略（P)+系统防护（P）+实时监测（D）+实时响应（R）+灾难恢复（R）</li></ul><hr><h3 id="网络安全评估标准"><a href="#网络安全评估标准" class="headerlink" title="网络安全评估标准"></a>网络安全评估标准</h3><p>在TCSEC中，美国国防部按处理信息的等级和应采用的响应措施，将计算机安全从高到低分为：A、B、C、D四类八个级别，共27条评估准则，随着安全等级的提高，系统的可信度随之增加，风险逐渐减少。<br>四个安全等级：</p><ul><li>无保护级 </li><li>自主保护级 </li><li>强制保护级</li><li>验证保护级</li></ul><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="回顾-4"><a href="#回顾-4" class="headerlink" title="回顾"></a>回顾</h3><p>上一章学习了网络信息安全的模型，主要包括：</p><ul><li>网络通信</li><li>访问安全</li><li>P2DR模型</li></ul><p>本章主要涉及密码学。</p><h3 id="密码学基本概念"><a href="#密码学基本概念" class="headerlink" title="密码学基本概念"></a>密码学基本概念</h3><h4 id="密码学的起源和发展"><a href="#密码学的起源和发展" class="headerlink" title="密码学的起源和发展"></a>密码学的起源和发展</h4><ul><li>手工阶段</li><li>机器时代</li><li>公钥密码理论</li></ul><p>1883年Kerchoffs第一次明确提出了编码的原则：加密算法应建立在<strong>算法的公开不影响明文和密钥的安全</strong>。——成为判定密码强度的衡量标准，也成为<strong>传统密码和现代密码的分界线</strong>。</p><h4 id="密码算法的安全性"><a href="#密码算法的安全性" class="headerlink" title="密码算法的安全性"></a>密码算法的安全性</h4><ul><li>无条件安全</li><li>计算上安全</li><li>*不可攻破的密码系统</li></ul><h4 id="密码破解类型"><a href="#密码破解类型" class="headerlink" title="密码破解类型"></a>密码破解类型</h4><ul><li>唯密文</li><li>已知明文</li><li>选择明文</li><li>选择密文</li><li>选择文本</li></ul><hr><h3 id="对称密钥体系"><a href="#对称密钥体系" class="headerlink" title="对称密钥体系"></a>对称密钥体系</h3><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>在明文分组和密文分组上进行运算—通常分组长64bits，有时更长。相同的明文和相同的密钥得到相同的密文。分组密码是将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为n的组（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字序列，</p><h5 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h5><ul><li><p>混乱(Confusion)原则：为了避免密码分析者利用明文与密文之间的依赖关系进行破译，密码的设计应该保证这种依赖关系足够复杂。 通常的方法是“替换（Substitution)”。一个二进制字用其它二进制字替换,被称作  S-boxes</p></li><li><p>扩散(Diffusion)原则：为避免密码分析者对密钥逐段破译，密码的设计应该保证密钥的每位数字能够影响密文中的多位数字；同时，为了避免密码分析者利用明文的统计特性，密码的设计应该保证明文的每位数字能够影响密文中的多位数字，从而隐藏明文的统计特性。通常的方法是“换位(Permutation)”。二进制字次序被打乱，重新排序，被称作  P-boxes </p></li></ul><h5 id="Feistel密码结构"><a href="#Feistel密码结构" class="headerlink" title="Feistel密码结构"></a>Feistel密码结构</h5><p>单个循环不能提供足够的安全性，而多个循环提供的安全性高，典型的循环次数是16次循环。<br><img src="https://s1.ax1x.com/2020/07/11/UlpPtP.jpg" alt=""></p><ul><li>序列密码（流密码）<br> 作用在明文和密文的数据序列的1位（bit）或1字节（byte）上。</li></ul><h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><ul><li><p>电子密码本（ECB)<br>明文一次被处理b比特，而且明文的每一个分组都使用同一密钥加密。</p></li><li><p>密码分组链接模式（CBC)<br>加密算法的输入是当前明文分组与前一密文分组的异或；每一个分组使用同一密钥。（先异或再Encrypt）</p></li><li><p>密码反馈模式(CFB)<br>将任意分组密码转为为流密码。（密文和明文长度相等）（先encrypt再异或）</p></li><li><p>计数器模式（CTR)</p><ul><li>计数器被加密然后与明文分组异或来产生密文分组。</li><li>随着消息块的增加，计数器的值增加1</li><li>E（R，K）异或P</li></ul></li></ul><h4 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h4><h5 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h5><p>密钥56bit(64bit只有56bit有效)，明文64bit，迭代16轮，56bit密钥产生16组子密钥。</p><h5 id="2DES"><a href="#2DES" class="headerlink" title="2DES"></a>2DES</h5><p>C = EK2(EK1(P)) &lt;-&gt; P = DK1(DK2(C))</p><ul><li>中间相遇(meet-in-the-middle)攻击</li></ul><h5 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h5><p>加密-解密-加密</p><h5 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h5><ul><li>分组 16字节  128位</li><li>子秘钥 44个，每个 32位，每轮使用4个字，128位</li><li>每轮进行“字节替换”、“行移位”、“列混淆”、“轮密钥加”</li><li>10轮迭代，但是非Feistel结构</li></ul><hr><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>由种子密钥通过密钥流发生器得到的密钥流为：K=k1k2…..kn,则加密变换为：C=c1c2…..cn，其中  ci=mi⊕ki，(i=1,2,…..,n),其中m,k,c是0，1 序列，⊕表示模2加法（异或）。</p><p>流密码具有实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播等特点，因此在实际应用中，特别是专用或机密机构中保持着优势，典型的应用领域包括无线通信、外交通信。 流密码强度依赖于<strong>密钥流产生器所生成序列的随机性和不可预测性</strong>。</p><h5 id="流密码VS分组密码"><a href="#流密码VS分组密码" class="headerlink" title="流密码VS分组密码"></a>流密码VS分组密码</h5><ul><li>分组密码以一定大小作为每次处理的基本单元，而流密码则是以一个元素（一个字母或一个比特）作为基本的处理单元。</li><li>流密码是一个随时间变化的加密变换，具有转换速度快、低错误传播的优点，硬件实现电路更简单；其缺点是：低扩散（意味着混乱不够）、插入及修改的不敏感性。</li><li>分组密码使用的是一个不随时间变化的固定变换，具有扩散性好、插入敏感等优点；其缺点是：加解密处理速度慢、存在错误传播。</li><li>分组密码可以重复使用密钥，流密码则最好不要重复使用密钥。</li></ul><hr><h3 id="公钥密码和消息认证"><a href="#公钥密码和消息认证" class="headerlink" title="公钥密码和消息认证"></a>公钥密码和消息认证</h3><h4 id="完整性校验（消息认证）"><a href="#完整性校验（消息认证）" class="headerlink" title="完整性校验（消息认证）"></a>完整性校验（消息认证）</h4><h5 id="消息认证的目的"><a href="#消息认证的目的" class="headerlink" title="消息认证的目的"></a>消息认证的目的</h5><p>防止主动攻击的重要技术:</p><ul><li>验证信息的发送者是真正的，而不是冒充的，信息是<strong>真实可信</strong>的，此为<strong>信源识别</strong>；</li><li>验证信息的<strong>完整性</strong>，在传送或存储过程中未被篡改，重放或延迟，消息流的相对顺序等。</li></ul><h5 id="常规加密方法实现消息认证"><a href="#常规加密方法实现消息认证" class="headerlink" title="常规加密方法实现消息认证"></a>常规加密方法实现消息认证</h5><ul><li>发送接收双方共享一个密钥（确认身份）</li><li>消息中含有序列号、时间戳进行标记（确认完整性）</li><li>错误检测码（确认完整性）</li></ul><h5 id="非加密方法实现消息认证—消息认证码（MAC）"><a href="#非加密方法实现消息认证—消息认证码（MAC）" class="headerlink" title="非加密方法实现消息认证—消息认证码（MAC）"></a>非加密方法实现消息认证—消息认证码（MAC）</h5><p><img src="https://s1.ax1x.com/2020/07/11/UlVenf.png" alt=""></p><p>使用一个密钥生成一个固定大小的数据，并加入到消息中，称MAC或密码校验和（cryptographic checksum）,核心是一个类似于加密的算法CK()，在密钥的作用下，以报文内容作为输入，其输出值是一个较短的定长数据分组，也就是报文鉴别码MAC（带有密钥），即：<br>                       MAC ＝ CK（M）</p><p>（使用附加秘密值在进行计算的MAC就是HMAC）</p><ul><li>基于分组密码的MAC</li></ul><h5 id="非加密方法实现消息认证—单向散列函数（不带有密钥）"><a href="#非加密方法实现消息认证—单向散列函数（不带有密钥）" class="headerlink" title="非加密方法实现消息认证—单向散列函数（不带有密钥）"></a>非加密方法实现消息认证—单向散列函数（不带有密钥）</h5><p>消息摘要（Message Digests）是散列函数，它以变长的信息为输入，把其压缩成一个定长的值输出。若输入的信息被改变了，则输出的定长值（摘要）也会相应改变，提供<strong>错误检测能力</strong>。</p><h6 id="散列函数的要求"><a href="#散列函数的要求" class="headerlink" title="散列函数的要求"></a>散列函数的要求</h6><ul><li>H可以作用于一个<strong>任意长度的数据块</strong>；</li><li>散列函数H必须对任意长度的明文产生<strong>固定长度的散列值</strong>；</li><li>对任意给定的明文x ,无论是软件还是硬件实现H(x) ，计算都相对容易。</li><li>对任意给定码h，找到x满足H(x)=h具有计算不可行性；（<strong>单向性，抗原像攻击性</strong>）</li><li>对任何给定的报文M，若要寻找不等于M的报文M1 使H( M1 ) ＝ H(M) 在计算上是不可行的。——<strong>防止伪造（弱碰撞攻击性）</strong></li><li>要找到任意两个报文M和N使H(M)＝H(N)在计算上是不可行<strong>（抗强碰撞性）</strong></li></ul><blockquote><p>生日攻击(基于生日悖论):在k个人中,找一个与某人生日相同的人的概率超过0.5时,只需k&gt;183; 而在此人群中,至少有两个人生日相同的概率超过0.5,只需k&gt;23.</p></blockquote><h6 id="散列函数的安全性"><a href="#散列函数的安全性" class="headerlink" title="散列函数的安全性"></a>散列函数的安全性</h6><ul><li>密码分析：依赖于具体算法的设计缺陷，利用算法的某种性质。理想的Hash函数要求密码分析攻击所需的代价大于或等于穷举攻击所需的代价。</li><li>穷举攻击</li></ul><p>对于长度为m的Hash码，对于穷举攻击所需付出的代价分别于下表中相应量成正比.（通过生日悖论进行穷举攻击）</p><div class="table-container"><table><thead><tr><th>穷举攻击</th><th>代价</th></tr></thead><tbody><tr><td>抗原像攻击</td><td>2<sup>m&lt;/sub&gt;</td></tr><tr><td>抗弱碰撞攻击</td><td>2<sup>m&lt;/sub&gt;</td></tr><tr><td>抗强碰撞攻击</td><td>2<sup>m/2&lt;/sub&gt;</td></tr></tbody></table></div><h6 id="典型散列函数"><a href="#典型散列函数" class="headerlink" title="典型散列函数"></a>典型散列函数</h6><ul><li>MD5：合成的迭代函数，将数据分为512bit的块，生成128bit摘要</li><li>SHA：预处理与MD5相同，输出5*32bit=160bit</li><li>HMAC：用一个秘密密钥来产生和验证MAC。将散列函数和密钥结合起来产生鉴别码，称为基于散列函数的报文鉴别码HMAC<br>HMAC(K, text)= H((K  opad )， H((K  ipad) ，text))</li></ul><h5 id="Hash与MAC的区别"><a href="#Hash与MAC的区别" class="headerlink" title="Hash与MAC的区别"></a>Hash与MAC的区别</h5><p>与密钥相关的单向散列函数通常称为MAC，因此MAC需要密钥， MAC计算速度慢；<br>Hash是一种直接产生鉴别码的方法，不需要密钥，对任意长度的报文直接产生定长的鉴别码</p><hr><h4 id="公钥密码（非对称加密）"><a href="#公钥密码（非对称加密）" class="headerlink" title="公钥密码（非对称加密）"></a>公钥密码（非对称加密）</h4><p>这种方案需要两个不同的但是相关的密钥值，一个是公钥，一个是私钥。私钥总是保密的，公钥需要公开。由私钥可以计算出公钥，但由公钥难以计算出私钥。<br>公钥密码体制是基于<strong>单向陷门函数</strong>的概念。单向函数是一些易于计算但难于求逆的函数，而单向陷门函数就是在已知一些额外信息的情况下易于求逆的单向函数，这些额外信息就是所谓的陷门。</p><h5 id="公钥密码系统的应用"><a href="#公钥密码系统的应用" class="headerlink" title="公钥密码系统的应用"></a>公钥密码系统的应用</h5><ul><li>加密/解密：发送者使用接收者的公钥加密消息</li><li>数字签名：发送者使用自己的私钥签名消息，通过对消息或者小的数据块应用加密算法来签名消息</li><li>密钥交换：双方合作交换会话密钥</li></ul><p>RSA算法三种方式都适合，Diffie-Hellman算法只适合于密钥交换，DSS（数字签名标准）适合于数字签名，EIGamal适合于前两种，椭圆曲线算法三种都适合。</p><h5 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h5><p>RSA安全性基础：求两个大素数的乘积是计算上容易的，但是要分解两个大素数的积求出它的素因子是计算上困难的。</p><p>（1）取两个素数p和q（保密）；<br>（2）计算n（公开）=pq，φ(n)=(p–1)(q–1)（保密）；<br>（3）随机选取整数e，满足gcd(e，φ(n))=1（公开），即e 与φ(n)互素且小于φ(n)；<br>（4）计算d，满足de≡1 (modφ(n))（保密）。<br>利用RSA加密第一步需将明文数字化，并取长度小于log2n位的数字作明文块。<br>加密算法：　　　　　　c=E(m)≡me(mod n)<br>解密算法：　　　　　　D(c)≡cd(mod n)</p><h5 id="Diffie-hellman"><a href="#Diffie-hellman" class="headerlink" title="Diffie-hellman"></a>Diffie-hellman</h5><p><img src="https://s1.ax1x.com/2020/07/11/UlNsBD.png" alt=""><br>共享密钥K，Y<sub>a</sub>、Y<sub>b</sub>为私钥</p><p>第3类公钥系统的安全性依赖于离散对数的计算困难性。离散对数问题可细分为两类: 一类为有限域上的离散对数问题；一类为椭圆曲线上的离散对数问题。</p><p>如果p和a被窃取，则会遭受中间人攻击。</p><h5 id="EIGamal公钥密码体制"><a href="#EIGamal公钥密码体制" class="headerlink" title="EIGamal公钥密码体制"></a>EIGamal公钥密码体制</h5><p>EIGamal公钥密码体制安全性是基于有限域上计算离散对数的困难性;其认证模型形成美国数字签名标准DSS的基础</p><h5 id="椭圆曲线公钥密码体制ECC"><a href="#椭圆曲线公钥密码体制ECC" class="headerlink" title="椭圆曲线公钥密码体制ECC"></a>椭圆曲线公钥密码体制ECC</h5><p>ECC实际上是将原有的经典的加密算法通过某些运算移植到安全的椭圆曲线方程上，如D-H协议、EIGamal协议等。</p><ul><li>160bit ECC = 1024bit RSA</li><li>210bit ECC = 2048bit RSA</li><li>实现速度快,密钥尺度小</li></ul><hr><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>数字签名用来保护信息传输过程中信息的完整性(hash）和提供信息发送者的身份的确认(private key)。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>Mes = M + E(H(M), Pri<sub>a</sub>) </p><hr><h3 id="公钥密码体制VS对称密钥体制"><a href="#公钥密码体制VS对称密钥体制" class="headerlink" title="公钥密码体制VS对称密钥体制"></a>公钥密码体制VS对称密钥体制</h3><ul><li>对称加密的优点<ul><li>速度快,处理量大，适用于对应用数据的直接加密。</li><li>加密密钥长度相对较短,如40比特—-256比特。</li><li>除了加密，还可构造各种加密体制，如产生伪随机数等。</li></ul></li><li>对称加密的缺点<ul><li>密钥在双方都要一致、保密，传递较难。</li><li>大型网络中密钥量大，难以管理，一般需要KDC。</li><li>密钥需要经常更换。</li></ul></li></ul><ul><li>公钥加密的优点<ul><li>只有私钥保密，公钥公开,密钥保存安全。</li><li>网络上密钥管理不需在线，可以离线。</li><li>密钥生命周期相对较长。</li><li>许多公钥方案可以产生数字签名机制。</li></ul></li><li>公钥加密的缺点<ul><li>速度慢，处理量少，适用于密钥交换。</li><li>密钥长度相对较长。</li></ul></li></ul><hr><h3 id="密钥分配和用户认证"><a href="#密钥分配和用户认证" class="headerlink" title="密钥分配和用户认证"></a>密钥分配和用户认证</h3><h4 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h4><p>密钥管理直接原因：</p><ul><li>拥有大量的密文有助于密码分析；一个密钥使用得太多了，会给攻击者增大收集密文的机会：</li><li>假定一个密钥受到危险或用一个特定密钥的加密/解密过程被分析，则限定密钥的使用期限就相当于限制危险的发生。</li></ul><hr><h4 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h4><h5 id="基于对称密码体制的密钥分配"><a href="#基于对称密码体制的密钥分配" class="headerlink" title="基于对称密码体制的密钥分配"></a>基于对称密码体制的密钥分配</h5><h6 id="KDC"><a href="#KDC" class="headerlink" title="KDC"></a>KDC</h6><p>设立密钥分配中心（KDC）<br>定义两种密钥：</p><ul><li>会话密钥（一次性密钥，会话开始时产生，会话结束时候销毁）</li><li>永久密钥：分发会话密钥时候所用的密钥 </li></ul><p>KDC的分层可以减少主密钥的分布</p><h6 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h6><p>Kerberos：</p><ul><li>认证(authentication)</li><li>记录(accounting)</li><li>审计(audit)<br>Kerberos提供一个<strong>中心认证服务器</strong>，采用<strong>对称密码</strong>加密体制DES，不使用公开密钥加密体制，提供一个可信第三方的认证服务。<br>特点：</li><li>基于口令鉴别，但未对口令做额外保护</li><li>依赖较好的时钟同步</li><li>可适用于分布式网络</li><li>存在登陆程序被篡改的风险</li><li>口令和会话密钥的存储风险（金钥匙、银钥匙）</li></ul><h5 id="基于公开密钥体制的密钥的分配"><a href="#基于公开密钥体制的密钥的分配" class="headerlink" title="基于公开密钥体制的密钥的分配"></a>基于公开密钥体制的密钥的分配</h5><h6 id="公钥证书"><a href="#公钥证书" class="headerlink" title="公钥证书"></a>公钥证书</h6><p>用户通过公钥证书相互交换自己的公钥而无需和公钥管理机构联系。绑定实体姓名与公钥及其他属性。 </p><p>C<sub>A</sub>=E(T+ID<sub>A</sub>+PK<sub>A</sub>, SK<sub>CA</sub>)<br>T: 时间戳<br>ID<sub>A</sub>: A用户的身份标识<br>PK<sub>A</sub>: A用户的公钥<br>SK<sub>CA</sub>: CA的私钥</p><h6 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h6><ol><li>假设个体A看到B的一个证书</li><li>B的证书中含有签发该证书的CA的信息</li><li>沿着层次树往上找，可以构成一条证书链，直到根证书</li><li>验证过程：</li></ol><ul><li>沿相反的方向，从根证书开始，依次往下验证每一个证书中的签名。其中，根证书是自签名的，用它自己的公钥进行验证</li><li>一直到验证B的证书中的签名</li><li>如果所有的签名验证都通过，则A可以确定所有的证书都是正确的，如果他信任根CA，则他可以相信B的证书和公钥</li></ul><h5 id="公开加密-常规加密的密钥分配"><a href="#公开加密-常规加密的密钥分配" class="headerlink" title="公开加密+常规加密的密钥分配"></a>公开加密+常规加密的密钥分配</h5><p>用非对称加密保护对称密钥，用对称加密保护消息。</p><ul><li>结合了非对称加密的高安全性和对称加密的快速、适应性强的特点</li></ul><ol><li>A-&gt;B :E<sub>KUb</sub>[N1//IDa]</li><li>B-&gt;A :E<sub>KUa</sub>[N1//N2]</li><li>A-&gt;B :E<sub>KUb</sub>[N2]</li><li>A-&gt;B :E<sub>KUb</sub>[E<sub>KRa</sub>[Ks]]</li><li>B计算 D<sub>KUa</sub>[D<sub>KRb</sub>[E<sub>KUb</sub>[E<sub>KRa</sub>[Ks]]]]</li></ol><hr><h4 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h4><p>PKI是用公钥概念与技术来实施和提供安全服务的具有普适性的安全基础设施。PKI中最基本的元素是数字证书。</p><h5 id="交叉认证"><a href="#交叉认证" class="headerlink" title="交叉认证"></a>交叉认证</h5><p>交叉认证是一种把以前无关的CA连接在一起的有用机制，从而使得在它们各自主体群之间的安全通信成为可能。<br>两个CA安全地交换密钥信息,这样每个CA都可以有效地验证另一方密钥的可信任性,这个过程称为交叉认证;</p><h5 id="联合身份管理"><a href="#联合身份管理" class="headerlink" title="联合身份管理"></a>联合身份管理</h5><p>将身份管理扩展到多个安全域，目的是：共享数字身份。</p><p>身份管理系统要素：认证、授权、审计（3A）</p><hr><h4 id="数字水印"><a href="#数字水印" class="headerlink" title="数字水印"></a>数字水印</h4><ul><li><p>信息隐藏技术(Information Hiding)，是利用载体信息中具有随机特性的冗余部分，将秘密信息隐藏在某些宿主对象中，且信息在传输或存储过程中不被发现或引起注意，接受者获得隐藏对象后按照约定规则可读取秘密信息的技术。</p></li><li><p>数字水印技术是利用数字作品中普遍存在的冗余数据与随机性把版权信息嵌入在数字作品本身中从而起到保护数字作品版权或完整性的一种数字产品版权保护技术，目的是鉴别出非法复制和盗用的数字产品。</p></li></ul><h2 id="网络访问控制和云安全"><a href="#网络访问控制和云安全" class="headerlink" title="网络访问控制和云安全"></a>网络访问控制和云安全</h2><h3 id="回顾-5"><a href="#回顾-5" class="headerlink" title="回顾"></a>回顾</h3><p>上一次学习了密码学与密钥分配的内容，涉及到：</p><ul><li>密码学的发展史</li><li>密码算法的安全性</li><li>对称加密<ul><li>分组密码<ul><li>电子密码本</li><li>密码分组链接</li><li>密码反馈</li><li>计数器</li></ul></li><li>流密码</li></ul></li><li>公钥加密<ul><li>加解密</li><li>密钥交换</li><li>数字签名</li></ul></li><li>密钥分配<ul><li>基于对称加密的密钥分发（KDC、Kerberos）</li><li>基于非对称加密的密钥分发（公钥证书）</li><li>基于对称加密与非对称加密的密钥分发</li></ul></li><li>PKI<ul><li>交叉验证</li><li>联合身份管理</li></ul></li></ul><p>本章涉及网络访问控制和云安全的内容。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><h4 id="访问控制的定义"><a href="#访问控制的定义" class="headerlink" title="访问控制的定义"></a>访问控制的定义</h4><p>访问控制是通过某种途径<strong>显式地准许或限制访问能力及范围</strong>的一种方法。</p><h4 id="访问控制的基本目标"><a href="#访问控制的基本目标" class="headerlink" title="访问控制的基本目标"></a>访问控制的基本目标</h4><ul><li>防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的<strong>访问</strong><ul><li>非法用户进入系统</li><li>合法用户对系统资源的非法使用</li></ul></li><li>允许被授权的主体对某些客体的访问、拒绝向非授权的主体提供服务</li></ul><h4 id="访问控制的实体"><a href="#访问控制的实体" class="headerlink" title="访问控制的实体"></a>访问控制的实体</h4><ul><li>主体</li><li>客体</li><li>授权</li></ul><hr><h3 id="网络访问控制措施"><a href="#网络访问控制措施" class="headerlink" title="网络访问控制措施"></a>网络访问控制措施</h3><ul><li>IEEE802.1X：链路层协议，它在一个端口被分配IP之前执行授权</li><li>VLAN：企业网络在逻辑上被分割成为一系列虚拟的LAN</li><li>防火墙: 允许或者拒绝企业主机与外部用户的网络流量来提供一种形式的网络访问控制。</li><li>DHCP:动态主机配置协议，给主机动态分配IP</li><li>EAP</li></ul><h4 id="可扩展认证协议EAP"><a href="#可扩展认证协议EAP" class="headerlink" title="可扩展认证协议EAP"></a>可扩展认证协议EAP</h4><p>EAP通常直接运行在数据链路层，目前支持EAP协议的网络有PPP、有线网（EAPOL，802.1X协议）、无线网络（即802.11 WLAN）、TCP、UDP</p><blockquote><ul><li>步骤1：请求方向认证方发送EAPOL-Start消息</li><li>步骤2：认证方向请求方发送EAP-Request/Identity消息</li><li>步骤3：请求方给认证方回复EAP-Response/Identity消息，并由认证方转发给认证Server</li><li>步骤4：认证Server给认证方发送一个Radius格式的质询（challenge）消息，认证方将其重新封装为EAPOL发送给请求方（ 支持单向和双向认证，单向即Server验证请求方的身份；双向即双方都验证对方身份，无线中采用双向避免中间人攻击）</li><li>步骤5：请求方向认证方回复质询消息，并由认证方转发给认证Server</li><li>步骤6：如果请求方提供的身份凭证无误，认证Server将返回Success的消息给请求方，并由认证方转发给请求方，认证方根据认证 结果给予请求方访问网络资源的权限。</li></ul></blockquote><h4 id="基于端口的认证策略—IEEE-802-1"><a href="#基于端口的认证策略—IEEE-802-1" class="headerlink" title="基于端口的认证策略—IEEE 802.1"></a>基于端口的认证策略—IEEE 802.1</h4><p>目的：确定一个端口是否可用。</p><p>一个端口，认证前处于“非授权”状态。<br>如果认证成功，就“打开”，端口切换到“授权”状态，允许所有的报文通过；如果认证不成功，就保持“关闭”，处于“非授权”状态，只允许802.1X的认证报文EAPOL（EAP OVER LAN)和广播报文通过。</p><hr><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><p>“云”中的资源在使用者看来是无限可以扩展的，并且可以随时获取、按需伸缩、按需使用。</p><h4 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h4><ul><li>广泛的网络访问：服务能力通过网络提供，支持各种标准接入手段，</li><li>快速的可伸缩性：快速扩容，可弹性提供服务</li><li>可度量的服务：具备一种可计量的能力，控制及优化资源，可以监视和控制资源</li><li>按需自助服务：用户可以在需要时自动配置计算能力</li><li>资源共享：计算资源汇集到资源池中，将不同的物理和虚拟资源动态分配给多个消费者使用。</li></ul><h4 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h4><ul><li>软件即服务（SaaS, Software as a Service)</li><li>平台即服务（PaaS)</li><li>基础设施即服务（IaaS)</li></ul><h4 id="云安全风险"><a href="#云安全风险" class="headerlink" title="云安全风险"></a>云安全风险</h4><ul><li>滥用和恶意使用云计算算力</li><li>不安全的API</li><li>恶意的内部人员</li><li>共享技术的安全风险</li><li>数据丢失或泄露：不合适的访问控制、弱加密</li><li>账户或服务劫持、流量劫持：证书盗用、密码泄露、流量拦截、改道发送数据等</li><li>其他：非标准私有云和公有云；缺少持续性风险管理和符合性监控；不完整的身份管理；</li></ul><h2 id="web安全和传输层安全"><a href="#web安全和传输层安全" class="headerlink" title="web安全和传输层安全"></a>web安全和传输层安全</h2><h3 id="回顾-6"><a href="#回顾-6" class="headerlink" title="回顾"></a>回顾</h3><p>上一次学习了访问控制的安全相关内容和云计算基础，涉及：</p><ul><li>访问控制<ul><li>防止未授权用户的访问，防止授权用户的非法操作</li><li>EAP</li><li>IEEE802.1</li></ul></li><li>云计算<ul><li>服务模式</li><li>安全风险</li></ul></li></ul><p>本章主要学习Web安全和传输层安全。</p><h3 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h3><h4 id="Web安全威胁"><a href="#Web安全威胁" class="headerlink" title="Web安全威胁"></a>Web安全威胁</h4><p>将威胁进行分组的方法之一是将其分为主动攻击和被动攻击：</p><ul><li>主动攻击：包括对其它用户的冒充、修改客户服务器之间传递的消息流量、木马，以及修改Web站点存储的信息等完整性攻击；</li><li>被动攻击：包括对在浏览器和服务器之间的数据流的窃听、对Web站点的施加了访问控制措施的信息的未授权访问、盗窃信息等机密性攻击；<br>拒绝服务攻击等可用性攻击；</li></ul><p>将威胁进行分组的方法之二是根据安全威胁所发生的位置：</p><ul><li>Web服务器</li><li>Web浏览器</li><li>浏览器和服务器之间的网络流量。</li></ul><p>根据威胁的后果，可分为：</p><ul><li>对信息完整性的攻击</li><li>对信息保密性的攻击</li><li>拒绝服务攻击</li><li>对身份认证攻击。</li></ul><h4 id="基于TCP-IP协议的网络安全体系结构"><a href="#基于TCP-IP协议的网络安全体系结构" class="headerlink" title="基于TCP/IP协议的网络安全体系结构"></a>基于TCP/IP协议的网络安全体系结构</h4><p><img src="https://s1.ax1x.com/2020/07/12/U1amg1.png" alt=""></p><hr><h3 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h3><p>TCP/IP协议本身非常简单，没有加密、身份认证等安全特性，因此必须在TCP之上建立一个安全通信层次。</p><h4 id="SSL-Secure-Sockets-Layer-协议"><a href="#SSL-Secure-Sockets-Layer-协议" class="headerlink" title="SSL(Secure Sockets Layer)协议"></a>SSL(Secure Sockets Layer)协议</h4><p>SSL是Netscape提出的一个在Internet上提供秘密通信的安全协议；为Client/Server应用提供可靠连接方式下的防窃听、防篡改、防信息伪造的通信。SSL协议使用<strong>通讯双方的证书</strong>，在通讯双方间建立一条安全的、可信任的通讯通道。</p><ul><li>设计目标：在TCP基础上提供一种<strong>可靠的端到端</strong>的安全服务，其服务对象一般是<strong>WEB应用</strong>，通过<strong>在两个实体之间建立一个共享的密钥</strong>，提供机密性服务。</li></ul><p><img src="https://s1.ax1x.com/2020/07/12/U1a5aF.png" alt=""></p><h5 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h5><ul><li>SSL连接是一个<strong>双向连接</strong>，每个连接都和一个SSL会话相关。SSL连接成功后，可以进行安全保密通信。</li><li>SSL会话由<strong>握手协议</strong>创建，定义了一系列相应的安全参数，最终建立客户机和服务器之间的一个关联。对于每个SSL连接，可利用SSL会话避免对新的安全参数进行代码繁多协商。</li><li>每个SSL会话都有许多与之相关的状态。一旦建立了会话，就有一个当前操作状态。</li></ul><h5 id="SSL记录协议层-SSL-Record-Protocol-layer"><a href="#SSL记录协议层-SSL-Record-Protocol-layer" class="headerlink" title="SSL记录协议层(SSL Record Protocol layer)"></a>SSL记录协议层(SSL Record Protocol layer)</h5><ul><li><strong>为高层协议提供</strong>基本的安全<strong>服务</strong>：<strong>机密性和完整性</strong>服务。</li><li>记录层<strong>封装各种高层协议</strong>。 </li><li>具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</li></ul><h5 id="SSL握手协议层-SSL-HandShake-Protocol-layer"><a href="#SSL握手协议层-SSL-HandShake-Protocol-layer" class="headerlink" title="SSL握手协议层(SSL HandShake Protocol layer)"></a>SSL握手协议层(SSL HandShake Protocol layer)</h5><p>用于SSL管理信息的交换，允许应用协议传送数据之前相互验证，协商加密算法和生成密钥等。<br>包括：<br>SSL握手协议（SSL HandShake Protocol）；<br>SSL密码参数修改协议（SSL Change Cipher Spec Protocol）；<br>应用数据协议（Application Data Protocol）；<br>SSL告警协议（SSL Alert Protocol）。 </p><h4 id="TLS传输层安全"><a href="#TLS传输层安全" class="headerlink" title="TLS传输层安全"></a>TLS传输层安全</h4><ul><li>TLS（Transport Layer Security） 1.0 （RFC 5246） = SSLv3.l</li><li>TLS:基于会话的加密和认证的Internet协议，为通信的两个实体提供了一个安全的通道。</li><li>TLS的主要目标是使得SSL更安全，并使协议的规范更精确和完善</li><li>TLS与SSL3.0之间存在着显著差别，主要是它们所支持的加密算法不同， TLS与SSL3.0不能互操作。</li></ul><h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><ul><li>HTTPS = HTTP + SSL</li><li>标准端口443</li><li>HTTPS对传输的数据进行加密，以及需要CA机构签名的SSL证书</li></ul><h4 id="SSH-Secure-Shell"><a href="#SSH-Secure-Shell" class="headerlink" title="SSH(Secure Shell)"></a>SSH(Secure Shell)</h4><ul><li>用于在非安全网络上提供安全的远程登录、交互式会话安全和其他安全网络服务，使用端口22。</li><li>SSH提供机密性、完整性服务、身份认证服务</li><li>可以取代传统的Telnet、FTP等，在本地主机和远程服务器间设置加密通道</li></ul><h2 id="无线网络安全"><a href="#无线网络安全" class="headerlink" title="无线网络安全"></a>无线网络安全</h2><h3 id="回顾-7"><a href="#回顾-7" class="headerlink" title="回顾"></a>回顾</h3><p>上次学习了Web安全和传输层安全，主要涉及：</p><ul><li>Web安全<ul><li>基于TCP/IP协议的网络安全体系架构</li></ul></li><li>传输层安全<ul><li>SSL<ul><li>记录协议层</li><li>握手协议层</li></ul></li><li>TLS</li><li>HTTPS</li><li>SSH</li></ul></li></ul><p>本章学习无线网络安全。</p><h3 id="无线网络安全-1"><a href="#无线网络安全-1" class="headerlink" title="无线网络安全"></a>无线网络安全</h3><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><ul><li>基站</li><li>WiFi热点</li><li>无线网和有线网的接入点AP<br>将多个无线用户互连起来组成一个无线局域网，将无线用户接入有线局域网</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>开放性</li><li>移动性</li><li>动态性（资源）</li><li>不确定性（信道）</li></ul><h4 id="安全威胁"><a href="#安全威胁" class="headerlink" title="安全威胁"></a>安全威胁</h4><ul><li>窃听、截取和监听</li><li>主动式攻击：欺骗(IP\MAC）、非授权访问、网络接管、篡改、DOS攻击、恶意代码、隐蔽通道</li><li>潜在的法律问题</li></ul><h4 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h4><ul><li>安全无线传输</li><li>安全无线AP</li><li>安全的无线网络</li></ul><hr><h3 id="移动设备安全"><a href="#移动设备安全" class="headerlink" title="移动设备安全"></a>移动设备安全</h3><h4 id="WAP-Wireless-Application-Protocol-无线应用协议"><a href="#WAP-Wireless-Application-Protocol-无线应用协议" class="headerlink" title="WAP(Wireless Application Protocol,无线应用协议)"></a>WAP(Wireless Application Protocol,无线应用协议)</h4><p>WAP是一个使移动用户使用无线设备（例如移动电话）随时使用互联网的信息和服务的开放的规范。<br>主要意图：使得无线终端设备能够获得类似网页浏览器的功能</p><h4 id="安全威胁-1"><a href="#安全威胁-1" class="headerlink" title="安全威胁"></a>安全威胁</h4><ul><li>缺乏物理安全控制</li><li>不可信移动设备</li><li>不可信网络</li><li>未知来源的app</li><li>不安全内容</li><li>与其他系统的相互作用</li><li>定位服务</li></ul><h4 id="安全措施-1"><a href="#安全措施-1" class="headerlink" title="安全措施"></a>安全措施</h4><ul><li>设备安全</li><li>数据流安全与边界安全<ul><li>数据流加密（VPN）</li><li>身份认证</li><li>边界安全（firewall+IDS）</li></ul></li></ul><hr><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>802.11 只涉及介质访问控制(MAC)层和物理层</p><ul><li>LLC子层:保证站点之间数据传输的正确性，流量控制、差错控制</li><li>MAC子层:解决多个站点对共享信道的访问，寻址、差错检测、媒介控制，组装拆封帧</li></ul><h5 id="介质访问特点"><a href="#介质访问特点" class="headerlink" title="介质访问特点"></a>介质访问特点</h5><ul><li>信息传输特点<ul><li>一个无线用户发出的电磁波会向各个方向扩散</li><li>一定范围内的所有无线用户共享传输信道。</li></ul></li><li>MAC层采用CSMA/CA （载波侦听多点接入／避让机制）协议<ul><li>CSMA：与在传统以太网中的含义相同</li><li>CA：冲突避免（先预约而非发送后检测）</li></ul></li></ul><h5 id="802-11网络组成模型"><a href="#802-11网络组成模型" class="headerlink" title="802.11网络组成模型"></a>802.11网络组成模型</h5><ul><li>无线局域网最小的组成块：<strong>基本服务单元BSS</strong>(Basic Service Set)<br>一个基本服务集 BSS 包括一个接入点AP(基站)和若干个移动站(STA），所有的站在本 BSS 以内都可以直接通信，但在和本 BSS 以外的站通信时 ，都要通过本 BSS 的AP。</li><li><strong>分布式系统（Distributed System, DS)</strong>:通过固定基础设施把多个BSS连接起来而形成的扩展服务集Extended Service Set (ESS)</li><li>一个基本服务集可以是孤立的，也可通过接入点 AP连接到一个分布式系统 DS (Distribution System)，然后再接入到另一个基本服务集，构成扩展的服务集ESS (Extended Service Set)。</li><li>ESS 还可通过叫做门户(portal)为无线用户提供到非 802.11 无线局域网（例如，有线连接的因特网）的接入。门户的作用就相当于一个网桥。</li><li>移动站 A 从某一个基本服务集漫游到另一个基本服务集（到 A 的位置），仍可保持与另一个移动站 B 进行通信。</li></ul><h5 id="提供2类9种服务"><a href="#提供2类9种服务" class="headerlink" title="提供2类9种服务"></a>提供2类9种服务</h5><ul><li><p>分配服务（Distribution service）：由基站提供，管理BSS内成员关系，与其它BSS中的站进行交互</p><ul><li>建立联系（association）：移动节点进入一个BSS后使用该服务与基站建立联系</li><li>解除联系（disassociation）：节点关机或离开前与基站解除联系</li><li>重建联系（reassociation）：节点使用该服务改变首选基站</li><li>分发（distribution）：基站转发收到的帧。</li><li>整合（integration）：将802.11格式转换成目的网络要求的格式</li></ul></li><li><p>站服务（station services）：在联系建立起来后使用，用于管理BSS内的活动。</p><ul><li>身份鉴别（authentication）：基站验证移动节点的身份。</li><li>解除鉴别（deauthentication）：一个此前经过认证的节点离开网络前解除认证。</li><li>保密（privacy）：处理数据的加密和解密。</li><li>数据传递（data delivery）：数据收发服务，802.11提供的<strong>数据传输服务是不可靠</strong>的。</li></ul></li></ul><h5 id="安全服务-1"><a href="#安全服务-1" class="headerlink" title="安全服务"></a>安全服务</h5><ul><li><p>服务集标识符(SSID)匹配<br>对AP设置不同的SSID，无线工作站必须出示正确的SSID才能访问AP<br>问题：AP周期地广播信标帧(包含SSID)，信标帧在发送时没有进行任何方式的保护，导致黑客很容易地识别出SSID</p></li><li><p>WEP（有线对等保密）<br>用于在无线局域网中<strong>保护链路层数据</strong>。WEP使用40位钥匙，采用RSA开发的RC4对称加密算法，在链路层加密数据。WEP加密采用静态的保密密钥，各无线工作站使用相同的密钥访问无线网络；采用认证 ，防止未授权用户对网络进行访问)</p><blockquote><p>WPA是继承了WEP基本原理而又解决了WEP缺点的一种新技术</p><ul><li>根据通用密钥，配合表示电脑MAC地址和分组信息顺序号的编号，分别为每个分组信息生成不同的密钥，然后与WEP一样将此密钥用于RC4加密处理。通过这种处理，所有客户端的所有分组信息所交换的数据将由各不相同的密钥加密而成。无论收集到多少这样的数据，要想破解出原始的通用密钥几乎是不可能的</li><li>追加了防止数据中途被篡改的数据完整性校验功能和认证功能</li></ul></blockquote></li><li><p>物理地址(MAC)过滤<br>每个无线工作站的无线网卡都有唯一的物理地址，类似以太网物理地址。可以在AP中建立允许访问的MAC地址列表</p></li></ul><h4 id="802-11i"><a href="#802-11i" class="headerlink" title="802.11i"></a>802.11i</h4><h5 id="IEEE-802-11i-操作过程"><a href="#IEEE-802-11i-操作过程" class="headerlink" title="IEEE 802.11i 操作过程"></a>IEEE 802.11i 操作过程</h5><ul><li>第一阶段：发现：站点连接访问接入点，</li><li>第二阶段：认证（在802.11i的认证中，涉及三个核心协议：802.1x、EAP、RADIUS）：站点和访问服务器互相证明身份，</li><li>第三阶段：密钥管理（产生与配送）</li><li>第四阶段：保密数据传输：数据帧在站点和终端站点间通过访问接入点进行交换，安全数据传输只在站点和访问接入点之间，不能确保端到端的安全</li><li>第五阶段：终止连接</li></ul><h6 id="密钥管理-1"><a href="#密钥管理-1" class="headerlink" title="密钥管理"></a>密钥管理</h6><p>要通过四次握手完成以下任务：STA和AP要确认PMK，产生新的PTK，确认数据加密与完整性检验方法。<br>PMK应用伪随机函数PRF导出PTK，计算TKIP的PTK时使用PRF-512，计算AES的PTK时使用PRF-384，函数PRF中的参数AA和SA分别是认证者和申请者的MAC地址，SNonce和ANonce分别是申请者和认证者发出的现时当前值。</p><ul><li>AP-&gt;STA: Anonce</li><li>STA-&gt;AP: Snonce，带有MIC</li><li>AP-&gt;STA: 是否使用一对一密钥，带有MIC</li><li>STA响应</li></ul><h6 id="暂时密钥集成协议TKIP"><a href="#暂时密钥集成协议TKIP" class="headerlink" title="暂时密钥集成协议TKIP"></a>暂时密钥集成协议TKIP</h6><p>当WEP被攻破的时候，已安装的数百万个系统突然失去安全，需要一种方案解决这一问题。但这些系统的硬件不能支持AES-CCMP。因此，设计者们寻找到一种既能够克服WEP的缺陷，又能利用现有的硬件的方法，这就是TKIP 。</p><h6 id="CCMP协议"><a href="#CCMP协议" class="headerlink" title="CCMP协议"></a>CCMP协议</h6><ul><li>CCMP是围绕AES建立的安全协议，称为计数器模式+密码块链认证码协议（ Counter Mode with Cipher Block Chaining MAC Protocol，CCMP）。</li><li>CCMP能提供高可靠的安全性，因为它是独立的设计，不是妥协的产物。</li><li>使用AES-CBC-MAC来计算消息完整性校验值</li><li>使用AES-CTR密码块模式来进行数据加密</li></ul><h2 id="电子邮件安全"><a href="#电子邮件安全" class="headerlink" title="电子邮件安全"></a>电子邮件安全</h2><h3 id="回顾-8"><a href="#回顾-8" class="headerlink" title="回顾"></a>回顾</h3><p>上次学习了无线安全，涉及到：</p><ul><li>无线安全</li><li>移动设备安全</li><li>IEEE 802.11<ul><li>网络组成模型</li><li>2类9种服务</li><li>安全服务</li></ul></li><li>IEEE 802.11i<ul><li>发现、认证、密钥管理、加密传输、终止</li><li>密钥管理四次握手</li><li>TKIP</li><li>CCMP</li></ul></li></ul><p>本章学习电子邮件安全。</p><h3 id="电子邮件安全-1"><a href="#电子邮件安全-1" class="headerlink" title="电子邮件安全"></a>电子邮件安全</h3><ul><li>端到端的安全电子邮件技术: PGP,  S/MIME (Multipurpose Internet Mail Extensions),使用密码技术对身份进行识别，对信息加密</li><li>传输层的安全电子邮件技术: SSL SMTP, SSL POP(在SSL建立的安全传输通道上运行SMTP、POP）支持认证,VPN和其他IP通道技术等使用</li><li>增强邮件服务器的安全与可靠性:防垃圾邮件网关、邮件过滤网关、防病毒网关等；加强认证和访问控制，及时更新补丁修补漏洞。</li></ul><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><h4 id="PGP提供的服务"><a href="#PGP提供的服务" class="headerlink" title="PGP提供的服务"></a>PGP提供的服务</h4><ul><li>认证</li><li>保密</li><li>压缩</li><li>电子邮件兼容性</li><li>分段和重组</li></ul><h4 id="密钥环"><a href="#密钥环" class="headerlink" title="密钥环"></a>密钥环</h4><p>PGP使用四种密钥：</p><ul><li>一次性会话密钥</li><li>公钥</li><li>私钥</li><li>基于对称密钥（口令短语）的口令。</li></ul><p>PGP在每一个节点上提供一对数据结构：<br>存储该节点拥有的公钥/私钥对；    （私钥环）（依赖于用户口令的安全性）<br>存储本节点知道的其他用户的公钥；（公钥环）</p><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://s1.ax1x.com/2020/07/12/U3kAjP.png" alt=""></p><h4 id="SMTP的局限性"><a href="#SMTP的局限性" class="headerlink" title="SMTP的局限性"></a>SMTP的局限性</h4><ul><li>不能传输可执行文件或其它二进制对象；</li><li>SMTP限于7比特的ASCII码，不能传递包括国际语言字符的文本数据；</li><li>SMTP可能拒绝超过一定大小的邮件消息；</li><li>SMTP网关在ASCII码和EBCDIC码之间转换时没有使用一致的映射；</li><li>不能处理 包含在X.400消息中的非文本数据；</li><li>RFC821中定义的SMTP标准和SMTP实现不完全一致；</li></ul><hr><h3 id="S-MIME"><a href="#S-MIME" class="headerlink" title="S/MIME"></a>S/MIME</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ul><li>数据加密（对称加密消息，非对称加密密钥）</li><li>数据签名</li><li>数据的干净签名</li><li>数据嵌套使用签名（先签名后加密或先加密后签名）</li></ul><hr><h3 id="DKIM-DomainKeys-Identified-Mail-域名密钥识别邮件标准"><a href="#DKIM-DomainKeys-Identified-Mail-域名密钥识别邮件标准" class="headerlink" title="DKIM(DomainKeys Identified Mail,域名密钥识别邮件标准)"></a>DKIM(DomainKeys Identified Mail,域名密钥识别邮件标准)</h3><p>DKIM让企业把加密签名插入到发送的电子邮件中，然后把该签名与域名关联起来。</p><p>DKIM 的基本工作原理同样是基于传统的密钥认证方式，产生公钥(public key)和私钥(private key)，公钥将会存放在 DNS 中，而私钥会存放在寄信服务器中。</p><hr><h3 id="传输层的安全电子邮件技术"><a href="#传输层的安全电子邮件技术" class="headerlink" title="传输层的安全电子邮件技术"></a>传输层的安全电子邮件技术</h3><p>通过对信头进行加密处理后进行传递。</p><ul><li>利用SSL SMTP和SSL POP</li><li>利用VPN或者其他的IP通道技术，将所有的TCP/IP传输封装起来，当然也就包括了电子邮件。</li></ul><h2 id="IP安全"><a href="#IP安全" class="headerlink" title="IP安全"></a>IP安全</h2><h3 id="回顾-9"><a href="#回顾-9" class="headerlink" title="回顾"></a>回顾</h3><p>上次学习了电子邮件安全，涉及：</p><ul><li>PGP<ul><li>认证、加密、压缩、电子邮件兼容性、分段和重组</li></ul></li><li>S/MIME</li><li>DKIM<ul><li>域名与签名联系</li></ul></li><li>传输层邮件安全<ul><li>SSL、VPN</li></ul></li></ul><p>本章学习IP安全。</p><h3 id="IP安全背景"><a href="#IP安全背景" class="headerlink" title="IP安全背景"></a>IP安全背景</h3><p>Everything over IP(TCP/IP, VOIP…)，但是IP不能提供安全性。<br>IP协议本质上就是不安全的。</p><ul><li>窃听：明文形式</li><li>篡改：修改内容和校验和</li><li>IP欺骗：假冒IP包中声明的IP</li><li>重放</li></ul><hr><h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>IPSec是随着IPv6的制定而产生的，IPSec对IPV4是可选的，对IPV6是必须的，IPSec由三种机制共同保障：</p><ul><li>认证</li><li>信息机密性</li><li>密钥管理<br>IPSec实现两个基本目标：</li><li>保护IP数据包安全；</li><li>为抵御网络攻击提供防护措施。</li></ul><h4 id="安全功能和服务"><a href="#安全功能和服务" class="headerlink" title="安全功能和服务"></a>安全功能和服务</h4><ul><li>访问控制</li><li>无连接完整性</li><li>数据源认证</li><li>拒绝重放数据包</li><li>保密性（加密）</li><li>受限制的流量保密性</li></ul><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>两大部分，三类协议构成IPSec：<br>AH(IP认证头) , ESP(IP封装安全载荷)；密钥协商及交换协议： IKE</p><ul><li>AH 提供认证和数据完整性，ESP实现通信保密</li><li>IKE 定义了通信实体间进行身份认证、创建安全关联SA、协商加密算法以及生成共享会话密钥的方法</li></ul><p>两种操作模式：</p><ul><li>传输模式（主机与主机的直接通信）</li><li>隧道模式（常用于关联到多台主机的网络访问连入设备间使用)</li></ul><p>安全关联SA （Security Association）：是通信对等方对某些要素的一种协定<br>两个重要数据库：安全策略数据库SPD，安全关联数据库SAD<br>使用鉴别和加密算法</p><h4 id="工作模式-1"><a href="#工作模式-1" class="headerlink" title="工作模式"></a>工作模式</h4><ul><li>传输模式<ul><li>传输模式保护的是<strong>IP载荷</strong>。 </li><li>传输模式通常应用于主机之间端对端通信，该模式要求主机支持IPSec。</li></ul></li><li>隧道模式 <ul><li>隧道模式保护的是<strong>整个IP包</strong>。</li><li>遂道就就是把一个包封装在另一个新包里面，整个源数据包作为新包的载荷部分，并在前面添加一个新的IP对。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。</li><li>被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为隧道。一旦到达网络终点，数据将被解包并转发到最终目的地。</li><li>隧道模式应用于网关模式中，即在主机的网关（防火墙、路由器）上加载IPSec。</li></ul></li></ul><h4 id="安全关联SA"><a href="#安全关联SA" class="headerlink" title="安全关联SA"></a>安全关联SA</h4><ul><li>AH和ESP两个协议都使用SA来保护通信，而IKE的主要功能就是在通信双方协商SA。当一个SA协商完成后，两个对等方都在其安全关联数据库(SAD)中存储该SA参数。</li><li>SA决定了保护什么、如何保护以及谁来保护。</li><li>SA是一个单向的逻辑链接，通常成对出现</li><li>IPSec 需要建立两个SA，一个用于入站通信，另一个用于出站通信，两个SA构成了一个SA束（SA Bundle）。</li></ul><p>安全关联有哪些组合？</p><ul><li>实现IPsec终端系统提供所有的安全</li><li>仅在安全网关之间提供安全性，主机没有实现IPsec</li><li>在情况二的基础上实现端对端安全</li><li>为互联网到达组织的防火墙然后获得在防火墙后面特定的工作站和服务器的访问权限的远程主机提供支持。远程主机和防火墙之间仅需要隧道模式</li></ul><h4 id="IKE密钥两阶段协商"><a href="#IKE密钥两阶段协商" class="headerlink" title="IKE密钥两阶段协商"></a>IKE密钥两阶段协商</h4><ul><li>阶段1协商：主模式交换和野蛮模式交换<br>ISAKMP通信双方建立一个ISAKMP SA，即用于保护双方后面的协商通信的一个协定，在通信双方建立一个已经通过身份验证和安全保护的通道，商定如何<strong>保护后面的协商过程</strong>；<br>用这个ISAKMP SA为其它安全协议(如AH和ESP)建立SA的协商。</li><li>阶段2协商：快速模式交换<br>利用第一阶段建立的通道,<strong>用于为其它安全协议</strong>，如像AH，ESP等协议或者是任何其它的需要密钥信息和参数协商的协议或服务建立SA,协商安全服务。<br>一个阶段1的SA可用于建立多个阶段2的SA，此SA将被相应的安全协议用于保护数据或者消息的交换</li></ul><p>两阶段协商作用：</p><ul><li>第一阶段的开销可以分摊到多个第二阶段中，这允许多个SA建立在同样的ISAKMP SA基础上</li><li>第一阶段商定的安全服务可以为第二阶段提供安全特性</li><li>两阶段分开，提供管理上的便利</li></ul><h4 id="Oakley密钥确定协议和ISAKMP"><a href="#Oakley密钥确定协议和ISAKMP" class="headerlink" title="Oakley密钥确定协议和ISAKMP"></a>Oakley密钥确定协议和ISAKMP</h4><p>Oakley密钥确定协议：它提供了额外的安全性，Oakley的通用性在于它没有规定任何特殊的格式；同时为IKE提供了一种模式。<br>ISAKMP：它为互联网密钥管理（IKE）提供了一个框架，并提供了特定的协议支持，包括格式和安全属性的协商。</p><h4 id="IPSec优点"><a href="#IPSec优点" class="headerlink" title="IPSec优点"></a>IPSec优点</h4><ul><li>IPSec<strong>在传输层之下</strong>，对于应用程序来说是<strong>透明</strong>的</li><li>保证因特网上各分支办公点的安全连接。 </li><li>保证因特网上远程访问的安全。 </li><li>通过外部网或内部网建立与合作伙伴的联系。 </li><li>提高了电子商务的安全性。 </li></ul><h2 id="IDS-amp-firewall"><a href="#IDS-amp-firewall" class="headerlink" title="IDS &amp; firewall"></a>IDS &amp; firewall</h2><h3 id="回顾-10"><a href="#回顾-10" class="headerlink" title="回顾"></a>回顾</h3><p>上一次学习了IPSec，涉及到：</p><ul><li>两类3种协议<ul><li>AH IP认证头，ESP IP封装安全载荷</li><li>IKE 密钥协商与交换 两阶段协商</li></ul></li><li>模式<ul><li>隧道模式 IP包</li><li>传输模式 IP载荷</li></ul></li><li>安全关联SA</li><li>数据库<ul><li>SPD</li><li>SAD</li></ul></li></ul><p>本章学习IDS、firewall。</p><h3 id="入侵检测模型"><a href="#入侵检测模型" class="headerlink" title="入侵检测模型"></a>入侵检测模型</h3><ul><li>（统计分析）异常检测模型（Anomaly Detection ):基于行为的检测技术<ul><li>阈值检测</li><li>用户轮廓(Profile)</li></ul></li><li>（模式匹配）误用检测模型（Misuse Detection)：基于知识（或规则）的检测技术或者模式匹配检测技术</li><li>完整性分析技术</li></ul><h4 id="信息响应"><a href="#信息响应" class="headerlink" title="信息响应"></a>信息响应</h4><ul><li>主动响应：检测到后采取措施阻断攻击</li><li>被动响应：检测到后只报告信息</li></ul><h5 id="蜜罐技术"><a href="#蜜罐技术" class="headerlink" title="蜜罐技术"></a>蜜罐技术</h5><ul><li>一个高级的网络节点可以采用路由器把攻击者引导到一个经过特殊装备的系统（诱骗系统）上，这种系统被成为蜜罐；</li><li>蜜罐是一种欺骗手段，它可以用于错误地诱导攻击者转移对重要系统的访问，也可以用于收集攻击信息，以改进防御能力；</li></ul><h5 id="入侵追踪"><a href="#入侵追踪" class="headerlink" title="入侵追踪"></a>入侵追踪</h5><ul><li>基于主机的：要求信任追踪系统的每个节点</li><li>基于网络的</li></ul><hr><h3 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h3><h4 id="保护口令"><a href="#保护口令" class="headerlink" title="保护口令"></a>保护口令</h4><ul><li>hash</li><li>访问控制</li></ul><hr><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙是建立在<strong>内外网络边界</strong>上的过滤封锁机制，是一种用于保护本地系统或者网络不受基于网络的安全威胁的有效方法。</p><h4 id="四种控制机制"><a href="#四种控制机制" class="headerlink" title="四种控制机制"></a>四种控制机制</h4><ul><li>服务控制</li><li>方向控制</li><li>用户控制</li><li>行为控制</li></ul><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li>包过滤：在网络层根据数据包中包头信息选择</li><li>应用网关</li><li>代理</li><li>状态检测：不限于包过滤防火墙的3/4层的过滤，又不需要应用层网关防火墙的5层过滤，既提供了比包过滤防火墙更高的安全性和更灵活的处理，也避免了应用层网关防火墙带来的速度降低的问题。</li></ul><blockquote><ul><li>应用级网关（代理服务器）：<strong>应用层</strong>，代理服务器是运行在防火墙主机上的专门的应用程序或者服务器程序，用于代表客户处理服务器连接请求</li><li>电路级网关：工作在<strong>会话层</strong>。在两个主机首次建立TCP连接时创立一个电子屏障。<strong>不允许端到端TCP连接</strong>,作为服务器接收外来请求，转发请求；与被保护的主机连接时则担当客户机角色，起代理服务的作用。</li></ul></blockquote><h4 id="体系结构-1"><a href="#体系结构-1" class="headerlink" title="体系结构"></a>体系结构</h4><ul><li>双/多宿主机模式：利用多个连接到不同网络的网络接口（网卡）的主机作为堡垒主机</li><li>屏蔽主机模式：路由器+堡垒主机</li><li>屏蔽子网模式：两个包过滤路由器+堡垒主机，建立了一个被隔离的子网DMZ（充当了内部网络和外部网络的缓冲区，在内部网络与外部网络之间形成了一个“隔离带”）</li></ul><h4 id="SOCKS"><a href="#SOCKS" class="headerlink" title="SOCKS"></a>SOCKS</h4><p>SOCKS（Protocol for sessions traversal across firewall securely，防火墙安全会话转换协议） 是一种基于传输层的网络代理协议。<br>SOCKS 利用网络防火墙将组织内部的网络结构与外部网络（如 Internet）有效地隔离开来<br>SOCKS代理只是简单地传递数据包，而不必关心传输的是何种应用协议,1080port。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网安导论 </tag>
            
            <tag> 夏令营复试资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中基本的神经网络模型总结</title>
      <link href="2020/07/07/CNN-RNN-DNN/"/>
      <url>2020/07/07/CNN-RNN-DNN/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;深度学习大热之后发展出各种神经网络，我虽然之前接触过相关的一些模型，但知识零零散散，感觉一头雾水。这篇文章主要涉及一些基本的神经网络模型，旨在加强对这些模型的系统认知。</p><a id="more"></a><h3 id="有监督的神经网络-Supervised-Neural-Networks"><a href="#有监督的神经网络-Supervised-Neural-Networks" class="headerlink" title="有监督的神经网络(Supervised Neural Networks)"></a>有监督的神经网络(Supervised Neural Networks)</h3><h4 id="NN和DNN"><a href="#NN和DNN" class="headerlink" title="NN和DNN"></a>NN和DNN</h4><p>&emsp;&emsp;NN的基础模型是感知机(Perceptron)，因此NN也可以叫做多层感知机(Multi-layer Perceptron，MLP)。单层感知机叫做感知机，多层感知机(MLP)≈人工神经网络(ANN)。</p><p>&emsp;&emsp;<strong>网络的层数直接决定了其对现实的刻画能力</strong>——利用每层更少的神经元拟合更复杂的函数。但层数加深意味着：</p><ul><li>“<strong>梯度消失</strong>”(gradient vanish)更加严重，反向传播梯度时，梯度指数衰减导致低层几乎接收不到信号；</li><li>更容易<strong>陷入局部最优</strong>而越来越偏离全局最优。在数据量不足时，深层网络的性能甚至不如浅层网络；</li><li>更容易<strong>过拟合</strong>。</li></ul><p>&emsp;&emsp;一般来说，多个隐藏层(通常为超过5层)的NN都可以叫做DNN，NN的结构指神经元的连接方式，下图为3种不同的例子，神经元的连接可以是任意深度的。</p><p><img src="https://pic2.zhimg.com/80/v2-5a3fb8e97514931eebc72394e0196e65_720w.jpg" alt=""></p><p>图片来源：<a href="https://link.zhihu.com/?target=http%3A//www.turingfinance.com/misconceptions-about-neural-networks/">10 Misconceptions about Neural Networks</a></p><p>&emsp;&emsp;DNN可以解决大部分分类任务，但是DNN的参数量很大，需要的数据量也很大，因此纯粹的全连接层应用性不强。(CNN和RNN一般结构都比较深；AE则可以是浅层或深层的，所以会有Deep Auto Encoder这样的词汇而通常没有Deep CNN/RNN。)</p><h4 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h4><p>&emsp;&emsp;CNN的精髓是<strong>在多个空间位置上共享参数</strong>，从而压缩输入端的维度，避免参数数量的膨胀。</p><ul><li>以“卷积核”为上下层神经元提供间接连接方式。</li><li>通过卷积和池化，在压缩维度的同时，挖掘和提取了局部结构的特征。</li></ul><p><img src="https://bkimg.cdn.bcebos.com/pic/ae51f3deb48f8c541f6a0cdd36292df5e1fe7f83?x-bce-process=image/resize,m_lfit,w_220,h_220,limit_1" alt=""></p><p>&emsp;&emsp;CNN的输入通常和图片联系，实际上，CNN可以处理大部分格状结构化数据(Grid-like Data)。例如，图片像素是二维的格状数据，时间序列在等时间上抽取相当于一维的的格状数据，而视频数据可以理解为对应视频帧宽度、高度、时间的三维数据。</p><h4 id="循环神经网络-Recurrent-NN-和递归神经网络-Recursive-NN"><a href="#循环神经网络-Recurrent-NN-和递归神经网络-Recursive-NN" class="headerlink" title="循环神经网络(Recurrent NN)和递归神经网络(Recursive NN)"></a>循环神经网络(Recurrent NN)和递归神经网络(Recursive NN)</h4><p>&emsp;&emsp;这两种网络通常都叫RNN，虽然网络结构不同，但是都可以处理序列问题。在RNN中，每一层在t时刻的输入，不仅包含上一层在t时刻的输出，还包含自身在t-1时刻的输出，如下图所示，某一时刻的输出，理论上<strong>由该时刻和之前的所有输入决定</strong>，换言之，RNN拥有“记忆”能力，可以学习序列间的依赖关系。</p><p><img src="https://pic4.zhimg.com/80/c2eb9099048761fd25f0e90aa66d363a_720w.jpg" alt=""></p><p>&emsp;&emsp;RNN实际上可以看成一个在时间上传递的网络，时间序列长度就是它的深度。那么问题来了，“gradient vanish”也会在RNN的时间轴上出现，f<sup>t</sup>反向传播梯度时，并不足以影响遥远的过去，因此ML领域发展出了LSTM(Long Short-term Memory)。</p><p>&emsp;&emsp;LSTM处理序列问题有效的关键在于Gate，Gate是一种让信息选择式通过的方法。</p><ul><li>forget gate: 控制上一时刻cell状态c<sub>t-1</sub>有多少保留到c<sub>t</sub>;</li><li>input state: 控制当前时刻网络输入x<sub>t-1</sub>有多少保存到c<sub>t</sub>;</li><li>output: 控制当前时刻cell状态c<sub>t</sub>有多少输出到h<sub>t</sub>;</li></ul><p>&emsp;&emsp;类似地，Bi-RNN(双向RNN)中“现在”依赖于“过去”和“未来”，可以使输出取决于上下文，常在NLP和语音分析中使用。Recursive NN和Recurrent NN结构不同，是树状而不是网状，可以用树状降低序列的长度。</p><hr><h3 id="无监督的预训练网络-Unsupervised-Pre-trained-Neural-Networks"><a href="#无监督的预训练网络-Unsupervised-Pre-trained-Neural-Networks" class="headerlink" title="无监督的预训练网络(Unsupervised Pre-trained Neural Networks)"></a>无监督的预训练网络(Unsupervised Pre-trained Neural Networks)</h3><h4 id="深度生成模型-Deep-Generative-Models"><a href="#深度生成模型-Deep-Generative-Models" class="headerlink" title="深度生成模型(Deep Generative Models)"></a>深度生成模型(Deep Generative Models)</h4><h5 id="玻尔兹曼机-Boltzmann-Machines-与RBM"><a href="#玻尔兹曼机-Boltzmann-Machines-与RBM" class="headerlink" title="玻尔兹曼机(Boltzmann Machines)与RBM"></a>玻尔兹曼机(Boltzmann Machines)与RBM</h5><p>&emsp;&emsp;BM是一个基于能量的模型，能量越小，对应状态的概率越大。对于给定数据集，如果不知道潜在的分布形式，则学习过程是非常困难的，但是统计力学的结论表明，任何概率分布都可以转变成基于能量的模型，这是一种学习概率分布的方法。</p><p>&emsp;&emsp;RBM限定了其结构必须是二分图(Biparitite Graph)且隐藏层和可观测层之间不可以相连接。</p><h5 id="深度信念网络-Deep-Belief-Neural-Networks"><a href="#深度信念网络-Deep-Belief-Neural-Networks" class="headerlink" title="深度信念网络(Deep Belief Neural Networks)"></a>深度信念网络(Deep Belief Neural Networks)</h5><p>&emsp;&emsp;DBN由两个部分/阶段组成：</p><ul><li>用堆叠的受限玻尔兹曼机(Stacked RBM)进行预训练(unsupervised)，用于特征抽取并重建。</li><li>用一层普通的前馈网络进行微调，用于学习得到的复杂特征。</li></ul><h4 id="生成式对抗网络-Generative-Adversarial-Networks"><a href="#生成式对抗网络-Generative-Adversarial-Networks" class="headerlink" title="生成式对抗网络(Generative Adversarial Networks)"></a>生成式对抗网络(Generative Adversarial Networks)</h4><p>&emsp;&emsp;GAN同时训练两个模型(体现了博弈论的思想)：</p><ul><li>生成网络Generator： 用于生成图片使其与训练数据类似，一般是deconvolutional layer。</li><li>判别网络Discriminator：用于判断生成的图片是训练数据还是伪装的数据，一般是CNN。</li></ul><h4 id="自编码器-Auto-encoder"><a href="#自编码器-Auto-encoder" class="headerlink" title="自编码器(Auto-encoder)"></a>自编码器(Auto-encoder)</h4><p>&emsp;&emsp;AE主要有两个部分：</p><ul><li>Encoder</li><li>Decoder</li></ul><p><img src="https://pic1.zhimg.com/80/v2-0fc0cf8aabcd0321ebf09a8e0e9c9bc8_720w.jpg" alt=""></p><p>&emsp;&emsp;模型学习的是中间的低维压缩表示，并以重建误差来评估AE的性能。实际上AE主要用于降维，与PCA类似，从高维原始数据中提取低维特征。</p><h3 id="OVER"><a href="#OVER" class="headerlink" title="OVER"></a>OVER</h3>]]></content>
      
      
      <categories>
          
          <category> DeepLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/07/07/hello-world/"/>
      <url>2020/07/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
